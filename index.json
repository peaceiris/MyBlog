[{"categories":null,"contents":"This is my first attempt at writing Racket or LISP code. It might be ugly \u0026hellip; For now, let\u0026rsquo;s build a web crawler, next, I shall write myself a language. That\u0026rsquo;s where Racket really shine.\nThe code is here. Thanks to Mike for reviewing it.\nWhy I want to translate a website, including recursively reached pages, to a pdf to read on my e-reader. This program does the first step: going from a URL to a list of URLs by recursively navigating the links on the page.\nThe PS1Script directory contains scripts to perfrom the other steps:\n Translate all the links to PDF pages (using Chrome headless). Combine all the PDFs to a single document (using cpdf).  Prelude First you declare which language you are using. Racket is a language to build languages and the language itself is just one of many (try rereading this phrase).\n#lang racket We then expose the main functions of the library. Aka recursively getting all links from a webpage to a certain nesting level both as a Racket list and as a newline delimitated string.\n; Provides functions to extract links from web pages recursively (provide ; uriString nestingLevels -\u0026gt; list of uriStrings ; Doesn\u0026#39;t follow links to non-html resources or pointing to a different domain then uriString. uri-\u0026gt;nestedLinks ; uriSTring nestingLevels -\u0026gt; string of newline separated Uri Strings uri-\u0026gt;nestedLinksNl)Implementation This is similar, but not identical, to C# using statement as you declare which packages are needed.\n(require (planet neil/html-parsing:2:0) net/url xml html sxml/sxpath threading)The program crawl just links to html files in the same domain as the first URI given to it. It is possible to extend this more by having the program take a regular expression (or * expression) to identify which file sto leave out of the crawling.\n(define invalid-suffixes \u0026#39;(\u0026#34;./\u0026#34; \u0026#34;.xml\u0026#34; \u0026#34;.jpg\u0026#34; \u0026#34;.jpeg\u0026#34; \u0026#34;.png\u0026#34; \u0026#34;.gif\u0026#34; \u0026#34;.tiff\u0026#34; \u0026#34;.psd\u0026#34; \u0026#34;.eps\u0026#34; \u0026#34;.ai\u0026#34; \u0026#34;.indd\u0026#34; \u0026#34;.raw\u0026#34; \u0026#34;.svg\u0026#34;)) (define invalid-prefixes \u0026#39;(\u0026#34;#\u0026#34; \u0026#34;mailto:\u0026#34; \u0026#34;javascript:\u0026#34;)) (define (different-domain? baseUrl l) (define url (string-\u0026gt;url l)) (and (url-host url) (not (equal? (url-host baseUrl) (url-host url))))) (define (good-link? baseUrl l) (not (or (different-domain? baseUrl l) (ormap (curry string-suffix? l) invalid-suffixes) (ormap (curry string-prefix? l) invalid-prefixes))))Next we have to parse the HTML. We use XPath for that. Racket is particularly good for XML parsing as it maps naturally to expressions which are the bread and butter of the language. I don\u0026rsquo;t enjoy the nesting of expressions that LISP like languages force onto you (as in the expression below). But see later for a partial solution.\n(define (xexp-\u0026gt;links xexp) (flatten (map cdr ((sxpath \u0026#34;//a/@href\u0026#34;) xexp))))The strange ~\u0026gt;\u0026gt; operator in the code below comes from the Threading package. This set of macros lets you build pipelines of computations similarly to the F# |\u0026gt; operator. The initial value comes first and then the functions are applied in series each one to the result of the previous. By doing that you \u0026lsquo;flatten\u0026rsquo; the nested expressions, making them more readable (at least to my eyes).\nThis capability of changing the core behavior of the language is something very peculiar to the LISP family, and the reaason why I am attracted to Racket in the first place.\nThis function extracts all the \u0026lsquo;good\u0026rsquo; links from a url. BTW: I love that you can use -\u0026gt; to name symbols.\n(define (url-\u0026gt;links url) (~\u0026gt;\u0026gt; (call/input-url url get-pure-port html-\u0026gt;xexp) xexp-\u0026gt;links (filter (curry good-link? url))))λ~\u0026gt; is the function composition operator in the \u0026lsquo;Threading\u0026rsquo; library. You got to love embedding lambdas in the code.\n(define uri-\u0026gt;links (λ~\u0026gt; string-\u0026gt;url url-\u0026gt;links))This is the main recursive workhorse of the program. It works something like this (numbers marked in the code):\nTreat links to subparts of a web page as if they were links to the webpage If it is not a good link, return the links already visited (visited) Same thing if the link is alread in visited If we reached the nesting level specified, add the link to visited and return \u0026lsquo;visited\u0026rsquo; Otherwise add the link to visited and call yourself on all sublinks on the page  The function is not tail recursive, but that is not a huge deal in Racket as the stack is very large. It doesn\u0026rsquo;t blow up as easily as in most other languages.\n(define (uri-\u0026gt;nestedLinks-rec baseUrl uri visited levels) (define abs-url (if (string-contains? uri \u0026#34;#\u0026#34;) ; \u0026lt;0\u0026gt; (~\u0026gt; uri (string-split \u0026#34;#\u0026#34;) first (combine-url/relative baseUrl _)) (~\u0026gt;\u0026gt; uri (combine-url/relative baseUrl)))) (log-info \u0026#34;~a, ~a, ~a:~a~n\u0026#34; (url-\u0026gt;string baseUrl) levels uri (url-\u0026gt;string abs-url)) (cond [(not (good-link? baseUrl uri)) visited] ; \u0026lt;1\u0026gt; [(member abs-url visited) visited] ; \u0026lt;2\u0026gt; [(zero? levels) (cons abs-url visited)] ; \u0026lt;3\u0026gt; [else (for/fold ([acc (cons abs-url visited)]) ;\u0026lt;4\u0026gt; ([l (in-list (url-\u0026gt;links abs-url))]) (uri-\u0026gt;nestedLinks-rec abs-url l acc (sub1 levels)))]))Finally we can trivially define the two main functions in the module.\n(define (uri-\u0026gt;nestedLinks uri levels) (reverse (uri-\u0026gt;nestedLinks-rec (string-\u0026gt;url uri) \u0026#34;\u0026#34; \u0026#39;() levels))) (define (uri-\u0026gt;nestedLinksNl uri levels) (define links (uri-\u0026gt;nestedLinks uri levels)) (string-join (map url-\u0026gt;string links) \u0026#34;\\n\u0026#34; #:after-last \u0026#34;\\n\u0026#34;))Test To my great pleasure, Racket allows (encourages?) you to have tests in the same file as the code. They just go into sub modules, that can be constructed piecewise with the module+ instruction.\nYou could add the tests beside each function, but I decided to have a separate section in the file instead. To run them you call raco test FILENAME.\n(define (uri-\u0026gt;path test-uri) (build-path \u0026#34;./data\u0026#34; (~\u0026gt; test-uri first uri-\u0026gt;file string-\u0026gt;path))) (define uri-\u0026gt;file (λ~\u0026gt; string-\u0026gt;url url-host)) (define test-uris \u0026#39;( (\u0026#34;https://www.lucabol.com\u0026#34; 3) (\u0026#34;https://beautifulracket.com/\u0026#34; 3) (\u0026#34;https://en.wikipedia.org/wiki/Typeface\u0026#34; 1) (\u0026#34;https://brieferhistoryoftime.com\u0026#34; 3) (\u0026#34;https://mobydick.wales/\u0026#34; 3) (\u0026#34;https://resilientwebdesign.com\u0026#34; 3) (\u0026#34;https://www.c82.net/euclid/\u0026#34; 3) )) (module+ test (require rackunit)I got a bit sloppy not naming my lambdas here \u0026hellip; But, doesn\u0026rsquo;t the lambda symbol look cool?\n(for-each (λ (test-uri) (with-input-from-file (uri-\u0026gt;path test-uri) (λ () (begin (define saved-result (port-\u0026gt;string)) (define calc-result (uri-\u0026gt;nestedLinksNl (first test-uri) (second test-uri))) (check-equal? calc-result saved-result test-uri))) #:mode \u0026#39;text )) test-uris))This is used to regenerate the test data. You can then inspect it manually before running tests.\n(define (refresh-test-data) (for-each (λ (test-uri) (with-output-to-file (uri-\u0026gt;path test-uri) (λ () (display (uri-\u0026gt;nestedLinksNl (first test-uri) (second test-uri)))) #:exists \u0026#39;replace)) test-uris))Main Main goes into its own submodule as well. Racket is not as pure as Haskell, so you can naturally manage side effects like user input and such. You got to appreciate the concisivness of the command line parsing library.\nThe code below looks a bit odd to me. It could probably be refactored so that the parser expression returns the values instead of filling out parameters.\n(module+ main (define levels (make-parameter \u0026#34;3\u0026#34;)) (define uri (make-parameter #f)) (define parser (command-line #:program \u0026#34;website-links\u0026#34; #:usage-help \u0026#34;Extracts links from a webpage recursively to a specified level.\u0026#34; #:once-each [(\u0026#34;-l\u0026#34; \u0026#34;--levels\u0026#34;) LEVELS \u0026#34;How many nested levels to process (default 3).\u0026#34; (levels LEVELS)] #:args (URI) (uri URI))) (display (uri-\u0026gt;nestedLinksNl (uri) (string-\u0026gt;number (levels))))) Conclusion I liked Racket very much. It takes a little while to get use to the expression syntax, which is very different from the C-like one most of us are used to. It also takes a while to get used to the style of the documentation, which is written very precisely for the careful reader. We are more used to the \u0026lsquo;here is an example, copy it\u0026rsquo; kind of documentation. For the distracted programmer \u0026hellip;\n","permalink":"https://peaceiris.com/MyBlog/posts/2020-05-11-recursively-extracting-sensted-links-from-a-webpage-using-racket/","tags":["racket","functional-programming"],"title":"Recursively extracting nested links from a webpage using Racket"},{"categories":null,"contents":"In the process of chosing fonts for my blog, I looked for lists of words containing characters that can be easily confused.\nI took this one from here.\n Henry III - Henry lII - Henry 111 - Henry tll - Henry t7I\nHenry l - Henry 1 - Henry I - Henry 7\ni j, B 8, D 0, O 0, o 0, k R, a o, f F , r v Y, B 8, g q, a g, J I, J L, l !, u v, U V, 5 S, B 8, a o, rn m, vv w, Z 2, C G, Q O, ISO 150, go 90, LJ IJ LI Ll L1 U, LU LLI UU W, LILI UU, CI O 0, \u0026lt;j (J (j (T\nclear dear, burn bum, skivvy skiwy, CS5 CSS, 105 IOS, z2 22, 5AM SAM, travel bavel, LJ U, MENSUR SULJOVIC, 6 9, ce œ, amazon.corn amazon.com mac.com rnac.com, Ox0 0OR\nminnimalistI1llI\nHenry III - Henry lII - Henry 111 - Henry tll - Henry t7I Henry l - Henry 1 - Henry I - Henry 7 i j, B 8, D 0, O 0, o 0, k R, a o, _f_ _F_ , r v Y, B 8, g q, a g, J I, J L, l !, u v, U V, 5 S, B 8, a o, rn m, vv w, Z 2, C G, Q O, ISO 150, go 90, LJ IJ LI Ll L1 U, LU LLI UU W, LILI UU, CI O 0, \u0026lt;j (J (j (T clear dear, burn bum, skivvy skiwy, CS5 CSS, 105 IOS, z2 22, 5AM SAM, travel bavel, LJ U, MENSUR SULJOVIC, 6 9, ce œ, amazon.corn amazon.com mac.com rnac.com, Ox0 0OR minnimalistI1llI ","permalink":"https://peaceiris.com/MyBlog/posts/2020-03-19-confusing-characters-in-text/","tags":["typography"],"title":"Confusing characters in text"},{"categories":null,"contents":"I am not sure why I have not blogged about this. We have released some very nice PS1 libraries to automate the usage of Azure Lab Services and Azure DevTest Labs.\nThe nicest thing about them is how they make use of the PS1 Pipeline to give a nice user experience.\nGet-AzLabAccount | Get-AzLab | Get-AzLabVm -Status Running | Stop-AzLabVm I intend to shoot some brief videos to describe how to use them. In the meantime, you can read tutorials here and here\n","permalink":"https://peaceiris.com/MyBlog/posts/2020-01-06-introducing-ps1-libraries-for-azure-lab-services-and-devtest-lab/","tags":["lab-services","devtest-labs"],"title":"Introducing PS1 Libraries for Azure Lab Services and DevTest Labs"},{"categories":null,"contents":"Abstract Writing C# functional code has become easier with each new release of the language (i.e. nullable ref types, tuples, switch expr, \u0026hellip;). This document presents a review of the current status of basic functional features for C# 8.0. It focuses mostly on syntax and aims to achieve its goal using code examples. It doesn\u0026rsquo;t touches on more advanced topics as Monad, Functors, etc \u0026hellip;\nHaskell has been chosen as the \u0026lsquo;comparison\u0026rsquo; language (using few examples from here and elsewhere). This is not intended as a statement of value of one language vs the other. The languages are profoundly different in underlying philosophies. They both do much more than what is presented here (i.e. C# supports OO and imperative style, while Haskell goes much deeper in type system power etc\u0026hellip;).\nI also present samples of usage of language-ext to show what can be achieved in C# using a functional library.\nUsing a library of functions In C# you can use static functions as if they were \u0026lsquo;floating\u0026rsquo; by importing the static class they are defined to with the syntax using static CLASSNAME. Below an example of both importing Console.WriteLine and using it.\nusing System; using System.IO; using LanguageExt; using LanguageExt.TypeClasses; using LanguageExt.ClassInstances; using System.Collections.Generic; using static System.Console; using static System.Linq.Enumerable; using static System.Math; using static LanguageExt.Prelude; public static class Core { static void UseFunc() =\u0026gt; WriteLine(\u0026#34;System.WriteLine as a floating function\u0026#34;); Writing simple functions In Haskell, a simple function might be written as:\nsquare :: Num a =\u0026gt; a -\u0026gt; a square x = x * x Which in C# looks like the below.\nstatic int Square(int x) =\u0026gt; x * x; As an aside, note that we lose the generality of the function (i.e. we need a different one for doubles).This is due to the lack of ad-hoc polymorphism in C#. By using language-ext, you can fake it so that it looks like this:\nstatic A Square\u0026lt;NumA, A\u0026gt;(A x) where NumA : struct, Num\u0026lt;A\u0026gt; =\u0026gt; default(NumA).Product(x, x); static void SquarePoly() { WriteLine(Square\u0026lt;TInt, int\u0026gt;(2)); WriteLine(Square\u0026lt;TDouble, double\u0026gt;(2.5)); } In Haskell, it is conventional to write the type of a function before the function itself. In C# you can use Func and Action to achieve a similar goal (aka seeing the types separately from the function implementation), despite with more verbose syntax, as below:\nstatic Func\u0026lt;int, int\u0026gt; SquareF = x =\u0026gt; x * x; Pattern matching Here is an example in Haskell:\nlucky :: (Integral a) =\u0026gt; a -\u0026gt; String lucky 7 = \u0026#34;LUCKY NUMBER SEVEN!\u0026#34; lucky x = show x In C#, you can write it in a few ways. Either as a function static property \u0026hellip;\nstatic Func\u0026lt;int, string\u0026gt; Lucky = x =\u0026gt; x switch { 7 =\u0026gt; \u0026#34;LUCKY NUMBER SEVEN!\u0026#34;, _ =\u0026gt; x.ToString() }; Or with a normal function:\nstatic string Lucky1(int x) =\u0026gt; x switch { 7 =\u0026gt; \u0026#34;LUCKY NUMBER SEVEN!\u0026#34;, _ =\u0026gt; x.ToString() }; Or even using the ternary operator (a perennial favorite of mine).\nstatic string Lucky2(int x) =\u0026gt; x == 7 ? \u0026#34;LUCKY NUMBER SEVEN!\u0026#34; : x.ToString(); Pattern matching on tuples works with similar syntax:\nstatic bool And(bool x, bool y) =\u0026gt; (x, y) switch { (true, true) =\u0026gt; true, _ =\u0026gt; false }; In Haskell you can match on lists as follows:\nsum :: Num a =\u0026gt; [a] -\u0026gt; a sum [] = 0 sum (x:xs) = x + sum xs Writing this in standard C# looks like this:\nstatic int Sum(IEnumerable\u0026lt;int\u0026gt; l) =\u0026gt; l.Count() == 0 ? 0 : l.First() + Sum(l.Skip(1)); static int Sum1(IEnumerable\u0026lt;int\u0026gt; l) =\u0026gt; l.Count() switch { 0 =\u0026gt; 0, _ =\u0026gt; l.First() + Sum(l.Skip(1)) }; Language-ext gives you a simpler syntax, with more flexibility on what you can match against:\nstatic int Sum2(Seq\u0026lt;int\u0026gt; l) =\u0026gt; match(l, () =\u0026gt; 0, (x, xs) =\u0026gt; x + Sum1(xs)); Obviously you always have to be careful with recursion in C# (here). Better use the various methods on Enumerable.\nGuards (and case expressions) Let\u0026rsquo;s explore guards. Case expressions have an identical translation in C#.\nIn Haskell guards are used as below:\nbmiTell :: (RealFloat a) =\u0026gt; a -\u0026gt; a -\u0026gt; String bmiTell weight height | weight / height ^ 2 \u0026lt;= 18.5 = \u0026#34;Under\u0026#34; | weight / height ^ 2 \u0026lt;= 25.0 = \u0026#34;Normal\u0026#34; | weight / height ^ 2 \u0026lt;= 30.0 = \u0026#34;Over\u0026#34; | otherwise = \u0026#34;Way over\u0026#34; Which can be coded in C# as:\nstatic string BmiTell(double weight, double height) =\u0026gt; (weight, height) switch { _ when Pow(weight / height, 2) \u0026lt;= 18.5 =\u0026gt; \u0026#34;Under\u0026#34;, _ when Pow(weight / height, 2) \u0026lt;= 25.0 =\u0026gt; \u0026#34;Normal\u0026#34;, _ when Pow(weight / height, 2) \u0026lt;= 30.0 =\u0026gt; \u0026#34;Over\u0026#34;, _ =\u0026gt; \u0026#34;Way over\u0026#34; }; Obviously this is quite bad. You would like something more like:\nbmiTell :: (RealFloat a) =\u0026gt; a -\u0026gt; a -\u0026gt; String bmiTell weight height | bmi \u0026lt;= skinny = \u0026#34;Under\u0026#34; | bmi \u0026lt;= normal = \u0026#34;Normal\u0026#34; | bmi \u0026lt;= fat = \u0026#34;Over\u0026#34; | otherwise = \u0026#34;Way Over\u0026#34; where bmi = weight / height ^ 2 skinny = 18.5 normal = 25.0 fat = 30.0 But it is not trivial in C# to declare variables in expression bodied members. You can either move it to a normal method or abuse the LINQ query syntax. Both shown below. Notice that this is more similar to let expressions in Haskell, as they come before the expression, not after.\nstatic string BmiTell1(double weight, double height) { double bmi = Pow(weight / height, 2), skinny = 18.5, normal = 25.0, fat = 30; return bmi switch { _ when bmi \u0026lt;= skinny =\u0026gt; \u0026#34;Under\u0026#34;, _ when bmi \u0026lt;= normal =\u0026gt; \u0026#34;Normal\u0026#34;, _ when bmi \u0026lt;= fat =\u0026gt; \u0026#34;Over\u0026#34;, _ =\u0026gt; \u0026#34;Way over\u0026#34; }; } static string BmiTell2(double weight, double height) =\u0026gt; ( from _ in \u0026#34;x\u0026#34; let bmi = Pow(weight / height, 2) let skinny = 18.5 let normal = 25.0 let fat = 30 select bmi \u0026lt;= skinny ? \u0026#34;Under\u0026#34; : bmi \u0026lt;= normal ? \u0026#34;Normal\u0026#34; : bmi \u0026lt;= fat ? \u0026#34;Over\u0026#34; : \u0026#34;Way over\u0026#34;).First(); Product types (aka Records) In Haskell you define a product type as below:\ndata Person = Person { firstName :: String , lastName :: String , age :: Int } deriving (Show) In C#, it is currently complicated to define an immutable product type with structural equality, structural ordering and efficient hashing.\nIn essence, you have to implement a bunch of interfaces and operators, somehow similar to below (and I am not implementing ordering, and it is probably not too efficient either).\npublic readonly struct PersonData: IEquatable\u0026lt;PersonData\u0026gt; { public readonly string FirstName; public readonly string LastName; public readonly int Age; public PersonData(string first, string last, int age) =\u0026gt; (LastName, FirstName, Age) = (last, first, age); public override int GetHashCode() =\u0026gt; (FirstName, LastName, Age).GetHashCode(); public override bool Equals(object other) =\u0026gt; other is PersonData l \u0026amp;\u0026amp; Equals(l); public bool Equals(PersonData oth) =\u0026gt; LastName == oth.LastName \u0026amp;\u0026amp; FirstName == oth.FirstName \u0026amp;\u0026amp; Age == oth.Age; public static bool operator ==(PersonData lhs, PersonData rhs) =\u0026gt; lhs.Equals(rhs); public static bool operator !=(PersonData lhs, PersonData rhs) =\u0026gt; !(lhs == rhs); } If you use a struct, you are still open to someone simply newing it using the default constructor, that you can\u0026rsquo;t make private.\nUsing a class (as below) avoids that, but loses the pass by value semantic.\npublic class PersonData1 : IEquatable\u0026lt;PersonData1\u0026gt; { public readonly string FirstName; public readonly string LastName; public readonly int Age; public PersonData1(string first, string last, int age) =\u0026gt; (LastName, FirstName, Age) = (last, first, age); public override int GetHashCode() =\u0026gt; (FirstName, LastName, Age).GetHashCode(); public override bool Equals(object oth) =\u0026gt; oth is PersonData l \u0026amp;\u0026amp; Equals(l); public bool Equals(PersonData1 other) =\u0026gt; LastName == other.LastName \u0026amp;\u0026amp; FirstName == other.FirstName \u0026amp;\u0026amp; Age == other.Age; public static bool operator ==(PersonData1 lhs, PersonData1 rhs) =\u0026gt; lhs.Equals(rhs); public static bool operator !=(PersonData1 lhs, PersonData1 rhs) =\u0026gt; !(lhs == rhs); } So, there is no easy fix. Using Language-ext you can do it much more simply, by inheritance. But obviously it uses IL generation that is slow the first time around. Try running the code and notice the delay when IL generating.\npublic class PersonData2 : Record\u0026lt;PersonData2\u0026gt; { public readonly string FirstName; public readonly string LastName; public readonly int Age; public PersonData2(string first, string last, int age) =\u0026gt; (LastName, FirstName, Age) = (last, first, age); } Sum types (aka Discriminated Union) In Haskell you write:\ndata Shape = Circle Float Float Float | Rectangle Float Float Float Float | NoShape deriving (Show) There is no obvious equivalent in C#, and different libraries has sprung up to propose possible solutions (but not language-ext) (i.e. here or here).\nOne possible \u0026lsquo;pure language\u0026rsquo; implementation, not considering structural equality/ordering/hash, follows:\nabstract class Shape { public sealed class NoShape : Shape { } public sealed class Circle : Shape { internal Circle(double r) =\u0026gt; Radius = r; public readonly double Radius; } public sealed class Rectangle : Shape { internal Rectangle(double height, double width) =\u0026gt; (Height, Width) = (height, width); public readonly double Height; public readonly double Width; } } static Shape.Circle Circle(double x) =\u0026gt; new Shape.Circle(x); static Shape.Rectangle Rectangle(double x, double y) =\u0026gt; new Shape.Rectangle(x,y); static Shape.NoShape NoShape() =\u0026gt; new Shape.NoShape(); You can then pattern match on it in various obvious ways:\nstatic double Area(Shape s) =\u0026gt; s switch { Shape.NoShape _ =\u0026gt; 0, Shape.Circle {Radius: var r } =\u0026gt; Pow(r, 2) * PI, Shape.Rectangle r =\u0026gt; r.Height * r.Width, _ =\u0026gt; throw new Exception(\u0026#34;No known shape\u0026#34;) }; static void CalcAreas() { var c = Circle(10); var r = Rectangle(10, 3); var n = NoShape(); WriteLine(Area(c)); WriteLine(Area(r)); WriteLine(Area(n)); } Maybe (Or Option) type In Haskell you write:\nf::Int -\u0026gt; Maybe Int f 0 = Nothing f x = Just x g::Maybe Int -\u0026gt; Int g Nothing = 0 g (Just x) = x In C#, this easily translates to Nullable value and reference types. Assume you have Nullable = enabled in your project\nstatic int? F(int i) =\u0026gt; i switch { 0 =\u0026gt; new Nullable\u0026lt;int\u0026gt;(), _ =\u0026gt; i }; static int G(int? i) =\u0026gt; i ?? 0; Main Method Let\u0026rsquo;s wrap all the samples with a Main function and then write a full program.\nstatic void Main() { UseFunc(); SquarePoly(); WriteLine(Square(2) == SquareF(2)); WriteLine(Sum(new[] { 1, 2, 3, 4 }) == Sum1(new[] { 1, 2, 3, 4 })); WriteLine(Sum1(new[] { 1, 2, 3, 4 }) == Sum2(new[] { 1, 2, 3, 4 }.ToSeq())); WriteLine(BmiTell(80, 100) == BmiTell1(80, 100)); WriteLine(BmiTell(80, 100) == BmiTell2(80, 100)); WriteLine(new PersonData(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40) == new PersonData(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40)); WriteLine(new PersonData1(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40) == new PersonData1(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40)); WriteLine(\u0026#34;Before IL gen\u0026#34;); WriteLine(new PersonData2(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40) == new PersonData2(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40)); WriteLine(new PersonData2(\u0026#34;Alphie\u0026#34;, \u0026#34;Blake\u0026#34;, 40) \u0026lt;= new PersonData2(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40)); WriteLine(\u0026#34;Already genned\u0026#34;); WriteLine(new PersonData2(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40) == new PersonData2(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40)); WriteLine(new PersonData2(\u0026#34;Alphie\u0026#34;, \u0026#34;Blake\u0026#34;, 40) \u0026lt;= new PersonData2(\u0026#34;Bob\u0026#34;, \u0026#34;Blake\u0026#34;, 40)); CalcAreas(); Hangman.Core.MainHangman(); } } Full program Let\u0026rsquo;s finish with a semi-working version of Hangman, from an exercise in Haskell programming from first principles, just to get an overall impression of how the two languages look for bigger things.\nThe exercise was a fill-in-the-blanks kind of thing with the function names and types given, so I don\u0026rsquo;t think I butcher it too badly, but maybe not.\nThe Haskell code is:\nmodule Main where import Control.Monad (forever) -- [1] import Data.Char (toLower) -- [2] import Data.Maybe (isJust) -- [3] import Data.List (intersperse) -- [4] import System.Exit (exitSuccess) -- [5] import System.Random (randomRIO) -- [6] type WordList = [String] allWords :: IO WordList allWords = do dict \u0026lt;- readFile \u0026#34;data/dict.txt\u0026#34; return (lines dict) minWordLength :: Int minWordLength = 5 maxWordLength :: Int maxWordLength = 9 gameWords :: IO WordList gameWords = do aw \u0026lt;- allWords return (filter gameLength aw) where gameLength w = let l = length (w :: String) in l \u0026gt; minWordLength \u0026amp;\u0026amp; l \u0026lt; maxWordLength randomWord :: WordList -\u0026gt; IO String randomWord wl = do randomIndex \u0026lt;- randomRIO ( 0, length wl - 1) return $ wl !! randomIndex randomWord\u0026#39; :: IO String randomWord\u0026#39; = gameWords \u0026gt;\u0026gt;= randomWord data Puzzle = Puzzle String [Maybe Char] [Char] instance Show Puzzle where show (Puzzle _ discovered guessed) = (intersperse \u0026#39; \u0026#39; $ fmap renderPuzzleChar discovered) ++ \u0026#34;Guessed so far: \u0026#34; ++ guessed freshPuzzle :: String -\u0026gt; Puzzle freshPuzzle s = Puzzle s (map (const Nothing) s) [] charInWord :: Puzzle -\u0026gt; Char -\u0026gt; Bool charInWord (Puzzle s _ _) c = c `elem` s alreadyGuessed :: Puzzle -\u0026gt; Char -\u0026gt; Bool alreadyGuessed (Puzzle _ _ s) c = c `elem` s renderPuzzleChar :: Maybe Char -\u0026gt; Char renderPuzzleChar Nothing = \u0026#39;_\u0026#39; renderPuzzleChar (Just c) = c fillInCharacter :: Puzzle -\u0026gt; Char -\u0026gt; Puzzle fillInCharacter (Puzzle word filledInSoFar s) c = Puzzle word newFilledInSoFar (c : s) where zipper guessed wordChar guessChar = if wordChar == guessed then Just wordChar else guessChar newFilledInSoFar = zipWith (zipper c) word filledInSoFar handleGuess :: Puzzle -\u0026gt; Char -\u0026gt; IO Puzzle handleGuess puzzle guess = do putStrLn $ \u0026#34;Your guess was: \u0026#34; ++ [guess] case (charInWord puzzle guess, alreadyGuessed puzzle guess) of (_, True) -\u0026gt; do putStrLn \u0026#34;You already guessed that character, pick something else!\u0026#34; return puzzle (True, _) -\u0026gt; do putStrLn \u0026#34;This character was in the word,filling in the word accordingly\u0026#34; return (fillInCharacter puzzle guess) (False, _) -\u0026gt; do putStrLn \u0026#34;This character wasn\u0026#39;t in the word, try again.\u0026#34; return (fillInCharacter puzzle guess) gameOver :: Puzzle -\u0026gt; IO () gameOver (Puzzle wordToGuess _ guessed) = if (length guessed) \u0026gt; 7 then do putStrLn \u0026#34;You lose!\u0026#34; putStrLn $ \u0026#34;The word was: \u0026#34; ++ wordToGuess exitSuccess else return () gameWin :: Puzzle -\u0026gt; IO () gameWin (Puzzle _ filledInSoFar _) = if all isJust filledInSoFar then do putStrLn \u0026#34;You win!\u0026#34; exitSuccess else return () runGame :: Puzzle -\u0026gt; IO () runGame puzzle = forever $ do gameOver puzzle gameWin puzzle putStrLn $ \u0026#34;Current puzzle is: \u0026#34; ++ show puzzle putStr \u0026#34;Guess a letter: \u0026#34; guess \u0026lt;- getLine case guess of [c] -\u0026gt; handleGuess puzzle c \u0026gt;\u0026gt;= runGame _ -\u0026gt; putStrLn \u0026#34;Your guess must be a single character\u0026#34; main :: IO () main = do word \u0026lt;- randomWord\u0026#39; let puzzle = freshPuzzle (fmap toLower word) runGame puzzle Which loosely translate to the code below (pure C#, no language-ext) . A few comments:\n I tried to keep the translation as 1:1 as possible. I used expression bodied members for everything except IO returning function. That\u0026rsquo;s a pleasing convention to me. Things translate rather straightforwardly except for:  Cheated using a simple struct instead of a Record, but often it is ok to do so. Needed to use LINQ query syntax to translate more complex expressions, but cannot have lambadas in it. Needed to do manual currying (language-ext would have beautified that).   The line count for this example is roughly similar. I think that\u0026rsquo;s random. Also the C# code \u0026lsquo;extends to the right\u0026rsquo; more. Notably absent from the code are sum types, which would have been verbose to implement in C#.  namespace Hangman { using WordList = IEnumerable\u0026lt;String\u0026gt;; using static System.Linq.Enumerable; static class Core { const int MinWordLength = 5; const int MaxWordLength = 9; static WordList AllWords =\u0026gt; File.ReadAllLines(\u0026#34;data/dict.txt\u0026#34;); static WordList GameWords =\u0026gt; AllWords.Where(w =\u0026gt; w.Length \u0026gt; MinWordLength \u0026amp;\u0026amp; w.Length \u0026lt; MaxWordLength); static Random r = new Random(); static string RandomWord(WordList wl) =\u0026gt; GameWords.ElementAt(r.Next(0, wl.Length())); static string RandomWord1 =\u0026gt; RandomWord(GameWords); static char RenderPuzzleChar(char? c) =\u0026gt; c ?? \u0026#39;_\u0026#39;; struct Puzzle { // Not implemented Eq and Ord because not needed in this program  public string Word; public IEnumerable\u0026lt;char?\u0026gt; Discovered; public string Guessed; public override string ToString() =\u0026gt; $\u0026#34;{string.Join(\u0026#34; \u0026#34;, Discovered.Select(RenderPuzzleChar))}\u0026#34; + \u0026#34; Guessed so far: \u0026#34; + Guessed; } static Puzzle FreshPuzzle(string s) =\u0026gt; new Puzzle { Word = s, Discovered = s.Select(_ =\u0026gt; new Nullable\u0026lt;char\u0026gt;()), Guessed = \u0026#34;\u0026#34; }; static bool CharInWord(Puzzle p, char c) =\u0026gt; p.Word.Contains(c); static bool AlreadyGuessed(Puzzle p, char c) =\u0026gt; p.Guessed.Contains(c); // Can\u0026#39;t assign lambda expression to range variable with let, hence separate function  static char? Zipper(char guessed, char wordChar, char? guessChar) =\u0026gt; wordChar == guessed ? wordChar : guessChar; // Manual curry. Could use language-ext to make it more beautiful.  static Func\u0026lt;char, char?, char?\u0026gt; Zipper1(char c) =\u0026gt; (c1, c2) =\u0026gt; Zipper(c, c1, c2); static Puzzle FillInCharacter(Puzzle p, char c) =\u0026gt; (from _ in \u0026#34;x\u0026#34; let newFilledInSoFar = System.Linq.Enumerable.Zip\u0026lt;char, char?, char?\u0026gt;(p.Word, p.Discovered, Zipper1(c)) select new Puzzle { Word = p.Word, Discovered = newFilledInSoFar, Guessed = c + p.Guessed }).First(); static Puzzle HandleGuess(Puzzle puzzle, char guess) {// Braces means IO ...  WriteLine($\u0026#34;Your guess was {guess}\u0026#34;); switch (CharInWord(puzzle, guess), AlreadyGuessed(puzzle, guess)) { case (_, true): WriteLine(\u0026#34;You already guessed that character, pick something else!\u0026#34;); return puzzle; case (true, _): WriteLine(\u0026#34;This character was in the word,filling in the word accordingly\u0026#34;); return FillInCharacter(puzzle, guess); case (false, _): WriteLine(\u0026#34;This character wasn\u0026#39;t in the word, try again.\u0026#34;); return FillInCharacter(puzzle, guess); } } static void GameOver(Puzzle p) { if(p.Guessed.Length \u0026gt; 7) { WriteLine(\u0026#34;You lose!\u0026#34;); WriteLine($\u0026#34;The word was {p.Word}\u0026#34;); Environment.Exit(0); } } static void GameWin(Puzzle p) { if(p.Discovered.All(c =\u0026gt; c.HasValue)) { WriteLine(\u0026#34;You win!\u0026#34;); Environment.Exit(0); } } static void RunGame(Puzzle puzzle) { while(true) { GameOver(puzzle); GameWin(puzzle); WriteLine($\u0026#34;Current puzzle is: {puzzle}\u0026#34;); WriteLine(\u0026#34;Guess a letter: \u0026#34;); var guess = ReadLine(); if(guess.Length == 1) RunGame(HandleGuess(puzzle, guess[0])); else WriteLine(\u0026#34;Your guess must be a single char\u0026#34;); } } public static void MainHangman() { var puzzle = FreshPuzzle(RandomWord1); RunGame(puzzle); } } } ","permalink":"https://peaceiris.com/MyBlog/posts/2019-12-06-status-of-csharp-8-functional-features-with-a-comparison-to-haskell/","tags":["csharp","functional-programming"],"title":"Status of C# 8.0 functional features with a comparison to Haskell"},{"categories":null,"contents":"Abstract The code is here.\nThanks to Mike for reviewing this.\nI have always been mildly irritated by how many .net projects I need to create in my standard workflow.\nUsually I start with an idea for a library; I then want to test it with a simple executable; write some XUnit tests for it and finally benchmark some key scenarios. So I end up with at least four projects to manage.\nSure, I can find ways to automatically generate those projects, but I have always been weary of codegen to solve complexity issues. It always ends up coming back to bite you. For those of you as old as I am, think MFC \u0026hellip;\nSo what is my ideal world then? Well, let\u0026rsquo;s try this:\n One single project for the library and related artifacts (i.e. test, benchmarks, etc\u0026hellip;). Distinguish the library code from the test code from the benchmark code by some convention (i.e. name scheme). Generate each artifact (i.e. library, tests, benchmarks, executable) by passing different options to dotnet build and dotnet run. Create a new project by using the standard dotnet new syntax. Have intellisense working normally in each file for my chosen editor (VSCode). Work with dotnet watch so that one can automatically run tests when anything changes.  Disclaimer What follows, despite working fine, is not the standard way .net tools are used. It is not in the \u0026lsquo;golden path\u0026rsquo;. That is problematic for production usage as:\n It might not work in your particular configuration. It might not work with other tools that rely on the presence of multiple projects (i.e. code coverage? \u0026hellip;). It might work now in all scenarios, but get broken in the future as you update to a new framework, sdk, editor. It might expose bugs in the tools, now or later, which aren\u0026rsquo;t going to be fixed, as you are not using the tools as intended. It might upset your coworkers that are used to a more standard setup.  I need to write a blog post about the concept of the \u0026lsquo;golden path\u0026rsquo; and the perils, mostly hidden, of getting away from it. The summary, it is a bad idea.\nHaving said all of that, for the daring souls, here is one way to achieve most of the above. It also works out as a tutorial on how the different components of the .NET Core build system interacts.\nHow to use it Here are the steps:\n Type dotnet new -i Lucabol.SingleSourceProject. Create a directory for your project and cd to it. Type dotnet new lsingleproject and optionally --standardVersion \u0026lt;netstandardXX\u0026gt; --appVersion \u0026lt;netcoreappXX\u0026gt;. Either modify the Library.cs, Main.cs, Test.cs, Bench.cs files or create your own with this convention:  Code for the executable goes in potentially multiple files named XXXMain.cs (i.e. MyLibrary.Main.cs). Code for the tests goes into files named XXXTest.cs (i.e. MyLibrary.Test.cs). Code for the benchmarks goes into files named XXXBench.cs (i.e. MyLibrary.Bench.cs). Any .cs file not following the above conventions is compiled into the dll.   Type:  dotnet build or dotnet build -c release to build debug or release version of your dll. This doesn\u0026rsquo;t include any of the main, test or bench code. dotnet build -c main or dotnet build -c main_release and the corresponding dotnet run -c .. build and run the exe. dotnet build -c test, dotnet build -c test_release and dotnet test -c test build and run the tests. dotnet build -c bench, dotnet run -c bench build and run the benchmark.    How it all works The various steps above are implemented as follows:\ndotnet new -i ... install a custom template that I have created and pushed on NuGet.\nThe custom template is composed of the following files:\nCode files There is one file for each kind of artifact that the project can generate: library, program, tests and benchmark. The files follow the name terminating conventions, as described above.\nProject file The project file is identical to any other project file generated by dotnet new except that there is one additional line appended at the end:\n\u0026lt;Import Project=\u0026#34;Base.targets\u0026#34; /\u0026gt; This instruct msbuild to include the Base.targets file. That file has most of the magick. I have separated it out so that you can use it unchanged in your own projects.\nBase.targets We start by removing all the file from compilation except the ones that are used to build the library.\n\u0026lt;ItemGroup\u0026gt; \u0026lt;Compile Remove=\u0026#34;**/*Bench.cs;**/*Test.cs;**/*Main.cs\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; We then conditionally include the correct ones depending on which configuration is chosen. Please notice the last line, which instruct dotnet watch to watch all the .cs files. By default it just watches the ones in the debug configuration.\n\u0026lt;ItemGroup\u0026gt; \u0026lt;Compile Include=\u0026#34;**/*Test.cs\u0026#34; Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Test\u0026#39;\u0026#34;/\u0026gt; \u0026lt;Compile Include=\u0026#34;**/*Test.cs\u0026#34; Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Test_Release\u0026#39;\u0026#34;/\u0026gt; \u0026lt;Compile Include=\u0026#34;**/*Bench.cs\u0026#34; Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Bench\u0026#39;\u0026#34;/\u0026gt; \u0026lt;Compile Include=\u0026#34;**/*Main.cs\u0026#34; Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Main\u0026#39;\u0026#34;/\u0026gt; \u0026lt;Compile Include=\u0026#34;**/*Main.cs\u0026#34; Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Main_Release\u0026#39;\u0026#34;/\u0026gt; \u0026lt;Watch Include=\u0026#34;**\\*.cs\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; Then we need to define the references. Depending on what you are building you need to include references to the correct NuGet packages (i.e. if you are building test you need the xunit packages). This is done below:\n\u0026lt;ItemGroup Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Bench\u0026#39; OR \u0026#39;$(Configuration)\u0026#39;==\u0026#39;Debug\u0026#39;\u0026#34;\u0026gt; \u0026lt;PackageReference Include=\u0026#34;BenchmarkDotNet\u0026#34; Version=\u0026#34;0.11.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Test\u0026#39; OR \u0026#39;$(Configuration)\u0026#39;==\u0026#39;Test_Release\u0026#39; OR \u0026#39;$(Configuration)\u0026#39;==\u0026#39;Debug\u0026#39;\u0026#34;\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.NET.Test.Sdk\u0026#34; Version=\u0026#34;15.9.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;xunit\u0026#34; Version=\u0026#34;2.4.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;xunit.runner.visualstudio\u0026#34; Version=\u0026#34;2.4.0\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; One thing to notice is that most references are also included in the debug configuration. This is not a good thing, but it is the only way to get VSCode Intellisense to work for all the files in the solution. Apparently, IntelliSense uses whatever reference are defined for the debug build in VsCode. So debug is special, if you wish \u0026hellip;\nBut that\u0026rsquo;s not enough. When you create your own MsBuild configurations, you also have to replicate the properties and constants that are set in the debug and release configurations. You would like a way to inherit them, but I don\u0026rsquo;t think it is possible.\nIt is particularly important to set the TargetFramework property, as it needs to be set to netcoreappXXX for the main, test and benchmark configurations. I give an example of the Test and Test_release configurations below. The rest is similar:\n\u0026lt;PropertyGroup Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Test\u0026#39;\u0026#34;\u0026gt; \u0026lt;TargetFramework\u0026gt;netcoreapp2.1\u0026lt;/TargetFramework\u0026gt; \u0026lt;DefineConstants\u0026gt;$(DefineConstants);DEBUG;TRACE;TEST\u0026lt;/DefineConstants\u0026gt; \u0026lt;DebugSymbols\u0026gt;true\u0026lt;/DebugSymbols\u0026gt; \u0026lt;DebugType\u0026gt;portable\u0026lt;/DebugType\u0026gt; \u0026lt;Optimize\u0026gt;false\u0026lt;/Optimize\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;PropertyGroup Condition=\u0026#34;\u0026#39;$(Configuration)\u0026#39;==\u0026#39;Test_Release\u0026#39;\u0026#34;\u0026gt; \u0026lt;TargetFramework\u0026gt;netcoreapp2.1\u0026lt;/TargetFramework\u0026gt; \u0026lt;DefineConstants\u0026gt;$(DefineConstants);RELEASE;TRACE;TEST\u0026lt;/DefineConstants\u0026gt; \u0026lt;DebugSymbols\u0026gt;false\u0026lt;/DebugSymbols\u0026gt; \u0026lt;DebugType\u0026gt;portable\u0026lt;/DebugType\u0026gt; \u0026lt;Optimize\u0026gt;true\u0026lt;/Optimize\u0026gt; \u0026lt;/PropertyGroup\u0026gt; The .template.config/template.json file This is necessary to create a dotnet new custom template. The only thing to notice is the two parameters standardVersion and appVersion that gives the user a way to indicate which version of the .NET Standard to use for the library and which version of the application framework to use for Main, Test and Bench.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;http://json.schemastore.org/template\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Luca Bolognese\u0026#34;, \u0026#34;classifications\u0026#34;: [ \u0026#34;Classlib\u0026#34;, \u0026#34;Console\u0026#34;, \u0026#34;XUnit\u0026#34; ], \u0026#34;identity\u0026#34;: \u0026#34;Lucabol.SingleSourceProject\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;One single Project\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;One single Project for DLL, XUnit, Benchmark \u0026amp; Main, using configurations to decide what to compile\u0026#34;, \u0026#34;shortName\u0026#34;: \u0026#34;oneproject\u0026#34;, \u0026#34;tags\u0026#34;: { \u0026#34;language\u0026#34;: \u0026#34;C#\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;project\u0026#34; }, \u0026#34;preferNameDirectory\u0026#34;: true, \u0026#34;sourceName\u0026#34;: \u0026#34;SingleSourceProject\u0026#34;, \u0026#34;symbols\u0026#34;:{ \u0026#34;standardVersion\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;parameter\u0026#34;, \u0026#34;defaultValue\u0026#34;: \u0026#34;netstandard2.0\u0026#34;, \u0026#34;replaces\u0026#34;:\u0026#34;netstandard2.0\u0026#34; }, \u0026#34;appVersion\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;parameter\u0026#34;, \u0026#34;defaultValue\u0026#34;: \u0026#34;netcoreapp2.1\u0026#34;, \u0026#34;replaces\u0026#34;:\u0026#34;netcoreapp2.1\u0026#34; } } } Conclusion Now that you know how it all works, you can make an informed decision if to use it or not. As for me \u0026hellip;\n","permalink":"https://peaceiris.com/MyBlog/posts/2019-02-04-singleproject/","tags":["csharp"],"title":"A single .NET Core project to rule them all"},{"categories":null,"contents":"Abstract Thanks to Mike for reviewing this.\nThis is a way to enable compile time customization of classes/functions in the style of C++ template meta-programming as in Modern C++ Design. In particular, we are going to implement the policy pattern, which is compile time version of the strategy pattern.\nWhat do we gain by constraining ourselves to compile time customization, instead of run time one? High performance. Blazingly high performance. You gain an abstraction, without paying for it.\nToo good to be true? Read on!\nBTW1: none of this is new. It has been floating around in various forms. But I have never seen explained fully and associated to the policy pattern. BTW2: it is also related to the uber cool Shape proposal for C#, where it becomes an implementation detail.\nImplementation First, the usual plethora of namespaces \u0026hellip; BenchmarkDotNet is really heavy into separating abstractions in different namespaces \u0026hellip;\nusing System.Runtime.CompilerServices; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Diagnostics.Windows.Configs; using BenchmarkDotNet.Mathematics; using BenchmarkDotNet.Order; using BenchmarkDotNet.Running; Let\u0026rsquo;s take a look at the strategy pattern, as more traditionally implemented. You got an interface IIncrementer and two implementations, either thread safe or not. Let\u0026rsquo;s also add a couple of struct implementations so that we can measure the performance difference of implementation by classes and by structs.\npublic interface IIncrementer { void Increment(ref int location); } public sealed class CStandardIncrementer : IIncrementer {[MethodImpl(MethodImplOptions.AggressiveInlining)] public void Increment(ref int location) =\u0026gt; location += 1; } public sealed class CInterlockedIncrementer : IIncrementer {[MethodImpl(MethodImplOptions.AggressiveInlining)] public void Increment(ref int location) =\u0026gt; Interlocked.Increment(ref location); } public readonly struct SStandardIncrementer : IIncrementer {[MethodImpl(MethodImplOptions.AggressiveInlining)] public void Increment(ref int location) =\u0026gt; location += 1; } public readonly struct SInterlockedIncrementer : IIncrementer {[MethodImpl(MethodImplOptions.AggressiveInlining)] public void Increment(ref int location) =\u0026gt; Interlocked.Increment(ref location); } We then need a class that can be customized by an Incrementer. Think of it as: the policy of incrementing something is independent from the class in question.\nLet\u0026rsquo;s take a Counter and call it Dynamic as we want to be able to customize it at runtime. We need to keep things simple so that looking at ASM is doable. Also we inline everything to try to squeeze the most performance out of our program.\npublic class DynamicCounter\u0026lt;T\u0026gt; where T: IIncrementer { int _count; T _incrementer; public DynamicCounter(T incrementer) =\u0026gt; _incrementer = incrementer; [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Increment() =\u0026gt; _incrementer.Increment(ref _count); } Then we look at how to implement the strategy pattern at compile time (transforming it magically into the policy pattern).\n(no-one every talks about the negative aspects of giving names to things, one of these days I\u0026rsquo;ll blog about it \u0026hellip;)\nThere are many ways to go about it. They all rely on the fact that the JIT Compiler instantiates a different type for each struct used to customize the type (aka each T).\nFor each one of these types, the JIT knows at compile type what T is, which brings about certain optimizations.\nThe optimization exploited by StaticCounterInterface is that the call to Increment becomes a non-virtual call that can be inlined.\npublic class StaticCounterInterface\u0026lt;T\u0026gt; where T : struct, IIncrementer { int _count; T _incrementer = new T(); [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Increment() =\u0026gt; _incrementer.Increment(ref _count); } For StaticCounterMatch the situation is even more obvious.\nThe Jitter doesn\u0026rsquo;t generate code for any of the if statements. It just puts the right code for the type T directly in the body of the Increment method.\nIt is as if the if statement were executed at compile time, as with C++ templates. Also notice the IncrementRaw method used for perf comparison.\npublic class StaticCounterMatch\u0026lt;T\u0026gt; { int _count; [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Increment() { if (typeof(T) == typeof(SStandardIncrementer)) _count += 1; if (typeof(T) == typeof(SInterlockedIncrementer)) Interlocked.Increment(ref _count); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void IncrementRaw() =\u0026gt; _count += 1; } We are now ready for the performance testing. We create one class for each combination and benchmark their Increment method.\nA few comments on the attributes:\n DryCoreJob doesn\u0026rsquo;t do the benchmark, but just runs the diagnosers, in this case produces assembly code. InProcessAttribute makes everything go faster, but cannot be used to generate assembly. DisassemblyDiagnoser creates files with the assembly code. RankColumn generates a nicer table.  //[DryCoreJob] //[InProcessAttribute] [DisassemblyDiagnoser(printAsm: true, printPrologAndEpilog: true, printIL: false, printSource: false, recursiveDepth: 3)] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [RankColumn(NumeralSystem.Stars)] public class MainClass { DynamicCounter\u0026lt;IIncrementer\u0026gt; dynInterface = new DynamicCounter\u0026lt;IIncrementer\u0026gt;(new CStandardIncrementer()); DynamicCounter\u0026lt;CStandardIncrementer\u0026gt; dynConcrete = new DynamicCounter\u0026lt;CStandardIncrementer\u0026gt;(new CStandardIncrementer()); DynamicCounter\u0026lt;SStandardIncrementer\u0026gt; dynStruct = new DynamicCounter\u0026lt;SStandardIncrementer\u0026gt;(new SStandardIncrementer()); StaticCounterMatch\u0026lt;SStandardIncrementer\u0026gt; staticCounterM = new StaticCounterMatch\u0026lt;SStandardIncrementer\u0026gt;(); StaticCounterInterface\u0026lt;SStandardIncrementer\u0026gt; staticCounterI = new StaticCounterInterface\u0026lt;SStandardIncrementer\u0026gt;(); [Benchmark] public void DynamicInterface() =\u0026gt; dynInterface.Increment(); [Benchmark] public void DynamicConcrete() =\u0026gt; dynConcrete.Increment(); [Benchmark] public void DynamicStruct() =\u0026gt; dynStruct.Increment(); [Benchmark] public void StaticCounterInterface() =\u0026gt; staticCounterI.Increment(); [Benchmark] public void StaticCounterMatch() =\u0026gt; staticCounterM.Increment(); [Benchmark(Baseline = true)] public void IncrementRaw() =\u0026gt; staticCounterM.IncrementRaw(); public static void Main() =\u0026gt; BenchmarkRunner.Run\u0026lt;MainClass\u0026gt;(); } Results Please note that the results are valid just for the tested configuration.\nI have no reason to think that they would be different on other modern runtimes/OSs as the optimizations are quite well known.\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.17763.253 (1809/October2018Update/Redstone5) Intel Core i7-6600U CPU 2.60GHz (Skylake), 1 CPU, 4 logical and 2 physical cores .NET Core SDK=3.0.100-preview-009812 [Host] : .NET Core 2.0.9 (CoreCLR 4.6.26614.01, CoreFX 4.6.26614.01), 64bit RyuJIT DefaultJob : .NET Core 2.0.9 (CoreCLR 4.6.26614.01, CoreFX 4.6.26614.01), 64bit RyuJIT    Method Mean Error StdDev Median Ratio RatioSD Rank     StaticCounterInterface 0.0000 ns 0.0000 ns 0.0000 ns 0.0000 ns 0.000 0.00 *   IncrementRaw 0.1036 ns 0.0515 ns 0.0573 ns 0.1071 ns 1.000 0.00 **   StaticCounterMatch 0.1122 ns 0.0422 ns 0.0943 ns 0.1020 ns 2.092 1.95 **   DynamicStruct 0.2707 ns 0.0910 ns 0.2683 ns 0.1407 ns 4.135 6.28 ***   DynamicConcrete 1.9216 ns 0.1506 ns 0.4440 ns 1.7883 ns 23.417 21.44 ****   DynamicInterface 2.2441 ns 0.1170 ns 0.3449 ns 2.1470 ns 32.783 30.52 *****    As expected, you gain an order of magnitude in performance by foregoing run time customization, except when using a struct as the optimizer manages to inline that one (as we\u0026rsquo;ll see).\nNotice that these numbers are really low. In fact the order of the first 4 lines might change when you run it. But they are always much faster than the rest.\nBut why? Let\u0026rsquo;s look at the generated code.\nIL and ASM First let\u0026rsquo;s look at IL for a few of the methods\nMainClass.IncrementRaw() IL_0000: ldarg.0 IL_0001: ldfld StaticCounterMatch`1\u0026lt;SStandardIncrementer\u0026gt; MainClass::staticCounterM IL_0006: callvirt System.Void StaticCounterMatch`1\u0026lt;SStandardIncrementer\u0026gt;::IncrementRaw() IL_000b: ret ; MainClass.StaticCounterInterface() IL_0000: ldarg.0 IL_0001: ldfld StaticCounterInterface`1\u0026lt;SStandardIncrementer\u0026gt; MainClass::staticCounterI IL_0006: callvirt System.Void StaticCounterInterface`1\u0026lt;SStandardIncrementer\u0026gt;::Increment() IL_000b: ret ; MainClass.StaticCounterMatch() IL_0000: ldarg.0 IL_0001: ldfld StaticCounterMatch`1\u0026lt;SStandardIncrementer\u0026gt; MainClass::staticCounterM IL_0006: callvirt System.Void StaticCounterMatch`1\u0026lt;SStandardIncrementer\u0026gt;::Increment() IL_000b: ret Ok, nothing interesting there apart from the use of callvirt when you would think a standard call would do (i.e. IncrementRaw).\nI vaguely remember from my C# compiler days that we do that as a way to short-circuit the test for null, as callvirt does it automatically.\nThe assembly code is more interesting. Let\u0026rsquo;s start from the three fast-resolved-at-compile-time methods.\nBTW: remember that looking at optimized ASM code is like peering into a muddy lake with foggy glasses. Let\u0026rsquo;s do it.\n; MainClass.IncrementRaw() mov rax,qword ptr [rcx+20h] inc dword ptr [rax+8] ret ; MainClass.StaticCounterInterface() mov rax,qword ptr [rcx+28h] (*)mov edx,dword ptr [rax] add rax,8 inc dword ptr [rax] ret ; MainClass.StaticCounterMatch() mov rax,qword ptr [rcx+20h] (*)mov edx,dword ptr [rax] inc dword ptr [rax+8] ret ; MainClass.DynamicStruct() mov rax,qword ptr [rcx+18h] (*) mov edx,dword ptr [rax] add rax,8 inc dword ptr [rax] ret Yep, they are all the same (apart from the mysterious * instruction)! Get the memory location of the field, increment it.\nThe Jitter has completely inlined the code. It is as if you had written the incrementing code directly into the function, despite you composing the type using two independent abstractions.\nI think that is pretty cool! You can abstract your code properly and not pay the price for it (well, apart from one assembly instruction).\nFor the sake of completeness, let\u0026rsquo;s look at the assembly code for the dynamic dispatching cases.\n; MainClass.DynamicConcrete() mov rcx,qword ptr [rcx+10h] cmp dword ptr [rcx],ecx lea rdx,[rcx+10h] mov rcx,qword ptr [rcx+8] mov r11,7FF8C2B30470h mov rax,qword ptr [r11] cmp dword ptr [rcx],ecx jmp rax ; MainClass.DynamicInterface() mov rcx,qword ptr [rcx+8] cmp dword ptr [rcx],ecx lea rdx,[rcx+10h] mov rcx,qword ptr [rcx+8] mov r11,7FF8C2B10470h mov rax,qword ptr [r11] cmp dword ptr [rcx],ecx jmp rax The first thing to notice is that the code is identical, despite their seemingly different declarations. The Jitter doesn\u0026rsquo;t care.\nNotice the machinations the Jitter performs, very likely related to dynamic dispatching, to calculate the address to finally jump to. That\u0026rsquo;s where our Increment method is located.\nNo wonder it is slower.\nSummary If you can afford to use the policy pattern instead of the more generic strategy pattern (i.e. compile time vs run time dispatch) and/or you need bare to the metal performance, consider the code above.\nAs for me, I plan to use it in the near future for a few low level abstractions (i.e. memory allocators).\n","permalink":"https://peaceiris.com/MyBlog/posts/2019-01-29-meta-programming-and-policy-based-design/","tags":["csharp"],"title":"Meta-programming in C# with JIT dead code removal and inlining"},{"categories":[".NET Core","csharp"],"contents":"Let\u0026rsquo;s see how it\u0026rsquo;s implemented. For why it is implemented, see part I.\nThanks to Mike for reviewing this.\nusing System; using System.Diagnostics.Tracing; using System.Runtime; The FxCop code analyzers get upset if I don\u0026rsquo;t declare this, which also impede me from using unsigned numeral types in interfaces.\n[assembly: CLSCompliant(true)] namespace LNativeMemory { The first piece of the puzzle is to implement an event listener. It is a not-obvious (for me) class. I don\u0026rsquo;t fully understand the lifetime semantics, but the code below seems to do the right thing.\nThe interesting piece is _started and the method Start(). The constructor for EventListener allocates plenty of stuff. I don\u0026rsquo;t want to do those allocations after calling TryStartNoGCRegion because they would use part of the GC Heap that I want for my program. Instead, I create it before such call, but then I make it \u0026lsquo;switch on\u0026rsquo; just after the Start() method is called.\ninternal sealed class GcEventListener : EventListener { Action _action; EventSource _eventSource; bool _active = false; internal void Start() { _active = true; } internal void Stop() { _active = false; } As described in part one, you pass a delegate at creation time, which is called when garbage collection is restarted.\ninternal GcEventListener(Action action) =\u0026gt; _action = action ?? throw new ArgumentNullException(nameof(action)); We register to all the events coming from .NET. We want to call the delegate at the exact point when garbage collection is turned on again. We don\u0026rsquo;t have a clean way to do that (aka there is no runtime event we can hook up to, see here, so listening to every single GC event gives us the most chances of doing it right. Also it ties us the least to any pattern of events, which might change in the future.\n// from https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events  private const int GC_KEYWORD = 0x0000001; private const int TYPE_KEYWORD = 0x0080000; private const int GCHEAPANDTYPENAMES_KEYWORD = 0x1000000; protected override void OnEventSourceCreated(EventSource eventSource) { if (eventSource.Name.Equals(\u0026#34;Microsoft-Windows-DotNETRuntime\u0026#34;, StringComparison.Ordinal)) { _eventSource = eventSource; EnableEvents(eventSource, EventLevel.Verbose, (EventKeywords)(GC_KEYWORD | GCHEAPANDTYPENAMES_KEYWORD | TYPE_KEYWORD)); } } For each event, I check if the garbage collector has exited the NoGC region. If it has, then let\u0026rsquo;s invoke the delegate.\nprotected override void OnEventWritten(EventWrittenEventArgs eventData) { var eventName = eventData.EventName; if(_active \u0026amp;\u0026amp; GCSettings.LatencyMode != GCLatencyMode.NoGCRegion) { _action?.Invoke(); } } } Now that we have our event listener, we need to hook it up. The code below implements what I described earlier.\n Do your allocations for the event listener Start the NoGc region Start monitoring the runtime for the start of the NoGC region  public static class GC2 { static private GcEventListener _evListener; public static bool TryStartNoGCRegion(long totalSize, Action actionWhenAllocatedMore) { _evListener = new GcEventListener(actionWhenAllocatedMore); var succeeded = GC.TryStartNoGCRegion(totalSize, disallowFullBlockingGC: false); _evListener.Start(); return succeeded; } As puzzling as this might be, I provisionally believe it to be correct. Apparently, even if the GC is not in a NoGC region, you still need to call EndNoGCRegion if you have called TryStartNoGCRegion earlier, otherwise your next call to TryStartNoGCRegion will fail. EndNoGCRegion will throw an exception, but that\u0026rsquo;s OK. Your next call to TryStartNoGCRegion will now succeed.\nNow read the above repeatedly until you got. Or just trust that it works somehow.\npublic static void EndNoGCRegion() { _evListener.Stop(); try { GC.EndNoGCRegion(); } catch (Exception) { } } } This is used as the default behavior for the delegate in the wrapper class below. I was made aware by the code analyzer that I shouldn\u0026rsquo;t be throwing an OOF exception here. At first, I dismissed it, but then it hit me. It is right.\nWe are not running out of memory here. We simply have allocated more memory than what we declared we would. There is likely plenty of memory left on the machine. Thinking more about it, I grew ashamed of my initial reaction. Think about a support engineer getting an OOM exception at that point and trying to figure out why. So, always listen to Lint \u0026hellip;\npublic class OutOfGCHeapMemoryException : OutOfMemoryException { public OutOfGCHeapMemoryException(string message) : base(message) { } public OutOfGCHeapMemoryException(string message, Exception innerException) : base(message, innerException) { } public OutOfGCHeapMemoryException() : base() { } } This is an utility class that implements the IDisposable pattern for this scenario. The size of the default ephemeral segment comes from here.\npublic sealed class NoGCRegion: IDisposable { static readonly Action defaultErrorF = () =\u0026gt; throw new OutOfGCHeapMemoryException(); const int safeEphemeralSegment = 16 * 1024 * 1024; public NoGCRegion(int totalSize, Action actionWhenAllocatedMore) { var succeeded = GC2.TryStartNoGCRegion(totalSize, actionWhenAllocatedMore); if (!succeeded) throw new InvalidOperationException(\u0026#34;Cannot enter NoGCRegion\u0026#34;); } public NoGCRegion(int totalSize) : this(totalSize, defaultErrorF) { } public NoGCRegion() : this(safeEphemeralSegment, defaultErrorF) { } public void Dispose() =\u0026gt; GC2.EndNoGCRegion(); } } ","permalink":"https://peaceiris.com/MyBlog/posts/2019-01-21-stopping-garbage-collection-in-net-core-3-0-part-ii/","tags":["csharp"],"title":"Stopping Garbage Collection in .NET Core 3.0 (part II)"},{"categories":[".NET Core","csharp"],"contents":"Scenario Thanks to Mike for reviewing this.\nYou have an application or a particular code path of your application that cannot take the pauses that GC creates. Typical examples are real time systems, tick by tick financial apps, embedded systems, etc \u0026hellip;\nDisclaimer For any normal kind of applications, YOU DON\u0026rsquo;T NEED TO DO THIS. You are likely to make your application run slower or blow up memory. If you have an hot path in your application (i.e. you are creating an editor with Intellisense), use the GC latency modes. Use the code below just under extreme circumstance as it is untested, error prone and wacky. You are probably better off waiting for an official way of doing it (i.e. when this is implemented)\nThe problem with TryStartNoGCRegion There is a GC.TryStartNoGCRegion in .NET. You can use it to stop garbage collection passing a totalBytes parameter that represents the maximum amount of memory that you plan to allocate from the managed heap. Matt describes it here.\nThe problem is that when/if you allocate more than that, garbage collection resumes silently. Your application continues to work, but with different performance characteristics from what you expected.\nThe idea The main idea is to use ETW events to detect when a GC occurs and to call an user provided delegate at that point. You can then do whatever you want in the delegate (i.e. shutdown the process, send email to support, start another NoGC region, etc\u0026hellip;).\nAlso, I have wrapped the whole StartNoGCRegion/EndNoGCRegion in an IDisposable wrapper for easy of use.\nThe tests Let\u0026rsquo;s start by looking at how you use it.\nusing Xunit; using System.Threading; namespace LNativeMemory.Tests { // XUnit executes all tests in a class sequentially, so no problem with multi-threading calls to GC  public class GC2Tests { We need to use a timer to maximize the chances that a GC happens in some of the tests. Also we allocate an amount that should work in all GC configuration as per the article above. trigger is a static field so as to stay zero-allocation (otherwise the delegate will have to capture the a local trigger variable creating a heap allocated closure). Not that it matters any to be zero-allocation in this test, but I like to keep ClrHeapAllocationAnalyzer happy.\nBTW: XUnit executes all tests in a class sequentially, so no problem with multi-threading calls to GC.\nconst int sleepTime = 200; const int totalBytes = 16 * 1024 * 1024; static bool triggered = false; First we test that any allocation that doesn\u0026rsquo;t exceed the limit doesn\u0026rsquo;t trigger the call to action.\n[Fact] public void NoAllocationBeforeLimit() { try { triggered = false; var succeeded = GC2.TryStartNoGCRegion(totalBytes, () =\u0026gt; triggered = true); Assert.True(succeeded); Thread.Sleep(sleepTime); Assert.False(triggered); var bytes = new byte[99]; Thread.Sleep(sleepTime); Assert.False(triggered); } finally { GC2.EndNoGCRegion(); triggered = false; } } Then we test that allocating over the limit does trigger the action. To do so we need to trigger a garbage collection. Out best attempt is with the goofy for loop. If you got a better idea, shout.\n[Fact] public void AllocatingOverLimitTriggersTheAction() { try { triggered = false; var succeeded = GC2.TryStartNoGCRegion(totalBytes, () =\u0026gt; triggered = true); Assert.True(succeeded); Assert.False(triggered); for (var i = 0; i \u0026lt; 3; i++) { var k = new byte[totalBytes]; } Thread.Sleep(sleepTime); Assert.True(triggered); } finally { GC2.EndNoGCRegion(); triggered = false; } } We also test that we can go back and forth between starting and stopping without messing things up.\n[Fact] public void CanCallMultipleTimes() { for (int i = 0; i \u0026lt; 3; i++) { NoAllocationBeforeLimit(); } } And lastly, we make sure that we can use our little wrapper function, just to be sure everything works.\n[Fact] public void CanUseNoGCRegion() { triggered = false; using (new NoGCRegion(totalBytes, () =\u0026gt; triggered = true)) { for (var i = 0; i \u0026lt; 3; i++) { var k = new byte[totalBytes]; } Thread.Sleep(sleepTime); Assert.True(triggered); triggered = false; } } } } ","permalink":"https://peaceiris.com/MyBlog/posts/2019-01-14-stopping-garbage-collection-in-net-core-3-0-part-i/","tags":["csharp"],"title":"Stopping Garbage Collection in .NET Core 3.0 (part I)"},{"categories":["csharp"],"contents":"I am back in Microsoft and today we talk about the code below, which is on github here:\npublic ref struct SpanStack\u0026lt;T\u0026gt; { private Span memory; private int index; private int size; public SpanStack(Span mem) { memory = mem; index = 0; size = mem.Length; } public bool IsEmpty() =\u0026gt; index \u0026lt; 0; public bool IsFull() =\u0026gt; index \u0026gt; size - 1; public void Push(T item) =\u0026gt; memory[index++] = item; public T Pop() =\u0026gt; memory[--index]; } public static class SpanExtensions { public static SpanStack AsStack\u0026lt;T\u0026gt;(this Span span) =\u0026gt; new SpanStack(span); } This Stack data structure can be used over memory that resides on the stack, heap or unmanaged heap. If you know about Span this should immediately make sense to you.\nThis has to be a ref struct because it contains a Span. It can\u0026rsquo;t be used on the heap (i.e. in lambdas, async, class field, \u0026hellip;). You have to build it on top of Memory if you need that. Also, you can happily blow the stack with this guy \u0026hellip;\nLet\u0026rsquo;s micro-benchmark it with BenchmarkDotNet. For example, a postfix calculator. Let\u0026rsquo;s first do it naively using inheritance and the generic Stack class in the framework.\nThis is the naive object model:\nabstract class Token {} sealed class Operand: Token { public int Value { get; } public Operand(int v) { Value = v; } } abstract class Operator: Token { abstract public int Calc(int a, int b); } sealed class Add: Operator { public override int Calc(int a, int b) =\u0026gt; a + b; } sealed class Mult : Operator { public override int Calc(int a, int b) =\u0026gt; a * b; } sealed class Minus : Operator { public override int Calc(int a, int b) =\u0026gt; a - b; } Let\u0026#39;s then do it trying to be a bit more performance aware using a stack friendly representation: public enum TokenType { Operand, Sum, Mult, Minus} readonly struct SToken { public TokenType Type { get; } public int Value { get; } public SToken(TokenType t, int v) { Type = t; Value = v; } public SToken(TokenType t) { Type = t; Value = 0; } public int Calc(int a, int b) =\u0026gt; Type == TokenType.Sum ? a + b : Type == TokenType.Minus ? a - b : Type == TokenType.Minus ? a * b : throw new Exception(\u0026#34;I don\u0026#39;t know that one\u0026#34;); } Perhaps not overtly elegant, but not that terrible either. You got to love those expression bodied methods and throw-expression.\nWe then setup things (I know I could/should parse a string here):\nstatic Token[] tokens; static SToken[] stokens; [GlobalSetup] public void Setup() { tokens = new Token[] { new Operand(2), new Operand(3), new Operand(4), new Add(), new Mult(), new Operand(5), new Minus() }; stokens = new SToken[] { new SToken(TokenType.Operand, 2), new SToken(TokenType.Operand, 3), new SToken(TokenType.Operand, 4), new SToken(TokenType.Sum), new SToken(TokenType.Mult), new SToken(TokenType.Operand, 5), new SToken(TokenType.Minus)}; } And first test the naive object model with the standard Stack from System.Collections.Generic.\n[Benchmark] public int PostfixEvalStack() { var stack = new Stack(100); foreach (var token in tokens) { switch (token) { case Operand t: stack.Push(t); break; case Operator o: var a = stack.Pop() as Operand; var b = stack.Pop() as Operand; var result = o.Calc(a.Value, b.Value); stack.Push(new Operand(result)); break; } } return (stack.Pop() as Operand).Value; } Then let\u0026rsquo;s just swap out our own lean-and-mean stack:\n[Benchmark] public int PostfixEvalSpanStack() { Span span = new Token[100]; var stack = span.AsStack(); foreach (var token in tokens) { switch (token) { case Operand t: stack.Push(t); break; case Operator o: var a = stack.Pop() as Operand; var b = stack.Pop() as Operand; var result = o.Calc(a.Value, b.Value); stack.Push(new Operand(result)); break; } } return (stack.Pop() as Operand).Value; } And finally let\u0026rsquo;s go the whole way, lean object model and lean data structure, everything on the stack:\n[Benchmark(Baseline = true)] public int PostfixEvalSpanStackStructTypes() { Span span = stackalloc SToken[100]; var stack = span.AsStack(); foreach (var token in stokens) { if (token.Type == TokenType.Operand) { stack.Push(token); } else { var a = stack.Pop(); var b = stack.Pop(); var result = token.Calc(a.Value, b.Value); stack.Push(new SToken(TokenType.Operand, result)); break; } } return stack.Pop().Value; } We also want to check that we didn\u0026rsquo;t code anything stupid and finally run the benchmark.\nstatic void Test() { var p = new Program(); p.Setup(); Trace.Assert(p.PostfixEvalStack() == p.PostfixEvalSpanStack() \u0026amp;\u0026amp; p.PostfixEvalSpanStack() == p.PostfixEvalSpanStackStructTypes()); } static void Main(string[] args) { Test(); var summary = BenchmarkRunner.Run(); } On my machine I get these results:\nBenchmarkDotNet=v0.10.14, OS=Windows 10.0.16299.431 (1709/FallCreatorsUpdate/Redstone3) Intel Core i7-6600U CPU 2.60GHz (Skylake), 1 CPU, 4 logical and 2 physical cores Frequency=2742185 Hz, Resolution=364.6727 ns, Timer=TSC .NET Core SDK=2.1.300-rc1-008673 [Host] : .NET Core 2.1.0-rc1 (CoreCLR 4.6.26426.02, CoreFX 4.6.26426.04), 64bit RyuJIT DefaultJob : .NET Core 2.1.0-rc1 (CoreCLR 4.6.26426.02, CoreFX 4.6.26426.04), 64bit RyuJIT Method\tMean\tError\tStdDev\tScaled\tScaledSD PostfixEvalSpanStackStructTypes\t76.24 ns\t1.563 ns\t2.857 ns\t1.00\t0.00 PostfixEvalSpanStack\t168.65 ns\t5.280 ns\t15.319 ns\t2.22\t0.22 PostfixEvalStack\t334.56 ns\t7.387 ns\t20.593 ns\t4.39\t0.31 Your mileage might vary. I want to emphasize that I am just playing with things. I haven\u0026rsquo;t done any deep analysis of this benchmark. There can be flaws, etc\u0026hellip; etc\u0026hellip;\nStill, I find the idea of data structures which are memory-location-independent rather fascinating.\n","permalink":"https://peaceiris.com/MyBlog/posts/2018-06-04-a-stack-data-structure-implementation-using-span/","tags":["csharp"],"title":"A Stack data structure implementation using Span"},{"categories":null,"contents":"You are able to access just the pages that you have visited previously. Please go back to the home page to see which pages are available (perhaps with the back button on the browser). ","permalink":"https://peaceiris.com/MyBlog/offline/","tags":null,"title":"Oops, you are offline."},{"categories":["Investing","javascript"],"contents":" This is obsolete as Yahoo stopped their quote service. I have a new spreadsheet here.\nWhen I thought about it, I realized that my ideal system would be a spreadsheet where to add tickers and alert levels. Under the covers, the system would need to check the current price of a ticker, compare it with the alert level and send me email when triggered.\nAlso the whole thing shouldn\u0026rsquo;t be running from my machine at home, but from somewhere on the internet.\nGoogle script fit the bill. Let\u0026rsquo;s see how it works.\nScript is here. Sheet is here.\nFirst a utility function to send errors via email, which will be used throughout the script.\nfunction emailError(e) { MailApp.sendEmail(\u0026#34;lucabolg@gmail.com\u0026#34;, \u0026#34;Watchlist Error\u0026#34;, \u0026#34;\\r\\nMessage: \u0026#34; + e.message + \u0026#34;\\r\\nFile: \u0026#34; + e.fileName + \u0026#34;\\r\\nLine: \u0026#34; + e.lineNumber + \u0026#34;\\r\\nLOg: \u0026#34; + Logger.getLog()) } Then another one to check if the price downloaded from the internet is sensible.\nfunction validPrice(price) { return price != \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; price \u0026gt; 0.1 } We then need one to retrieve the current price of a ticker from the array of data returned from the internet:\n// Find the current price of a ticker in an array of data where the ticker is the first column function getQuote(data, ticker) { var ticker = ticker.trim().toLowerCase() for(var i = 0; i = 22 \u0026amp;\u0026amp; hour \u0026lt;= 23) || value != \u0026#34;close\u0026#34; } With all of that in place, we can now look at the main function. First we load up the spreadsheet and get the values and headers we care about. This would be more robust if we looked up the sheet by name. Also the id of the sheet is burned in the code. You\u0026rsquo;ll need to change it if you want to make it point to your own.\n// Check spreadsheet with tickers and stop prices, send email when a stop is hit and mark the row as \u0026#39;Executed\u0026#39;. function checkQuotes() { try { // Get all data from spreadsheet in one web call.  var ss = SpreadsheetApp.openById(\u0026#34;1WQf2AiBPQW5HLzCyGgsFlKN0f1HTOWAteJ5bJCXVnlc\u0026#34;) var range = ss.getSheets()[0].getDataRange() var values = range.getValues() var headers = values[0] var rows = ObjApp.rangeToObjects(values) var body = \u0026#34;\u0026#34; var now = new Date() Notice \u0026lsquo;ObjApp\u0026rsquo; is part of the ObjService library to make the code a bit more maintainable, instead of scattering column numbers in the code.\nNow we get all the tickers and download the prices from Yahoo (we try three times as it occasionally fails.\n// Fish out all tickers from col 0 where Status (col 4) is not executed  var tickers = [] for(var i = 1; i \u0026lt; rows.length; i++) {// dont\u0026#39; process the headers  if((rows[i]).executed.toLowerCase() == \u0026#39;active\u0026#39; \u0026amp;\u0026amp; isRightTime(rows[i], now)) tickers.push((rows[i]).ticker.trim().toLowerCase()) } Logger.log(\u0026#34;Tickers:%s\u0026#34; ,tickers) if(tickers.length == 0) return // Nothing to process  // Get ticker, real time bid, real time ask for all tickers in one web call  var url = \u0026#34;http://finance.yahoo.com/d/quotes.csv?s=\u0026#34; + tickers.join(\u0026#34;+\u0026#34;) + \u0026#34;\u0026amp;f=sl1\u0026#34;//\u0026#34;\u0026amp;f=sb2b3\u0026#34;  // Try 3 times before giving up  for(var i = 0; i \u0026lt; 3; i++) { try { var response = UrlFetchApp.fetch(url) break; } catch(e) { } } Logger.log(\u0026#34;Response:\\n%s\u0026#34;, response) var data = Utilities.parseCsv(response.getContentText()) Logger.log(\u0026#34;Data:\\n%s\u0026#34;, data) Once that is done, we enter the main loop. The concept is simple, for each row we check the price and, if the price is above/below the alert we add it to the body string and mark the row in the sheet so that we don\u0026rsquo;t process it again next time. A the end, we email the body variable if not null.\nFirst we check that we haven\u0026rsquo;t already executed this row:\nfor(var i = 1; i \u0026lt; rows.length; i++) {// dont\u0026#39; process the headers  var current = rows[i] if(current.executed.trim().toLowerCase() == \u0026#39;executed\u0026#39;) continue // no need to process it as it is \u0026#39;Executed\u0026#39;  var symbol = current.operator var stop = current.stop If it\u0026rsquo;s still active and if it is the right time, we check if the alert is triggered. If it is we add the text to the body variable.\nif(isRightTime(current, now)) { var price = getQuote(data, current.ticker) if( (symbol.trim() == \u0026#34;\u0026gt;\u0026#34; \u0026amp;\u0026amp; price \u0026gt; stop) || (symbol.trim() == \u0026#34;\u0026lt;\u0026#34; \u0026amp;\u0026amp; price \u0026lt; stop)) { current.executed = \u0026#34;Executed\u0026#34; current.price = price body += [current.kind, current.ticker, current.price, current.operator, current.stop, \u0026#34;\\r\\n\u0026#34;].join(\u0026#34; \u0026#34;) Logger.log(\u0026#34;Body in loop:\\n%s\u0026#34;, body) } } } If body is not empty, that means that something was triggered, so we send the email.\nif(body != \u0026#34;\u0026#34;) { Logger.log(\u0026#34;Body final:%s\u0026#34;, body) MailApp.sendEmail(\u0026#39;lucabolg@gmail.com\u0026#39;, \u0026#39;Watchlist: stops triggered\u0026#39;, body) var data = ObjApp.objectToArray(headers, rows) data.unshift(headers) range.setValues(data) } If an error was generated, then we send the error email.\n} catch (e) { Logger.log(e.lineNumber + \u0026#34;:\u0026#34; + e.message) emailError(e) } } My experience overall was remarkable. The learning curve was very quick and the web editor works remarkably well (well, stepping through code is rather slow).\nOverall, if Google has all your data (in Drive) and you can write code to manipulate it (in Google script), why do I need my home computer again? I can just have a small screen that connects to the internet and I\u0026rsquo;m done.\nThat\u0026rsquo;s probably true for me apart from two things that I haven\u0026rsquo;t found in web form: editing of images in the raw format and a sophisticated portfolio application. If I find these two, I\u0026rsquo;m ready to give up my life to Google \u0026hellip;\n","permalink":"https://peaceiris.com/MyBlog/posts/2014-10-31-building-a-stock-alert-system-with-google-script/","tags":["Financial"],"title":"Building a stock alert system with Google Script"},{"categories":["C","fsharp","Functional Programming","Literate programming"],"contents":"Main ideas This is a port of LLIte in C. The reason for it is to experiment with writing functional code in standard C and compare the experience with using a functional language like F#. It is in a way a continuation of my previous posts on the topic.\nI will be using glib and an header of convenient macros/functions to help me (lutils.h). I don’t think that is cheating. Any modern C praticoner has its bag of tricks …\nDon’t tell me this is not idiomatic C. I already know that.\n#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;glib.h\u0026gt;#include \u0026lt;glib/gprintf.h\u0026gt; #ifdef ARENA#include \u0026#34;arena.h\u0026#34;#endif #include \u0026#34;lutils.h\u0026#34;Lack of tuples In the snippet below I overcomed such deficiency by declaring a struct. Using the new constructor syntax makes initializing a static table simple.\ntypedef struct LangSymbols { char language[40]; char start[10]; char end[10];} LangSymbols; static LangSymbols* s_lang_params_table[] = { \u0026amp;(LangSymbols) {.language = \u0026#34;fsharp\u0026#34;, .start = \u0026#34;(*\u0026#34; \u0026#34;*\u0026#34;, .end = \u0026#34;*\u0026#34; \u0026#34;*)\u0026#34;}, \u0026amp;(LangSymbols) {.language = \u0026#34;c\u0026#34;, .start = \u0026#34;/*\u0026#34; \u0026#34;*\u0026#34;, .end = \u0026#34;*\u0026#34; \u0026#34;*/\u0026#34;}, \u0026amp;(LangSymbols) {.language = \u0026#34;csharp\u0026#34;, .start = \u0026#34;/*\u0026#34; \u0026#34;*\u0026#34;, .end = \u0026#34;*\u0026#34; \u0026#34;*/\u0026#34;}, \u0026amp;(LangSymbols) {.language = \u0026#34;java\u0026#34;, .start = \u0026#34;/*\u0026#34; \u0026#34;*\u0026#34;, .end = \u0026#34;*\u0026#34; \u0026#34;*/\u0026#34;}, NULL }; Folding over arrays I need to gather all the languages, aka perform a fold over the array. You might have noticed the propensity to add a NULL terminator marker to arrays (as for strings). This allows me to avoid passing a size to functions and makes simpler writing utility macros (as foreach below) more simply.\nIn the rest of the program, every time I end a function with _z, it is because I consider it generally usable and I add a version of it without the _z to lutils.h.\n#define array_foreach_z(p) for(; *symbols != NULL; ++symbols) static char* summary(LangSymbols** symbols) { GString* langs = g_string_sized_new(20); array_foreach(symbols) g_string_append_printf(langs, \u0026#34;%s \u0026#34;, (*symbols)-\u0026gt;language); g_string_truncate(langs, strlen(langs-\u0026gt;str) - 1); GString* usage = g_string_sized_new(100); g_string_printf(usage, \u0026#34;You should specify:nt. either -l or -o and -pn\u0026#34; \u0026#34;t. either -indent or -P and -Cn\u0026#34; \u0026#34;t. -l supports: %s\u0026#34; ,langs-\u0026gt;str); return usage-\u0026gt;str; } Find an item in an array based on some expression. Returns NULL if not found. Again, this is a common task, hence I’ll abstract it out with a macro (that ends up being a cute use of gcc statment expressions).\n#define array_find_z(arr, ...)  ({ array_foreach(arr) if (__VA_ARGS__) break; *arr; }) static LangSymbols* lang_find_symbols(LangSymbols** symbols, char* lang) { g_assert(symbols); g_assert(lang); return array_find(symbols, !strcmp((*symbols)-\u0026gt;language, lang)); } Deallocating stuff You might wonder why I don’t seem overly worried about deallocating the memory that I allocate. I haven’t gone crazy(yet). You’ll see.\nDiscriminated unions Here are the discriminated unions macros from a previous blog post of mine. I’ll need a couple of these and pre-declare two functions.\nunion_decl(CodeSymbols, Indented, Surrounded) union_type(Indented, int indentation;) union_type(Surrounded, char* start_code; char* end_code;) union_end(CodeSymbols); typedef struct Options { char* start_narrative; char* end_narrative; CodeSymbols* code_symbols; } Options; static gchar* translate(Options*, gchar*); union_decl(Block, Code, Narrative) union_type(Code, char* code) union_type(Narrative, char* narrative) union_end(Block); Main data structure We want to use higher level abstractions that standard C arrays, hence we’ll pick a convenient data structure to use in the rest of the code. A queue lets you to insert at the front and back, with just a one pointer overhead over a single linked list. Hence it is my data structure of choice for this program.\nstatic GQueue* blockize(Options*, char*); There is already a function in glib to check if a string has a certain prefix (g_str_has_prefix). We need one that returns the remaining string after the prefix. We also define a g_slow_assert that is executed just if G_ENABLE_SLOW_ASSERT is defined static char* str_after_prefix(char* src, char* prefix) { g_assert(src); g_assert(prefix); g_slow_assert(g_str_has_prefix(src, prefix)); while(*prefix != \u0026#39;0\u0026#39;) if(*src == *prefix) ++src, ++prefix; else break; return src; } Tokenizer The structure of the function is identical to the F# version. The big bread-winners are statement expressions and local functions …\nIt is interesting how you can replicate the shape of an F# function by substituting ternary operators for match statements.\nIt is nothing magic, just a way to have a case statment as an expression, but it is suggestive of its more functional counterpart.\n#define NL \u0026#34;n\u0026#34; union_decl(Token, OpenComment, CloseComment, Text) union_type(OpenComment, int line) union_type(CloseComment,int line) union_type(Text, char* text) union_end(Token); GQueue* tokenize(Options* options, char* source) { g_assert(options); g_assert(source); struct tuple { int line; GString* acc; char* rem;}; bool is_opening(char* src) { return g_str_has_prefix(src, options-\u0026gt;start_narrative);} bool is_closing(char* src) { return g_str_has_prefix(src, options-\u0026gt;end_narrative);} char* remaining_open (char* src){ return str_after_prefix(src, options-\u0026gt;start_narrative);} char* remaining_close(char* src){ return str_after_prefix(src, options-\u0026gt;end_narrative);} struct tuple text(char* src, GString* acc, int line) { inline struct tuple stop_parse_text() { return (struct tuple) {.line = line, .acc = acc, .rem = src};} return str_empty (src)? stop_parse_text() : is_opening(src)? stop_parse_text() : is_closing(src)? stop_parse_text() : ({ int line2 = g_str_has_prefix(src, NL) ? line + 1 : line; GString* newAcc = g_string_append_c(acc, *src); char* rem = src + 1; text(rem, newAcc, line2); }); } GQueue* tokenize_rec(char* src, GQueue* acc, int line) { return str_empty(src) ? acc : is_opening(src) ? tokenize_rec(remaining_open(src), g_queue_push_back(acc, union_new( Token, OpenComment, .line = line)), line) : is_closing(src) ? tokenize_rec(remaining_close(src), g_queue_push_back(acc, union_new( Token, CloseComment, .line = line)), line) : ({ struct tuple t = text(src, g_string_sized_new(200), line); tokenize_rec(t.rem, g_queue_push_back(acc, union_new( Token, Text, .text = t.acc-\u0026gt;str)), t.line); }); } return tokenize_rec(source, g_queue_new(), 1); } Parser This again has a similar structure to the F# version, just longer. It is very long because it contains 3 (nested) functions which are on the verbose side in C.\nThe creation of a error macro is unfortunate. I just don’t know how to adapt g_assert_e so that it works for not pointer returning functions.\nI also need a simple function report_error to exit gracefully giving a message to the user. I didn’t found such thing in glib (?)\n#define report_error_z(...) G_STMT_START { g_print(__VA_ARGS__); exit(1); } G_STMT_END  union_decl(Chunk, NarrativeChunk, CodeChunk) union_type(NarrativeChunk, GQueue* tokens) union_type(CodeChunk, GQueue* tokens) union_end(Chunk); static GQueue* parse(Options* options, GQueue* tokens) { g_assert(options); g_assert(tokens); struct tuple { GQueue* acc; GQueue* rem;}; #define error(...)  ({ report_error(__VA_ARGS__); (struct tuple) {.acc = NULL, .rem = NULL}; }) struct tuple parse_narrative(GQueue* acc, GQueue* rem) { bool isEmpty = g_queue_is_empty(rem); Token* h = g_queue_pop_head(rem); GQueue* t = rem; return isEmpty ? error(\u0026#34;You haven\u0026#39;t closed your last narrative comment\u0026#34;) : h-\u0026gt;kind == OpenComment ? error(\u0026#34;Don\u0026#39;t open narrative comments inside narrative comments at line %i\u0026#34;, h-\u0026gt;OpenComment.line) : h-\u0026gt;kind == CloseComment ? (struct tuple) {.acc = acc, .rem = t} : h-\u0026gt;kind == Text ? parse_narrative(g_queue_push_back(acc, h), t) : error(\u0026#34;Should never get here\u0026#34;); }; struct tuple parse_code(GQueue* acc, GQueue* rem) { bool isEmpty = g_queue_is_empty(rem); Token* h = g_queue_pop_head(rem); GQueue* t = rem; return isEmpty ? (struct tuple) {.acc = acc, .rem = t} : h-\u0026gt;kind == OpenComment ? (struct tuple) {.acc = acc, .rem = g_queue_push_front(rem, h)} : h-\u0026gt;kind == CloseComment ? parse_code(g_queue_push_back(acc, h), rem) : h-\u0026gt;kind == Text ? parse_code(g_queue_push_back(acc, h), rem) : error(\u0026#34;Should never get here\u0026#34;); }; #undef error GQueue* parse_rec(GQueue* acc, GQueue* rem) { bool isEmpty = g_queue_is_empty(rem); Token* h = g_queue_pop_head(rem); GQueue* t = rem; return isEmpty ? acc : h-\u0026gt;kind == OpenComment ? ({ GQueue* emp = g_queue_new(); struct tuple tu = parse_narrative(emp, t); Chunk* ch = union_new( Chunk, NarrativeChunk, .tokens = tu.acc ); GQueue* newQ = g_queue_push_back(acc, ch); parse_rec(newQ, tu.rem); }) : h-\u0026gt;kind == CloseComment ? report_error_e( \u0026#34;Don\u0026#39;t insert a close narrative comment at the start of your\u0026#34; \u0026#34;program at line %i\u0026#34;, h-\u0026gt;OpenComment.line) : h-\u0026gt;kind == Text ? ({ GQueue* emp = g_queue_new(); struct tuple tu = parse_code(g_queue_push_front(emp, h), t); parse_rec(g_queue_push_back (acc, union_new(Chunk, CodeChunk, .tokens = tu.acc)), tu.rem); }) : g_assert_no_match; } return parse_rec(g_queue_new(), tokens); } Flattener This follows the usual practice of representing fold as foreach statments (and maps to). Pheraps I shall build better abstractions for them at some point. I also introduce a little macro to simplify writing of GFunc lambdas, given how pervasive they are.\nAgain, note how heavy ternary operated this is …\n#define g_func_z(type, name, ...) lambda(void,  (void* private_it, G_GNUC_UNUSED void* private_no){ type name = private_it; __VA_ARGS__ }) static GQueue* flatten(Options* options, GQueue* chunks) { GString* token_to_string_narrative(Token* tok) { return tok-\u0026gt;kind == OpenComment || tok-\u0026gt;kind == CloseComment ? report_error_e(\u0026#34;Cannot nest narrative comments at line %i\u0026#34;, tok-\u0026gt;OpenComment.line) : tok-\u0026gt;kind == Text ? g_string_new(tok-\u0026gt;Text.text) : g_assert_no_match; } GString* token_to_string_code(Token* tok) { return tok-\u0026gt;kind == OpenComment ? report_error_e( \u0026#34;Open narrative comment cannot be in code at line %i.\u0026#34; \u0026#34;Pheraps you have an open comment \u0026#34; \u0026#34;in a code string before this comment tag?\u0026#34; , tok-\u0026gt;OpenComment.line) : tok-\u0026gt;kind == CloseComment ? g_string_new(options-\u0026gt;end_narrative) : tok-\u0026gt;kind == Text ? g_string_new(tok-\u0026gt;Text.text) : g_assert_no_match; } Block* flatten_chunk(Chunk* ch) { return ch-\u0026gt;kind == NarrativeChunk ? ({ GQueue* tokens = ch-\u0026gt;NarrativeChunk.tokens; GString* res = g_string_sized_new(256); g_queue_foreach(tokens, g_func(Token*, tok, g_string_append( res, token_to_string_narrative(tok)-\u0026gt;str); ), NULL); union_new(Block, Narrative, .narrative = res-\u0026gt;str); }) : ch-\u0026gt;kind == CodeChunk ? ({ GQueue* tokens = ch-\u0026gt;CodeChunk.tokens; GString* res = g_string_sized_new(256); g_queue_foreach(tokens, g_func(Token*, tok, g_string_append( res, token_to_string_code(tok)-\u0026gt;str); ), NULL); union_new(Block, Code, .code = res-\u0026gt;str); }) : g_assert_no_match; } GQueue* res = g_queue_new(); g_queue_foreach(chunks, g_func(Chunk*, ch, Block* b = flatten_chunk(ch); g_queue_push_tail(res, b); ) ,NULL); return res; } Now we can tie everything together to build blockize, which is our parse tree.\nstatic GQueue* blockize(Options* options, char* source) { GQueue* tokens = tokenize(options, source); GQueue* blocks = parse(options, tokens); return flatten(options, blocks); } 10 Define the phases In C you can easily forward declare function, so you don’t have to come up with some clever escabotage like we had to do in F#. static GQueue* remove_empty_blocks(Options*, GQueue*); static GQueue* merge_blocks(Options*, GQueue*); static GQueue* add_code_tags(Options*, GQueue*); static GQueue* process_phases(Options* options, GQueue* blocks) { blocks = remove_empty_blocks(options, blocks); blocks = merge_blocks(options, blocks); blocks = add_code_tags(options, blocks); return blocks; } static char* extract(Block* b) { return b-\u0026gt;kind == Code ? b-\u0026gt;Code.code : b-\u0026gt;kind == Narrative ? b-\u0026gt;Narrative.narrative: g_assert_no_match; } There must be a higher level way to write this utility function …\nstatic bool is_str_all_spaces(const char* str) { g_assert(str); while(*str != \u0026#39;0\u0026#39;) { if(!g_ascii_isspace(*str)) return false; str++; } return true; } static GQueue* remove_empty_blocks(G_GNUC_UNUSED Options* options, GQueue* blocks) { g_queue_foreach(blocks, g_func(Block*, b, if(is_str_all_spaces(extract(b))) g_queue_remove(blocks, b); ), NULL); return blocks; } static GQueue* merge_blocks(G_GNUC_UNUSED Options*options, GQueue* blocks) { return g_queue_is_empty(blocks) ? blocks : g_queue_get_length(blocks) == 1 ? blocks : ({ Block* h1 = g_queue_pop_head(blocks); Block* h2 = g_queue_pop_head(blocks); h1-\u0026gt;kind == Code \u0026amp;\u0026amp; h2-\u0026gt;kind == Code ? ({ char* newCode = g_strjoin(\u0026#34;\u0026#34;, h1-\u0026gt;Code.code, NL, h2-\u0026gt;Code.code, NULL); Block* b = union_new(Block, Code, .code = newCode); merge_blocks(options, g_queue_push_front(blocks, b)); }) : h1-\u0026gt;kind == Narrative \u0026amp;\u0026amp; h2-\u0026gt;kind == Narrative ? ({ char* newNarr = g_strjoin( \u0026#34;\u0026#34;, h1-\u0026gt;Narrative.narrative, NL, h2-\u0026gt;Narrative.narrative, NULL); Block* b = union_new(Block, Narrative, .narrative = newNarr); merge_blocks(options, g_queue_push_front(blocks, b)); }) : ({ GQueue* newBlocks = merge_blocks(options, g_queue_push_front(blocks, h2)); g_queue_push_front(newBlocks, h1); }); }); } This really should be in glib …\ninline static gint g_asprintf_z(gchar** string, gchar const *format, ...) { va_list argp; va_start(argp, format); gint bytes = g_vasprintf(string, format, argp); va_end(argp); return bytes; } static char* indent(int n, char* s) { g_assert(s); char* ind = g_strnfill(n, \u0026#39;\u0026#39;); char* tmp; g_asprintf(\u0026amp;tmp, \u0026#34;%s%s\u0026#34;, ind, s); char* withNl; g_asprintf(\u0026amp;withNl, \u0026#34;n%s\u0026#34;, ind); return g_strjoinv(withNl, g_strsplit(tmp, NL, -1)); } And finally I ended up defining map. See if you like how the usage looks in the function below. #define g_queue_map_z(q, type, name, ...) ({  GQueue* private_res = g_queue_new(); g_queue_foreach(q, g_func(type, name, name = __VA_ARGS__; g_queue_push_tail(private_res, name); ), NULL); private_res; }) static GQueue* add_code_tags(Options* options, GQueue* blocks) { GQueue* indent_blocks(GQueue* blocks) { return g_queue_map(blocks, Block*, b, b-\u0026gt;kind == Narrative ? b : b-\u0026gt;kind == Code ? union_new(Block, Code, .code = indent(options-\u0026gt;code_symbols-\u0026gt;Indented.indentation, b-\u0026gt;Code.code)) : g_assert_no_match;); } GQueue* surround_blocks(GQueue* blocks) { return g_queue_map(blocks, Block*, b, b-\u0026gt;kind == Narrative ? union_new(Block, Narrative, .narrative = g_strjoin(\u0026#34;\u0026#34;, NL, g_strstrip(b-\u0026gt;Narrative.narrative), NL, NULL)) : b-\u0026gt;kind == Code ? union_new(Block, Code, .code = g_strjoin(\u0026#34;\u0026#34;, NL, options-\u0026gt;code_symbols-\u0026gt;Surrounded.start_code, NL, g_strstrip(b-\u0026gt;Code.code), NL, options-\u0026gt;code_symbols-\u0026gt;Surrounded.end_code, NL, NULL)) : g_assert_no_match;); } return options-\u0026gt;code_symbols-\u0026gt;kind == Indented ? indent_blocks(blocks) : options-\u0026gt;code_symbols-\u0026gt;kind == Surrounded ? surround_blocks(blocks) : g_assert_no_match; } char* stringify(GQueue* blocks) { GString* res = g_string_sized_new(2048); g_queue_foreach(blocks, g_func(Block*, b, g_string_append(res, extract(b)); ), NULL); return g_strchug(res-\u0026gt;str); } void deb(GQueue* q); static char* translate(Options* options, char* source) { g_assert(options); g_assert(source); GQueue* blocks = blockize(options, source); blocks = process_phases(options, blocks); return stringify(blocks); } Parsing the command line In glib there is a command line parser that accept options in unix-like format and automatically produces professional \u0026ndash;help messages and such. We shoudl really have something like this in .NET. Pheraps we do and I’m not aware of it?\ntypedef struct CmdOptions { char* input_file; char* output_file; Options* options;} CmdOptions; static CmdOptions* parse_command_line(int argc, char* argv[]); static char *no = NULL, *nc = NULL, *l = NULL, *co = NULL, *cc = NULL, *ou = NULL; static char** in_file; static int ind = 0; static bool tests = false; // this is a bug in gcc, fixed in 2.7.0 not to moan about the final NULL #pragma GCC diagnostic push#pragma GCC diagnostic ignored \u0026#34;-Wmissing-field-initializers\u0026#34; static GOptionEntry entries[] = { { \u0026#34;language\u0026#34; , \u0026#39;l\u0026#39;, 0, G_OPTION_ARG_STRING, \u0026amp;l , \u0026#34;Language used\u0026#34;, \u0026#34;L\u0026#34; }, { \u0026#34;output\u0026#34; , \u0026#39;o\u0026#39;, 0, G_OPTION_ARG_FILENAME, \u0026amp;ou, \u0026#34;Defaults to the input file name with mkd extension\u0026#34;, \u0026#34;FILE\u0026#34; }, { \u0026#34;narrative-open\u0026#34; , \u0026#39;p\u0026#39;, 0, G_OPTION_ARG_STRING, \u0026amp;no, \u0026#34;String opening a narrative comment\u0026#34;, \u0026#34;NO\u0026#34; }, { \u0026#34;narrative-close\u0026#34; , \u0026#39;c\u0026#39;, 0, G_OPTION_ARG_STRING, \u0026amp;nc, \u0026#34;String closing a narrative comment\u0026#34;, \u0026#34;NC\u0026#34; }, { \u0026#34;code-open\u0026#34; , \u0026#39;P\u0026#39;, 0, G_OPTION_ARG_STRING, \u0026amp;co, \u0026#34;String opening a code block\u0026#34;, \u0026#34;CO\u0026#34; }, { \u0026#34;code-close\u0026#34; , \u0026#39;C\u0026#39;, 0, G_OPTION_ARG_STRING, \u0026amp;cc, \u0026#34;String closing a code block\u0026#34;, \u0026#34;CC\u0026#34; }, { \u0026#34;indent\u0026#34; , \u0026#39;i\u0026#39;, 0, G_OPTION_ARG_INT, \u0026amp;ind, \u0026#34;Indent the code by N whitespaces\u0026#34;, \u0026#34;N\u0026#34; }, { \u0026#34;run-tests\u0026#34; , \u0026#39;t\u0026#39;, G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE, \u0026amp;tests, \u0026#34;Run all the testcases\u0026#34;, NULL }, { G_OPTION_REMAINING , 0, 0, G_OPTION_ARG_FILENAME_ARRAY, \u0026amp;in_file, \u0026#34;Input file to process\u0026#34;, \u0026#34;FILE\u0026#34; }, { NULL } }; #pragma GCC diagnostic popBrain damaged way to run tests with a -t hidden option. Not paying the code size price in release.\n#ifndef NDEBUG#include \u0026#34;tests.c\u0026#34;#endifHere is my big ass command parsing function. It could use a bit of refactoring … void destroy_arena_allocator(); static CmdOptions* parse_command_line(int argc, char* argv[]) { GError *error = NULL; GOptionContext *context; context = g_option_context_new (\u0026#34;- translate source code with comemnts to an annotated file\u0026#34;); g_option_context_add_main_entries (context, entries, NULL); g_option_context_set_summary(context, summary(s_lang_params_table)); if (!g_option_context_parse (context, \u0026amp;argc, \u0026amp;argv, \u0026amp;error)) report_error(\u0026#34;option parsing failed: %s\u0026#34;, error-\u0026gt;message); CmdOptions* opt = g_new(CmdOptions, 1); opt-\u0026gt;options = g_new(Options, 1); #ifndef NDEBUG if(tests) { int i = run_tests(argc, argv); exit(i); } #endif if(!in_file) report_error(\u0026#34;No input file\u0026#34;); opt-\u0026gt;input_file = *in_file; // Uses input file without extension, adding extension .mkd (assume markdown)  opt-\u0026gt;output_file = ou ? ou : ({ char* output = g_strdup(*in_file); char* extension = g_strrstr(output, \u0026#34;.\u0026#34;); extension ? ({ *extension = \u0026#39;0\u0026#39;; g_strjoin(\u0026#34;\u0026#34;, output, \u0026#34;.mkd\u0026#34;, NULL); }) : g_strjoin(\u0026#34;\u0026#34;, output, \u0026#34;.mkd\u0026#34;, NULL); }); if(l) { // user passed a language  LangSymbols* lang = lang_find_symbols(s_lang_params_table, l); if(!lang) report_error(\u0026#34;%s is not a supported language\u0026#34;, l); opt-\u0026gt;options-\u0026gt;start_narrative = lang-\u0026gt;start; opt-\u0026gt;options-\u0026gt;end_narrative = lang-\u0026gt;end; } else { if(!no || !nc) report_error(\u0026#34;You need to specify either -l, or both -p and -c\u0026#34;); opt-\u0026gt;options-\u0026gt;start_narrative = no; opt-\u0026gt;options-\u0026gt;end_narrative = nc; } if(ind) { // user pass g_option_context_free();  opt-\u0026gt;options-\u0026gt;code_symbols = union_new(CodeSymbols, Indented, .indentation = ind); } else { if(!co || !cc) report_error(\u0026#34;You need to specify either -indent, or both -P and -C\u0026#34;); opt-\u0026gt;options-\u0026gt;code_symbols = union_new(CodeSymbols, Surrounded, .start_code = co, .end_code = cc); } return opt; } Some windows programs (i.e. notepad, VS, …) add a 3 bytes prelude to their utf-8 files, C doesn’t know anything about it, so you need to strip it. On this topic, I suspect the program works on UTF-8 files that contain non-ASCII chars, even if when I wrote it I didn’t know anything about localization.\nIt should work because I’m just splitting the file when I see a certain ASCII string and in UTF-8 ASCII chars cannot appear anywhere else than in their ASCII position.\nchar* skip_utf8_bom(char* str) { unsigned char* b = (unsigned char*) str; return b[0] == 0xEF \u0026amp;\u0026amp; b[1] == 0xBB \u0026amp;\u0026amp; b[2] == 0xBF ? (char*) \u0026amp;b[3] : // UTF-8  (char*) b; } Not freeing memory (again) The reason I haven’t been freeing memory all along is because I was planning on using an arena allocator (a kind of linear allocator).\nMemory management is fully hortogonal to the style of programming described in this post. You can do it whatever way you prefer, but there is a certain affinity between an arena allocator (or garbage collection) and functional programming because of the temporary objects created in expressions. You could create the temporary objects explicitely, but that would diminish the conciseness of the paradigm.\nI have an arena allocator implementation here. In the code below I comment it out so that you don’t have a dependency from that code if you want to try this. The program runs so quickly and it does so little that you can probably let the operating system reclame memory at the end of the process life.\nIf you ended up integrating this with an editor (i.e. literate programming editing), you’d need to be more careful.\n#ifdef ARENA Arena_T the_arena; inline static gpointer arena_malloc(gsize n_bytes) { return Arena_alloc(the_arena, n_bytes, __FILE__, __LINE__); } inline static gpointer arena_calloc(gsize n_blocks, gsize n_block_bytes) { return Arena_calloc(the_arena, n_blocks, n_block_bytes, __FILE__, __LINE__); } inline static gpointer arena_realloc(gpointer mem, gsize n_bytes) { return Arena_realloc(the_arena, mem, n_bytes, __FILE__, __LINE__); } void arena_free(G_GNUC_UNUSED gpointer mem) { // NOP } void set_arena_allocator() { GMemVTable vt = (GMemVTable) { .malloc = arena_malloc, .calloc = arena_calloc, .realloc = arena_realloc, .free = arena_free, .try_malloc = arena_malloc, .try_realloc = arena_realloc}; g_mem_set_vtable(\u0026amp;vt); the_arena = Arena_new(); } void destroy_arena_allocator() { Arena_dispose(\u0026amp;the_arena); } #endifSummary I have to say, it didn’t feel too cumbersome to structure C code in a functional way, assuming that you can use GLib and a couple of GCC extensions to the language. It certainly doesn’t have the problems that C++ has in terms of debugging STL failures.\nThere are a couple of things I don’t like about GLib and I’m working on an hobby project to overcome them. Eventually I’ll post it.\nint main(int argc, char* argv[]) { #ifdef ARENA set_arena_allocator(); #endif CmdOptions* opt = parse_command_line(argc, argv); char* source = NULL; GError* error = NULL; if(!g_file_get_contents(opt-\u0026gt;input_file, \u0026amp;source, NULL, \u0026amp;error)) report_error(error-\u0026gt;message); source = skip_utf8_bom(source); char* text = translate(opt-\u0026gt;options, source); if(!g_file_set_contents(opt-\u0026gt;output_file, text, -1, \u0026amp;error)) report_error(error-\u0026gt;message); #ifdef ARENA destroy_arena_allocator(); #endif return 0; } ","permalink":"https://peaceiris.com/MyBlog/posts/2013-03-20-funky-c-for-literate-programming/","tags":["C","fsharp","Functional Programming","Literate programming"],"title":"Funky C for literate programming"},{"categories":["C","Functional Programming"],"contents":"Cleanup Let\u0026rsquo;s start simple with the cleanup function. First we need the usual barrage of includes. G_BEGIN_DECLS allows the header to be linked in C++.\n#ifndef L_UTILS_INCLUDED#define L_UTILS_INCLUDED #include \u0026#34;glib.h\u0026#34; G_BEGIN_DECLS #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;This feature is GCC specific. It uses __attribute((cleanup(f))) where f is the cleanup function. In this case the cleanup function just frees the memory. #ifdef __GNUC__ static inline void __autofree(void *p) { void **_p = (void**)p; free(*_p); } auto_clean is a building block that you can use to plug in your own cleanup function. In the common case of memory allocation, I created a wrapper macro auto_free to make it even easier.\n#define auto_clean(f) __attribute((cleanup(f)))#define auto_free auto_clean(__autofree)Lambdas I took this one from here.\nIf you think about it, a lambda is just an expression that returns a function. This macro creates a nested function, called fn, inside a statement expression and returns it. Unfortunately these features are gcc specific.\nRemember that lambdas are not allocated on the heap, so you have to be careful on how you used them.\n#define lambda(return_type, function_body)  ({ return_type __fn__ function_body __fn__; }) #endifUnions A union type is what you would expect: a struct that contains an unnamed union and a field to specify which type it is. We need the list of types in union_decl to create the kind enum. The usage of VA_ARGS allows to use whatever syntax you want to go into the enum (i.e. specify int values).\nHaving to specify the the types here is unfortunate as you are going to need to specify it in the union_case macros as well.\nI haven\u0026rsquo;t found another way to do it. If you do, let me know.\n#define union_decl(alg, ...) typedef struct alg { enum { __VA_ARGS__ } kind; union { You specify each type for the union with union_type. That looks pretty good to me.\n#define union_type(type, ...)  struct type { __VA_ARGS__ } type; Ideally you shouldn\u0026rsquo;t need to specify alg here. Perhaps there is a way to avoid doing so.\n#define union_end(alg)  };} alg; You can then set the fields on the union type by using the below macro. Notice the usage of the new struct constructor here to allow optional named parameters.\nThis is a statement, so it cannot go into an expression place. I think I could make it an expression that returns the existing (or a new) union. This is going to be a sceanrio if people are not using gcc statement expressions.\n#define union_set(instance, type, ...)  G_STMT_START { (instance)-\u0026gt;kind = (type); (instance)-\u0026gt;type = (struct type) { __VA_ARGS__ }; } G_STMT_END This is an utility macro. It is a version of g_assert that you can use in an expression position.\n#define g_assert_e(expr) (  (G_LIKELY (!expr) ? (void)g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr) : (void) 1) ) And this allows to fill the default case in a match statement implemented as a ternary operator. It prints out a text representation of the expression and returns it.\n#define union_fail(...) (g_assert_e(((void)(__VA_ARGS__) , false)), (__VA_ARGS__))The rest of the code is commented out. It is a macro way to do pattern matching. For me, the ternary operator is simpler, but I left it there in case you want to play with it.\n/* #define union_case_only_s(instance, type, ...) G_STMT_START { if((instance)-\u0026gt;kind == (type)) { G_GNUC_UNUSED struct type* it = \u0026amp;((instance)-\u0026gt;type); __VA_ARGS__; } else g_assert_not_reached(); } G_STMT_END #define union_case_first_s(alg, instance, type, ...) G_STMT_START { alg* private_tmp = (instance); if(private_tmp-\u0026gt;kind == type) { G_GNUC_UNUSED struct type* it = \u0026amp;((private_tmp)-\u0026gt;type); __VA_ARGS__; } #define union_case_s(type, ...) else if(private_tmp-\u0026gt;kind == type) { G_GNUC_UNUSED struct type* it = \u0026amp;((private_tmp)-\u0026gt;type); __VA_ARGS__; } #define union_case_last_s(type, ...) else if(private_tmp-\u0026gt;kind == type) { G_GNUC_UNUSED struct type* it = \u0026amp;((private_tmp)-\u0026gt;type); __VA_ARGS__; } else g_assert_not_reached(); } G_STMT_END #define union_case_default_s(...) else __VA_ARGS__; } G_STMT_END // Need to use assert here because g_assert* cannot be used in expressions as it expands to do .. while(0) #define union_case_only(instance, type, ...) ( (instance)-\u0026gt;kind == (type) ? (__VA_ARGS__) : (assert(false), __VA_ARGS__) ) #define union_case_first(instance, type, ...) ( (instance)-\u0026gt;kind == (type) ? (__VA_ARGS__) : #define union_case(instance, type, ...) (instance)-\u0026gt;kind == (type) ? (__VA_ARGS__) : #define union_case_last(instance, type, ...) (instance)-\u0026gt;kind == (type) ? (__VA_ARGS__) : (assert(false), (__VA_ARGS__)) ) #define union_case_default(...) (__VA_ARGS__) ) */ G_BEGIN_DECLS #endif // L_UTILS_INCLUDED ","permalink":"https://peaceiris.com/MyBlog/posts/2013-01-11-functional-programming-in-c-implementation/","tags":["C","Functional Programming"],"title":"Functional programming in C: Implementation"},{"categories":["C","Functional Programming"],"contents":"This post/program (as I’m writing it in literate style) is a continuation of my previous posts about functional programming in C++. I promise I’m not going to post about doing it in assembly language (I think) ….\nI came to like the simplicity of C very much and got interested in how you could write functional code in it.\nThere is one irritating thing about C as a viable programming language. Microsoft’s compiler support is not good. It just supports ANSI C, not C99 or C11. So, if you want to use more modern idyoms, you got to use gcc or clang. In this post I assume you use gcc. I will point out the gcc specific extensions.\nAlso, the C standard library is pretty limited, so I decided to use GLib to complement it. I also created some macros to simplify the syntax. I never understood why people like templates and think macros are evil. It takes me all of 5 minutes to do a -E on GCC to debug the result of a macro expansion. With templates, well, that’s different.\nSo, in summary, this post is about how you can write functional code in C, perhaps with some gcc extensions and certainly with some macro tricks. Let’s call it funkyC (thanks Ian ). I’m going to show how to use it first. Next post I’m going to show how it’s implemented.\nDiscriminated unions in C With a bit of macro magic, you can get a decent looking discriminated union syntax. First we need to include the correct headers. lutils.h is where all the macros are defined.\n#include \u0026lt;glib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;stdbool.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;string.h\u0026gt; #include \u0026#34;lutils.h\u0026#34;Then you can declare a discriminated union with the syntax below. It suffers from two problems: repeting the list of possible types in union_decl and repeating the name of the discriminated union in union_end. Perhaps there is a way to avoid that, but I haven’t found it.\nThe syntax for the union_type call is the same as you would use inside a struct declaration. We’ll see how this works when we look at lutils.h.\nunion_decl (Car, Volvo, Fiat, Ferrari) union_type (Volvo, int x; double y;) union_type (Fiat, char* brand, *model;) union_type (Ferrari, char* brand, *model;) union_end (Car) We can create a Car either on the stack, as below, or on the heap and we can set its value with union_set.\nNotice the usage of the new struct construction syntax to simulate optional named parameters in C. I would prefer not to have a dot at the start of the name, but overall it is beautiful (if I can say that myself).\nstatic void printCar(Car*); static void testUnion() { Car c; union_set (\u0026amp;c, Volvo, .x = 3, .y = 4); printCar (\u0026amp;c); union_set (\u0026amp;c, Ferrari, .brand = \u0026#34;Ferrari\u0026#34;); printCar (\u0026amp;c); union_set (\u0026amp;c, Fiat, .brand = \u0026#34;Fiat\u0026#34;, .model = \u0026#34;234\u0026#34;); printCar (\u0026amp;c); } You can then access values inside your discriminated union with normal if statements.\nstatic void testCar(Car*, char const *); static void printCar(Car* c) { if(c-\u0026gt;kind == Volvo) { int x = c-\u0026gt;Volvo.x; g_assert_cmpint(x, ==, 3); } Or perhaps you want the equivalent of a match statement in F# (aka an expression that returns a value based on the type of the discriminated union). Notice that, as logical, all the expressions need to return the same type. That’s why union_fail takes a value of the expression type.\nchar temp[40]; char* value = c-\u0026gt;kind == Volvo ? itoa(c-\u0026gt;Volvo.x, temp, 10) : c-\u0026gt;kind == Ferrari ? (void)c-\u0026gt;Ferrari.model, c-\u0026gt;Ferrari.brand : c-\u0026gt;kind == Fiat ? c-\u0026gt;Fiat.model : union_fail(\u0026#34;Not a valid car type\u0026#34;); If you are willing to be gcc specific, then your expression can be comprised of multiple statements, of which the last one returns the value of the expression. This allows a much more flexible syntax for your match clauses.\n#ifdef __GNUC__ value = c-\u0026gt;kind == Volvo ? ({ struct Volvo* it = \u0026amp;c-\u0026gt;Volvo; itoa(it-\u0026gt;x, temp, 10); }) : c-\u0026gt;kind == Ferrari ? (void)c-\u0026gt;Ferrari.model, c-\u0026gt;Ferrari.brand : c-\u0026gt;kind == Fiat ? c-\u0026gt;Fiat.model : union_fail(\u0026#34;Not a valid car type\u0026#34;); testCar(c, value); #endif // __GNUC__ } We then use the super simple test framework in GLib to make sure that it all works as expected …\nstatic void testCar(Car* c, char const * value) { if(c-\u0026gt;kind == Volvo) g_assert_cmpstr(value, ==, \u0026#34;3\u0026#34;); else if (c-\u0026gt;kind == Fiat) g_assert_cmpstr(value, ==, \u0026#34;234\u0026#34;); else if (c-\u0026gt;kind == Ferrari) g_assert_cmpstr(value, ==, \u0026#34;Ferrari\u0026#34;); else g_assert_not_reached(); } Nested functions and lambda variables GCC has many other cool extensions. A very simple one is nested functions. It allows you to nest functions :-) Look at the definition of doA and f2 in the function below. Putting together nested functions and block statement expressions allows you, with some macro magic, to define lambda functions in your code (from here ).\nRemember that lambdas (aka nested functions) are allocated on the stack. They are very fast, but you cannot store their pointer into a gloal table (unless such table is used while the stack for this function is alive).\nIn such cases, you have to create a proper function. But for the other 90% of use cases, they work pretty well. They are lambdas in the spirit of C: very fast, but error prone …\n#ifdef __GNUC__ static void testLambda() { typedef int (*aFunc) (int); aFunc doA(aFunc f){ int k(int i) { return f(i) + 3; } return k; } int clos = 2; int f2 (int i) {return i;} aFunc b = doA(lambda (int, (int p) {return p + clos;})); g_assert_cmpint(b(3), ==, 8); } Automatic cleanup of local variables This is not a functional topic per se, but something that always annoyed me tremendously about C. The fact that you cannot define the equivalent of the using statement in C#, or destructors in C++. Well, now you can. Or not?\nAgain, if you are willing to be GCC specific, you can use an attribute (more on this in the upcoming implementation post) to associate a cleanup function that gets called when your variable goes out of scope. In this case, I wrapped the free case in a nice looking macro.\nBut that doesn’t really work. You would certainly want such function to be called on any kind of exit from the enclosing scope (aka via exit(), abort() or longjmp()). Alas, that doesn’t happen.\nThis reduces the usefulness of this mechanism tremendously. Probably too much in that it lulls you into a false sense of security. You still need to free your resources in the error path of your application.\nstatic void testAutomaticCleanup() { char* stack_alloc() { auto_free char* b = g_malloc(10000); memset(b, \u0026#39;#\u0026#39;, 10000); return b; }; char * c = stack_alloc(); g_assert(*c != \u0026#39;#\u0026#39;); } #endifData structures GLib comes with a vast library of data structures to use, not too different from the .NET framework or Java. For example, below you have a single linked list …\nstatic void testGLib() { GSList* list = NULL; list = g_slist_append(list, \u0026#34;Three\u0026#34;); list = g_slist_prepend(list, \u0026#34;first\u0026#34;); g_assert_cmpint(g_slist_length(list), ==, 2); list = g_slist_remove(list, \u0026#34;first\u0026#34;); g_assert_cmpint(g_slist_length(list), ==, 1); g_slist_free(list); } Wrapping up There you go, rising the level of abstraction of C, still keeping it very fast (if you are willing to be gcc bound).\nThere are other features in functional programming languages that are not in this post. Maybe I’ll get around to macro my way into them eventually, maybe not.\nIn the next post we’ll talk about how all of this is implemented. Below is the code for running the testcases.\nint runTests(int argc, char* argv[]) { g_test_init(\u0026amp;argc, \u0026amp;argv, NULL); if(g_test_quick()) { g_test_add_func(\u0026#34;/utils/automatic_cleanup\u0026#34;, testAutomaticCleanup); g_test_add_func(\u0026#34;/utils/lambda\u0026#34;, testLambda); g_test_add_func(\u0026#34;/utils/Union\u0026#34;, testUnion); g_test_add_func(\u0026#34;/utils/SList\u0026#34;, testGLib); } return g_test_run(); } int main(int argc, char *argv[]) { return runTests(argc, argv); } ","permalink":"https://peaceiris.com/MyBlog/posts/2013-01-04-functional-programming-in-c/","tags":["C","Functional Programming"],"title":"Functional programming in C"},{"categories":["C","fsharp","Literate programming"],"contents":"Main ideas My interest in literate programming comes from some realizations on my part:\n When I go back to code that I have written some time ago, I don\u0026rsquo;t remember my reasoning When I write a blog post, my code seems to be better. Perhaps explaining things to people encourages me to be more precise I like to think top down, but the compiler forces me to write code bottom up, starting from details and going to higher level concepts  Unhappiness with existing tools Many of the existing literate programming tools work similarly to the original CWeb.\n They have a tangle program that goes over your file and extract something that the compiler can understand They have a weave program that extracts from your file something that the document generator can understand  This scheme has the unfortunate limitation of breaking your code editor. Given that your file is not a valid code file anymore, the editor starts misbehaving (i.e. intellisense breaks). The debugger starts to get confused (albeit people tried to remediate that with cleaver use of #line. If your language has an interactive console, that would not work either.\nA different interpretation The main idea of this program is to add your narrative to the comment part of a code file by extending the comment tag (i.e. in C you could use /** ). This keeps editor, debugger and interactive console working.\nThe weave phase as been retained and what you are reading is the program that goes over your code file and extracts a nicely formatted (for this program in \u0026lsquo;markdown\u0026rsquo; format) file that can then be translated to HTML, PDF, latex, etc\u0026hellip;\nYou got that? The document you are reading now is the program.\nMulti-language, multi-document format LLite works for any programming language, assuming it has open and close comment character sequences, and any documentation format, assuming it has open and close code character sequences (aka allows you to delimitate your code somehow), or it needs the code to be indented. This document uses markdown (with Pandoc extensions to generate table of contents and titles).\nUsage You invoke the program as documented below. The first set of parameters lets you choose the symbols that delimitate your language comments (or the default symbols below). The second set of parameters lets you choose how your target documentation language treats code. Either it delimits it with some symbols or it indents it.\nmodule LLite let langParamsTable = [ \u0026#34;fsharp\u0026#34;, (\u0026#34;(*\u0026#34; + \u0026#34;*\u0026#34;, \u0026#34;*\u0026#34; + \u0026#34;*)\u0026#34;) // The + is not to confuse the parser  \u0026#34;c\u0026#34;, (\u0026#34;/**\u0026#34;, \u0026#34;**/\u0026#34;) \u0026#34;csharp\u0026#34;, (\u0026#34;/**\u0026#34;, \u0026#34;**/\u0026#34;) \u0026#34;java\u0026#34;, (\u0026#34;/**\u0026#34;, \u0026#34;**/\u0026#34;)] |\u0026gt; Map.ofList let languages = langParamsTable |\u0026gt; Map.fold (fun state lang _ -\u0026gt; state + lang + \u0026#34;\u0026#34;) \u0026#34;\u0026#34; let usage = sprintf @\u0026#34;Usage: llite inputFile parameters where: One of the following two sets of parameters is mandatory -no string : string opening a narrative comment -nc string : string closing a narrative comment or -l language: where language is one of (%s) One of the following two sets of parameters is mandatory -co string : string opening a code block -cc string : string closing a code block or -indent N : indent the code by N whitespaces The following parameters are optional: -o outFile : defaults to the input file name with mkd extension\u0026#34; languages let getLangNoNC lang = match Map.tryFind lang langParamsTable with | Some(no, nc) -\u0026gt; no, nc | None -\u0026gt; failwith (lang + \u0026#34;is not a valid programming language\u0026#34;) Programming Languages limitations One of the main tenets of literate programming is that the code should be written in the order that facilitates exposition to a human reader, not in the order that makes the compiler happy. This is very important.\nIf you have written a blog post or tried to explain a codebase to a new joiner, you must have noticed that you don\u0026rsquo;t start from the top of the file and go down, but jump here and there trying to better explain the main concepts. Literate programming says that you should write your code the same way. But in our version of it, the compiler needs to be kept happy because the literate file is the code file.\nSome ingenuity is required to achieve such goal:\n In C and C++ you can forward declare functions and classes, also class members can be in any order In C#, Java, VB.NET, F# (the object oriented part) you can write class members in any order In the functional part of F# you do have a problem (see later in this doc)  The F# trick below is used in the rest of the program. You\u0026rsquo;ll understand its usage naturally by just reading the code\nlet declare\u0026lt;\u0026#39;a\u0026gt; = ref Unchecked.defaultof\u0026lt;\u0026#39;a\u0026gt; Implementation At the core, this program is a simple translator that takes some code text and return a valid markdown/whatever text. We need to know:\n The strings that start and end a narrative comment (input symbols) How to translate a code block into a document. We support these variations:  Indented: indent them by N spaces Surrounded by startCode/endCode strings    type CodeSymbols = | Indent of int // indentation level in whitespaces  | Surrounded of string * string // start code * end code  type Options = { startNarrative : string endNarrative : string codeSymbols : CodeSymbols } let translate = declare\u0026lt;Options -\u0026gt; string -\u0026gt; string\u0026gt; Going over the parse tree We need a function that takes a string and returns a list with the various blocks. We can then go over each block, perform some operations and, in the end, transform it back to text\ntype Block = | Code of string | Narrative of string let blockize = declare\u0026lt;Options -\u0026gt; string -\u0026gt; Block list\u0026gt; I could have used regular expressions to parse the program, but it seemed ugly. I could also have used FsParsec, but that brings with it an additional dll. So I decided to roll my own parser. This has several problems:\n It is probably very slow It doesn\u0026rsquo;t allow narrative comments inside comments, in particular it doesn\u0026rsquo;t allow the opening comment It doesn\u0026rsquo;t allow opening comments in the program code (not even inside a string)  The latter in particular is troublesome. You\u0026rsquo;ll need to use a trick in the code (i.e. concatenating strings) to foul this program in not seeing an opening comment, but it is inconvenient.\nWith all of that, it works.\nTODO: consider switching to FsParsec\n###Lexer\nThe lexer is going to process list of characters. We need functions to check if a list of characters starts with certain chars and to return the remaining list after having removed such chars.\nBTW: these functions are polymorphic and tail recursive\nlet rec startWith startItems listToCheck = match startItems, listToCheck with | [], _ -\u0026gt; true | _ , [] -\u0026gt; false | h1::t1, h2::t2 when h1 = h2 -\u0026gt; startWith t1 t2 | _, _ -\u0026gt; false let rec remove itemsToRemove listToModify = match itemsToRemove, listToModify with | [], l -\u0026gt; l | _ , [] -\u0026gt; failwith \u0026#34;Remove not defined on an empty list\u0026#34; | h1::t1, h2::t2 when h1 = h2 -\u0026gt; remove t1 t2 | _, _ -\u0026gt; failwith \u0026#34;itemsToRemove are not in the list\u0026#34; let isOpening options = startWith (List.ofSeq options.startNarrative) let isClosing options = startWith (List.ofSeq options.endNarrative) let remainingOpen options = remove (List.ofSeq options.startNarrative) let remainingClose options = remove (List.ofSeq options.endNarrative) This is a pretty basic tokenizer. It just analyzes the start of the text and returns what it finds. It also keeps track of the line number for the sake of reporting it in the error message.\nlet NL = System.Environment.NewLine type Token = | OpenComment of int | CloseComment of int | Text of string let tokenize options source = let startWithNL = startWith (Seq.toList NL) let rec text line acc = function | t when isOpening options t -\u0026gt; line, acc, t | t when isClosing options t -\u0026gt; line, acc, t | c :: t as full -\u0026gt; let line\u0026#39; = if startWithNL full then line + 1 else line text line\u0026#39; (acc + c.ToString()) t | [] -\u0026gt; line, acc, [] let rec tokenize\u0026#39; line acc = function | [] -\u0026gt; List.rev acc | t when isOpening options t -\u0026gt; tokenize\u0026#39; line (OpenComment(line)::acc) (remainingOpen options t) | t when isClosing options t -\u0026gt; tokenize\u0026#39; line (CloseComment(line)::acc) (remainingClose options t) | t -\u0026gt; let line, s, t\u0026#39;= text line \u0026#34;\u0026#34; t tokenize\u0026#39; line (Text(s) :: acc) t\u0026#39; tokenize\u0026#39; 1 [] (List.ofSeq source) ###Parser\nThe parse tree is just a list of Chunks, where a chunk can be a piece of narrative or a piece of code.\ntype Chunk = | NarrativeChunk of Token list | CodeChunk of Token list let parse options source = let rec parseNarrative acc = function | OpenComment(l)::t -\u0026gt; failwith (\u0026#34;Don\u0026#39;t open narrative comments inside narrative comments at line \u0026#34; + l.ToString()) | CloseComment(_)::t -\u0026gt; acc, t | Text(s)::t -\u0026gt; parseNarrative (Text(s)::acc) t | [] -\u0026gt; failwith \u0026#34;You haven\u0026#39;t closed your last narrative comment\u0026#34; let rec parseCode acc = function | OpenComment(_)::t as t\u0026#39; -\u0026gt; acc, t\u0026#39; | CloseComment(l)::t -\u0026gt; parseCode (CloseComment(l)::acc) t | Text(s)::t -\u0026gt; parseCode (Text(s)::acc) t | [] -\u0026gt; acc, [] let rec parse\u0026#39; acc = function | OpenComment(_)::t -\u0026gt; let narrative, t\u0026#39; = parseNarrative [] t parse\u0026#39; (NarrativeChunk(narrative)::acc) t\u0026#39; | Text(s)::t -\u0026gt; let code, t\u0026#39; = parseCode [Text(s)] t parse\u0026#39; (CodeChunk(code)::acc) t\u0026#39; | CloseComment(l)::t -\u0026gt; failwith (\u0026#34;Don\u0026#39;t insert a close narrative comment at the start of your program at line \u0026#34; + l.ToString()) | [] -\u0026gt; List.rev acc parse\u0026#39; [] (List.ofSeq source) ###Flattener\nThe flattening part of the algorithm is a bit unusual. At this point we have a parse tree that contains tokens, but we want to reduce it to two simple node types containing all the text in string form.\nTODO: consider managing nested comments and comments in strings (the latter has to happen in earlier phases)\nlet flatten options chunks = let tokenToStringNarrative = function | OpenComment(l) | CloseComment(l) -\u0026gt; failwith (\u0026#34;Narrative comments cannot be nested at line \u0026#34; + l.ToString()) | Text(s) -\u0026gt; s let tokenToStringCode = function | OpenComment(l) -\u0026gt; failwith (\u0026#34;Open narrative comment cannot be in code at line\u0026#34; + l.ToString()) + \u0026#34;. Perhaps you have an open comment in\u0026#34; + \u0026#34;a code string before this comment tag?\u0026#34; | CloseComment(_) -\u0026gt; string(options.endNarrative |\u0026gt; Seq.toArray) | Text(s) -\u0026gt; s let flattenChunk = function | NarrativeChunk(tokens) -\u0026gt; Narrative(tokens |\u0026gt; List.fold (fun state token -\u0026gt; state + tokenToStringNarrative token) \u0026#34;\u0026#34;) | CodeChunk(tokens) -\u0026gt; Code(tokens |\u0026gt; List.fold (fun state token -\u0026gt; state + tokenToStringCode token) \u0026#34;\u0026#34;) chunks |\u0026gt; List.fold (fun state chunk -\u0026gt; flattenChunk chunk :: state) [] |\u0026gt; List.rev We are getting there, now we have a list of blocks we can operate upon\nblockize := fun options source -\u0026gt; source |\u0026gt; tokenize options |\u0026gt; parse options |\u0026gt; flatten options Narrative comments phases Each phase is a function that takes the options and a block list and returns a block list that has been \u0026lsquo;processed\u0026rsquo; in some way.\ntype Phase = Options -\u0026gt; Block List -\u0026gt; Block List let removeEmptyBlocks = declare\u0026lt;Phase\u0026gt; let mergeBlocks = declare\u0026lt;Phase\u0026gt; let addCodeTags = declare\u0026lt;Phase\u0026gt; let processPhases options blockList = blockList |\u0026gt; !removeEmptyBlocks options |\u0026gt; !mergeBlocks options |\u0026gt; !addCodeTags options We want to manage how many newlines there are between different blocks, because we don\u0026rsquo;t trust the programmer to have a good view of how many newline to keep from comment blocks and code blocks. We\u0026rsquo;ll trim all newlines from the start and end of a block, and then add our own.\nlet newLines = [|\u0026#39;\\n\u0026#39;;\u0026#39;\\r\u0026#39;|] type System.String with member s.TrimNl () = s.Trim(newLines) ###Remove empty blocks\nThere might be empty blocks (i.e. between two consecutive comment blocks) in the file. For the sake of formatting the file beautifully, we want to remove them.\nlet extract = function | Code(text) -\u0026gt; text | Narrative(text) -\u0026gt; text removeEmptyBlocks := fun options blocks -\u0026gt; blocks |\u0026gt; List.filter (fun b -\u0026gt; (extract b).TrimNl().Trim() \u0026lt;\u0026gt; \u0026#34;\u0026#34;) ###Merge blocks\nConsecutive blocks of the same kind need to be merged, for the sake of formatting the overall text correctly.\nTODO: make tail recursive\nlet rec mergeBlockList = function | [] -\u0026gt; [] | [a] -\u0026gt; [a] | h1::h2::t -\u0026gt; match h1, h2 with | Code(t1), Code(t2) -\u0026gt; mergeBlockList (Code(t1 + NL + t2)::t) | Narrative(n1), Narrative(n2) -\u0026gt; mergeBlockList(Narrative(n1 + NL + n2)::t) | _, _ -\u0026gt; h1::mergeBlockList(h2::t) mergeBlocks := fun options blocks -\u0026gt; mergeBlockList blocks ###Adding code tags\nEach code block needs a tag at the start and one at the end or it needs to be indented by N chars.\nlet indent n (s:string) = let pad = String.replicate n \u0026#34;\u0026#34; pad + s.Replace(NL, NL + pad) addCodeTags := fun options blocks -\u0026gt; match options.codeSymbols with | Indent(n) -\u0026gt; blocks |\u0026gt; List.map (function Narrative(s) as nar -\u0026gt; nar | Code(s) -\u0026gt; Code(indent n s)) | Surrounded(s, e) -\u0026gt; blocks |\u0026gt; List.map (function | Narrative(text) -\u0026gt; Narrative(NL + text.TrimNl() + NL) | Code(text) -\u0026gt; Code(NL + s + NL + text.TrimNl() + NL + e + NL)) ###Flatten again\nOnce we have the array of blocks, we need to flatten them (transform them in a single string), which is trivial, and then finally implement our original translate function.\nlet sumBlock s b2 = s + extract b2 let flattenB blocks = (blocks |\u0026gt; List.fold sumBlock \u0026#34;\u0026#34;).TrimStart(newLines) translate := fun options text -\u0026gt; text |\u0026gt; !blockize options |\u0026gt; processPhases options |\u0026gt; flattenB Parsing command line arguments Parsing command lines involves writing a function that goes from a sequence of strings to an input file name, output file name and Options record\nlet parseCommandLine = declare\u0026lt;string array -\u0026gt; string * string * Options\u0026gt; To implement it, we are going to use a command line parser taken from here. The parseArgs function takes a sequence of argument values and map them into a (name,value) tuple. It scans the tuple sequence and put command name into all subsequent tuples without name and discard the initial (\u0026quot;\u0026quot;,\u0026quot;\u0026quot;) tuple. It then groups tuples by name and converts the tuple sequence into a map of (name,value seq)\nFor now, I don\u0026rsquo;t need the \u0026lsquo;value seq\u0026rsquo; part as all my parameters take a single argument, but I left it in there in case I will need to pass multiple args later on.\nopen System.Text.RegularExpressions let (|Command|_|) (s:string) = let r = new Regex(@\u0026#34;^(?:-{1,2}|\\/)(?\u0026lt;command\u0026gt;\\w+)[=:]*(?\u0026lt;value\u0026gt;.*)$\u0026#34;,RegexOptions.IgnoreCase) let m = r.Match(s) if m.Success then Some(m.Groups.[\u0026#34;command\u0026#34;].Value.ToLower(), m.Groups.[\u0026#34;value\u0026#34;].Value) else None let parseArgs (args:string seq) = args |\u0026gt; Seq.map (fun i -\u0026gt; match i with | Command (n,v) -\u0026gt; (n,v) // command  | _ -\u0026gt; (\u0026#34;\u0026#34;,i) // data  ) |\u0026gt; Seq.scan (fun (sn,_) (n,v) -\u0026gt; if n.Length\u0026gt;0 then (n,v) else (sn,v)) (\u0026#34;\u0026#34;,\u0026#34;\u0026#34;) |\u0026gt; Seq.skip 1 |\u0026gt; Seq.groupBy (fun (n,_) -\u0026gt; n) |\u0026gt; Seq.map (fun (n,s) -\u0026gt; (n, s |\u0026gt; Seq.map (fun (_,v) -\u0026gt; v) |\u0026gt; Seq.filter (fun i -\u0026gt; i.Length\u0026gt;0))) |\u0026gt; Map.ofSeq let paramRetrieve (m:Map\u0026lt;string,_\u0026gt;) (p:string) = if Map.containsKey p m then Some(m.[p]) else None This is the main logic of parameter passing. Note that we give precedence to the -l and -indent parameters, if present.\nThis is a function that goes from the map of command line parameters to the input file name, output file name and options. With that we can finally define the original parseCommandLine.\nlet safeHead errMsg s = if s |\u0026gt; Seq.isEmpty then failwith errMsg else s |\u0026gt; Seq.head let paramsToInputs paramsMap = let single p er = match paramRetrieve paramsMap p with | Some(k) -\u0026gt; Some(k |\u0026gt; safeHead er) | None -\u0026gt; None let get p s = match paramRetrieve paramsMap p with |Some(k) -\u0026gt; k |\u0026gt; safeHead s | None -\u0026gt; failwith s let defaultP p q er = match paramRetrieve paramsMap p with | Some(k) -\u0026gt; k |\u0026gt; safeHead er | None -\u0026gt; q let inputFile = get \u0026#34;\u0026#34; \u0026#34;You need to pass an input file\u0026#34; let outputFile = defaultP \u0026#34;o\u0026#34; (System.IO.Path.GetFileNameWithoutExtension(inputFile:string) + \u0026#34;.mkd\u0026#34;) \u0026#34;You must pass a parameter to -o\u0026#34; let no, nc = match single \u0026#34;l\u0026#34; \u0026#34;You must pass a language parameter to -l\u0026#34; with | Some(l) -\u0026gt; getLangNoNC l | None -\u0026gt; get \u0026#34;no\u0026#34; \u0026#34;The no (narrative open) parameter is mandatory, if no -l specified\u0026#34;, get \u0026#34;nc\u0026#34; \u0026#34;The nc (narrative close) parameter is mandatory, if no -l specified\u0026#34; let codeSymbs = match single \u0026#34;indent\u0026#34; \u0026#34;You must pass a whitespace indentation number to -indent\u0026#34; with | Some(n) -\u0026gt; let success, value = System.Int32.TryParse n if success then Indent(value) else failwith \u0026#34;-i accepts just an integer value as parameter\u0026#34; | None -\u0026gt; match single \u0026#34;l\u0026#34; \u0026#34;You must pass a language parameter to -l\u0026#34; with | Some(l) -\u0026gt; Surrounded(\u0026#34;~~~\u0026#34; + l,\u0026#34;~~~\u0026#34;) | None -\u0026gt; Surrounded( get \u0026#34;co\u0026#34; \u0026#34;The co (code open) parameter is mandatory, if no -indent specified\u0026#34;, get \u0026#34;cc\u0026#34; \u0026#34;The cc (code close) parameter is mandatory\u0026#34;) inputFile, outputFile, { startNarrative = no endNarrative = nc codeSymbols = codeSymbs } parseCommandLine := parseArgs \u0026gt;\u0026gt; paramsToInputs Main method We can then write main as the only side effect function in the program. Here is where the IO monad would live \u0026hellip;\nlet banner = \u0026#34;LLite : language friendly literate programming\\n\u0026#34; let printMemory () = let bytesInMeg = 1048576. let peak = System.Diagnostics.Process.GetCurrentProcess().PeakWorkingSet64 let work = System.Diagnostics.Process.GetCurrentProcess().WorkingSet64 printfn \u0026#34;Peak working set: %A\u0026#34; ((float) peak / bytesInMeg) printfn \u0026#34;Working set: %A\u0026#34; ((float) peak / bytesInMeg) let myMain args = try let inputFile, outputFile, options = !parseCommandLine args let input = System.IO.File.ReadAllText inputFile let output = !translate options input System.IO.File.WriteAllText (outputFile, output) //printMemory ()  0 with | e -\u0026gt; printfn \u0026#34;%s\u0026#34; \u0026#34;Failure\u0026#34; printfn \u0026#34;%s\u0026#34; e.Message printfn \u0026#34;%s\u0026#34; usage #if DEBUG printfn \u0026#34;\\nDetailed Error Below:\\n%A\u0026#34; e #endif -1 An aside: forward declaring functions in F# A simple solution You can achieve something somehow similar to forward declaration by the \u0026lsquo;declare \u0026lsquo;dirty trick used in this program. Whenever you want to do a forward declaration of a function , or variable, you can type:\nlet testDeclare() = let add = declare\u0026lt;float -\u0026gt; float\u0026gt; let ``function where I want to use add without having defined it`` nums = nums |\u0026gt; Seq.map !add This creates a ref to a function from float to float. It looks a bit like an Haskell type declaration. You can then use such function as if it were actually define and delay his definition to a later point in time when you are ready to explain it.\nWhen you are ready to talk about it, you can then define it with:\nadd := fun x -\u0026gt; x + 1. The syntax is not too bad. You get that often-sought Haskell like explicit type declaration and you can regex the codebase to create an index at the end of the program (maybe).\nBut is it too slow? After all, there is one more indirection call for each function call.\nLet\u0026rsquo;s test it: enable #time in F# interactive and execute timeNormalF and timeIndirectF varying sleepTime and howManyIter until you convince yourself that it is ok (or not).\nlet sleepTime = 50 let howManyIter = 100 let normalF x = System.Threading.Thread.Sleep sleepTime let indirectF = declare\u0026lt;int -\u0026gt; unit\u0026gt; indirectF := fun x -\u0026gt; System.Threading.Thread.Sleep sleepTime let timeNormalF = [1..howManyIter] |\u0026gt; List.iter normalF let timeIndirectF = [1..howManyIter] |\u0026gt; List.iter !indirectF () A correct solution (but ugly) Unfortunately, there is a big problem with all of the above: it doesn\u0026rsquo;t work with generic functions and curried function invocations. The code below works in all cases, but it is ugly for the user to use. In this program I\u0026rsquo;ve used the beautiful, but incorrect, syntax.\ntype Literate() = static member Declare\u0026lt;\u0026#39;a, \u0026#39;b\u0026gt; (ref : obj ref) (x : \u0026#39;a) : \u0026#39;b = unbox \u0026lt;| (unbox\u0026lt;obj -\u0026gt; obj\u0026gt; !ref) x static member Define\u0026lt;\u0026#39;a, \u0026#39;b\u0026gt; (func : \u0026#39;a -\u0026gt; \u0026#39;b) (ref : obj ref) (f : \u0026#39;a -\u0026gt; \u0026#39;b) = ref := box (unbox\u0026lt;\u0026#39;a\u0026gt; \u0026gt;\u0026gt; f \u0026gt;\u0026gt; box) // Declaration let rec id (x : \u0026#39;a) : \u0026#39;a = Literate.Declare idImpl x and idImpl = ref null // Usage let f () = id 100 + id 200 // Definition Literate.Define id idImpl (fun x -\u0026gt; x) The traditional way The traditional way of doing something like this is by passing the function as a parameter in a manner similar to the below.\n// Declaration and usage intermingled let calculate\u0026#39; (add: int -\u0026gt; int -\u0026gt; int) x y = add x y * add x y // Definition let add x y = x + y let calculate = calculate\u0026#39; add To my way of seeing, this is the most cumbersome solution and conceptually dishonest because you are not parametrizing your function for technical reasons, but just for the sake of explaining things. In a way, you are changing the signature of your functions for the sake of writing a book. That can\u0026rsquo;t be right \u0026hellip;\n[\u0026lt;EntryPoint\u0026gt;] let main args = myMain args ","permalink":"https://peaceiris.com/MyBlog/posts/2012-12-14-llite-language-friendly-literate-programming/","tags":["C","fsharp","Literate programming"],"title":"LLite : language friendly literate programming"},{"categories":["fsharp"],"contents":"The Critical monad is defined as follows. First there is the type that propagates through the monad:\ntype Result\u0026lt;'a, 'b\u0026gt; = | Success of 'a | Failure of 'b Then we define the usual computation expression methods.\ntype Critical() = // a -\u0026gt; m a member o.Return x = Success x // m a -\u0026gt; (a -\u0026gt; m b) -\u0026gt; m b member o.Bind (m, f) = match m with | Failure e -\u0026gt; Failure e | Success x -\u0026gt; f x // m a -\u0026gt; m a member o.ReturnFrom m = m Explaining how computational expressions work in F# is a blog onto itself. And several chapters in many books. Sufficient to say that conceptually this propagates the success value and returns the failure value.\nWe then define an instance of this type, so that we can use the nice ‘critical { … }’ syntax.\nlet critical = Critical()  We then go and define the functions that the user needs to use to annotate their function calls. The simplest one is the one to propagate any exception coming from the function ‘f’.\nlet fault f = f  Then it comes the one to manage contingencies. This will trap any exception for which ‘stopF ex’ is ‘true’, call ‘errF ex’ to construct the error return value and wrap it in a ‘Failure’. Otherwise it will rethrow the exception.\nlet contingentGen stopF errF f = try Success(f ()) with | ex when stopF ex -\u0026gt; Failure(errF ex) | _ -\u0026gt; reraise ()  Albeit very simple, the above is the core of the system. Everything else is just details. Let’s look at them.\nFirst we want a function that takes as parameter a list of (Exception, ReturnValue) and gives back the correct stopF errF to plug into ‘contingentGen’.\nlet exceptionMapToFuncs exMap = let tryFind ex = exMap |\u0026gt; List.tryFind (fun (k, _) -\u0026gt; k.GetType() = ex.GetType()) (fun ex -\u0026gt; let found = tryFind ex match found with Some(_) -\u0026gt; true | None -\u0026gt; false), (fun ex -\u0026gt; let found = tryFind ex match found with | Some(k, v) -\u0026gt; v ex | None -\u0026gt; raise ex)  Then ugliness comes. For the sake of getting a decent syntax (not great) on the calling site, we need to fake overloading of functions by the old trick of adding a number at the end. Thanks to Tobias to point out this (my api was even worse earlier).\nI often wondered about the trade-off between currying and overloading for functions. I seem to always paint myself in a situation where I need overloading. In any case, here it goes:\nlet contingent1 exMap f x = let stopF, errF = exceptionMapToFuncs exMap contingentGen stopF errF (fun _ -\u0026gt; f x) let contingent2 exMap f x y = let stopF, errF = exceptionMapToFuncs exMap contingentGen stopF errF (fun _ -\u0026gt; f x y) let contingent3 exMap f x y z = let stopF, errF = exceptionMapToFuncs exMap contingentGen stopF errF (fun _ -\u0026gt; f x y z)  Sometimes you want to trap all exceptions from a function and return your own error value:\nlet neverThrow1 exc f x = contingentGen (fun _ -\u0026gt; true) (fun ex -\u0026gt; exc ex) (fun _ -\u0026gt; f x) let neverThrow2 exc f x y = contingentGen (fun _ -\u0026gt; true) (fun ex -\u0026gt; exc ex) (fun _ -\u0026gt; f x y) let neverThrow3 exc f x y z = contingentGen (fun _ -\u0026gt; true) (fun ex -\u0026gt; exc ex) (fun _ -\u0026gt; f x y z)  Other times you need to go from a function that returns return values to one that throws exceptions. You need translating from contingencies to faults:\nlet alwaysThrow exc f x = match f x with | Success(ret) -\u0026gt; ret | Failure(e) -\u0026gt; raise (exc e)  And that’s it. Hopefully we have bridged the gap between exceptions and return values without making the code too ugly (just a little bit). Or perhaps not.\nI need to add that I haven’t used this library myself (yet). I’m sure when I do I’ll discover many things to change.\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-12-07-exceptions-vs-return-values-to-represent-errors-in-f-iii-implementation/","tags":["fsharp"],"title":"Exceptions vs. Return Values to represent errors (in F#) – IV – Implementation"},{"categories":["fsharp"],"contents":"Code for this post is here.\nIn the last post we looked at some Critical code and decided that, albeit correct, it is convoluted. The error management path obfuscates the underlying logic. Also we have no way of knowing if a developer had thought about the error path or not when invoking a function.\nLet’s tackle the latter concern first as it is easier. We want the developer to declaratively tag each method call with something that represents his intent about managing the Contingencies or Faults of the function. Moreover if the function has contingencies, we want to force the developer to manage them explicitly.\nWe cannot use attributes for this as function calls happen in the middle of the code, so there is no place to stick attributes into. So we are going to use higher level functions to wrap the function calls.\nThe first case is easy. If the developer thinks that the caller of his code has no way to recover from all the exceptions thrown by a function, he can prepend his function call with the ‘fault’ word as in:\nfault parseUser userText That signals readers of the code that the developer is willing to propagate up all the exceptions thrown by the function parseUser. Embarrassingly, ‘fault’ is implemented as:\nlet fault f = f  So it is just a tag. Things get trickier when the function has contingencies. We want to find a way to manage them without introducing undue complexity in the code.\nWe’d like to catch some exceptions thrown by the function and convert them to return values and then either return such return values or manage the contingency immediately after the function call. On top of that, we’d want all of the code written after the function call to appear as clean as if no error management were taking place. Monads (computation values) can be used to achieve these goals.\nLast time we introduced a type to represent error return values:\ntype Result\u0026lt;'a, 'b\u0026gt; = | Success of 'a | Failure of 'b  type UserFetchError = | UserNotFound of exn | NotAuthorized of int * exn  We can then create a computation expression that ‘abstracts out’ the Failure case and let you write the code as cleanly as if you were not handling errors. Let’s call such thing ‘critical’. Here is how the final code looks like:\nlet tryFetchUser3 userName = if String.IsNullOrEmpty userName then invalidArg \"userName\" \"userName cannot be null/empty\" critical { let Unauthorized (ex:exn) = NotAuthorized (ex.Message.Length, ex)let! userText = contingent1 [FileNotFoundException() :\u0026gt; exn, UserNotFound; UnauthorizedAccessException() :\u0026gt; exn, Unauthorized] dbQuery (userName + \".user\") return fault parseUser userText } You can compare this with the code you would have to write without the ‘critical’ library (from last post):\nlet tryFetchUser1 userName = if String.IsNullOrEmpty userName then invalidArg \"userName\" \"userName cannot be null/empty\" // Could check for file existence in this case, but often not (i.e. db) let userResult = try Success(dbQuery(userName + \".user\")) with | FileNotFoundException as ex -\u0026gt; Failure(UserNotFound ex) | UnauthorizedAccessException as ex -\u0026gt; Failure(NotAuthorized(2, ex)) | ex -\u0026gt; reraise () match userResult with | Success(userText) -\u0026gt; let user = Success(parseUser(userText)) user | Failure(ex) -\u0026gt; Failure(ex)  And with the original (not critical) function:\nlet fetchUser userName = let userText = dbQuery (userName + \".user\") let user = parseUser(userText) user  \nLet’s go step by step and see how it works. First of all, you need to enclose the Critical parts of your code (perhaps your whole program) in a ‘critical’ computation:\ncritical {\n… }  This allows you to call functions that return a Result and manage the return result as if it were the successful result. If an error were generated, it would be returned instead. We will show how to manage contingencies immediately after the function call later.\nThe above is illustrated by the following:\nlet! userText = contingent1 [FileNotFoundException() :\u0026gt; exn, UserNotFound; UnauthorizedAccessException() :\u0026gt; exn, Unauthorized] dbQuery (userName + \".user\") Here ‘contingent1’ is a function that returns a Result, but userText has type string. The Critical monad, and in particular the usage of ‘let!’ is what allows the magic to happen.\n‘contingentN’ is a function that you call when you want to manage certain exceptions thrown by a function as contingencies. The N part represents how many parameters the function takes.\nThe first parameter to ‘contingent1’ is a list of pairs (Exception, ErrorReturnConstructor). That means: when an exception of type Exception is thrown, return the result of calling ‘ErrorReturnConstructor(Exception)’ wrapped inside a ‘Failure’ object. The second parameter to ‘contingent1’ is the function to invoke and the third is the argument to pass to it.\nConceptually, ‘ContingentN’ is a tag that says: if the function throws one of these exceptions, wrap them in these return values and propagate all the other exceptions. Notice that Unauthorized takes an integer and an exception as parameters while the ErrorReturnConstructor takes just an exception. So we need to add this line of code:\nlet Unauthorized (ex:exn) = NotAuthorized (ex.Message.Length, ex)  After the contingent1 call, we can then write code as if the function returned a normal string:\nreturn fault parseUser userText  This achieves that we set up to do at the start of the series:\n Contingencies are now explicit in the signature of tryFetchUser3 The developer needs to indicate for each function call how he intend to manage contingencies and faults The code is only slightly more complex than the non-critical one  You can also decide to manage your contingencies immediately after calling a function. Perhaps there is a way to recover from the problem. For example, if the user is not in the database, you might want to add a standard one:\nlet createAndReturnUser userName = critical { return {Name = userName; Age = 43}}\n\u0026lt;/fontlet \u0026lt;/spantryFetchUser4 userName = if String.IsNullOrEmpty userName then invalidArg \"userName\" \"userName cannot be null/empty\" critical { let Unauthorized (ex:exn) = NotAuthorized (ex.Message.Length, ex) // depends on ex let userFound = contingent1 [FileNotFoundException() :\u0026gt; exn, UserNotFound; UnauthorizedAccessException() :\u0026gt; exn, Unauthorized] dbQuery (userName + \".user\") match userFound with | Success(userText) -\u0026gt; return fault parseUser userText | Failure(UserNotFound(_)) -\u0026gt; return! createAndReturnUser(userName) | Failure(x) -\u0026gt; return! Failure(x) }  The only difference in this case is the usage of ‘let’ instead of ‘let!’. This exposes the real return type of the function allowing you to pattern match against it.  Sometimes a simple exception to return value mapping might not be enough and you want more control on which exceptions to catch and how to convert them to return values. In such cases you can use contingentGen: let tryFetchUser2 userName = if String.IsNullOrEmpty userName then invalidArg \"userName\" \"userName cannot be null/empty\" critical { let! userText = contingentGen (fun ex -\u0026gt; ex FileNotFoundException || ex UnauthorizedAccessException) (fun ex -\u0026gt; match ex with | FileNotFoundException -\u0026gt; UserNotFound(ex) | UnauthorizedAccessException -\u0026gt; NotAuthorized(3, ex) | _ -\u0026gt; raise ex) (fun _ -\u0026gt; dbQuery (userName + \".user\")) return fault parseUser userText }   The first parameter is a lambda describing when to catch an exception. The second lambda translate between exceptions and return values. The third lambda represents which function to call.  Sometimes you might want to catch all the exceptions that a function might throw and convert them to a single return value: type GenericError = GenericError of exn // 1. Wrapper that prevents exceptions for escaping the method by wrapping them in a generic critical result let tryFetchUserNoThrow userName = if String.IsNullOrEmpty userName then invalidArg \"userName\" \"userName cannot be null/empty\" critical { let! userText = neverThrow1 GenericError dbQuery (userName + \".user\") return fault parseUser userText }  And sometimes you might want to go the opposite way. Given a function that exposes some contingencies, you want to translate them to faults because you don’t know how to recover from them. let operateOnExistingUser userName = let user = alwaysThrow GenericException tryFetchUserNoThrow userName ()  Next time we’ll look at how the Critical computation expression is implemented. ","permalink":"https://peaceiris.com/MyBlog/posts/2012-11-30-exceptions-vs-return-values-to-represent-errors-in-f-iiithe-critical-monad/","tags":["fsharp"],"title":"Exceptions vs. Return Values to represent errors (in F#) – III–The Critical monad"},{"categories":["fsharp"],"contents":"In the previous post, we talked about the difference between Critical and Normal code. In this post we are going to talk about the Critical code part. Ideally, we want:\n A way to indicate that a particular piece of code (potentially the whole program) is Critical A way to force/encourage the programmer to make an explicit decision on the call site of a function on how he wants to manage the error conditions (both contingencies and faults) A way to force/encourage the programmer to expose contingencies/faults that are appropriate for the conceptual level of the function the code is in (aka don’t expose implementation details for the function, i.e. don’t throw SQLException from a getUser method where the caller is supposed to catch it)  Remember that I can use the word ‘force’ here because the programmer has already taken the decision to analyse each line of code for error conditions. As we discussed in the previous post, In many/most cases, such level of scrutiny is unwarranted.\nLet’s use the below scenario to unravel the design:\ntype User = {Name:string; Age:int} let fetchUser userName = let userText = dbQuery (userName + \".user\") let user = parseUser(userText) user This looks like a very reasonable .NET function and it is indeed reasonable in Normal code, but not in Critical code. Note that the caller likely needs to handle the user-not-in-repository case because there is no way for the caller to check such condition beforehand without incurring the performance cost of two network roundtrips.\nAlbeit the beauty and simplicity, there are issues with this function in a Critical context:\n The function throws implementation related exceptions, breaking encapsulation when the user needs to catch them It is not clear from the code if the developer thought about error management (do you think he did?) Preconditions are not checked, what about empty or null strings?  To test our design let’s define a fake dbQuery:\nlet dbQuery = function | \"parseError.user\" -\u0026gt; \"parseError\" | \"notFound.user\" -\u0026gt; raise (FileNotFoundException()) | \"notAuthorized.user\" -\u0026gt; raise (UnauthorizedAccessException()) | \"unknown.user\" -\u0026gt; failwith \"Unknown error reading the file\" | _ -\u0026gt; \"FoundUser\" The first two exceptions are contingencies, the caller of fetchUser is supposed to manage them. The unknown.user exception is a fault in the implementation. parseError triggers a problem in the parseUser function.\nParseUser looks like this:\nlet parseUser = function | \"parseError\" -\u0026gt; failwith \"Error parsing the user text\" | u -\u0026gt; {Name = u; Age = 43}  Let’s now create a test function to test the different versions of fetchUser that we are going to create:\nlet test fetchUser = let p x = try printfn \"%A\" (fetchUser x) with ex -\u0026gt; printfn \"%A %s\" (ex.GetType()) ex.Message p \"found\" p \"notFound\" p \"notAuthorized\" p \"parseError\" p \"unknown\" Running the function exposes the problems described above. From the point of view of the caller, there is no way to know what to expect by just inspecting the signature of the function. There is no differentiation between contingencies and faults. The only way to achieve that is to catch some implementation-specific exceptions.\nHow would we translate this to Critical code?\nFirst, we would define a type to represent the result of a function:\ntype Result\u0026lt;'a, 'b\u0026gt; = | Success of 'a | Failure of 'b  This is called the Either type, but the names have been customized to represent this scenario. We then need to define which kind of contingencies our function could return.\ntype UserFetchError = | UserNotFound of exn | NotAuthorized of int * exn So we assume that the caller can manage the fact that the user is not found or not authorized. This type contains an Exception member. This is useful in cases where the caller doesn’t want to manage a contingency, but wants to treat it like a fault (for example when some Normal code is calling some Critical code).\nIn such cases, we don’t lose important debugging information. But we still don’t break encapsulation because the caller is not supposed to ‘catch’ a fault.\nNotice that NotAuthorized contains an int member. This is to show that contingencies can carry some more information than just their type. For example, a caller could match on both the type and the additional data.\nWith that in place, let’s see how the previous function looks like:\nlet tryFetchUser1 userName = if String.IsNullOrEmpty userName then invalidArg \"userName\" \"userName cannot be null/empty\" // Could check for file existence in this case, but often not (i.e. db) let userResult = try Success(dbQuery(userName + \".user\")) with | FileNotFoundException as ex -\u0026gt; Failure(UserNotFound ex) | UnauthorizedAccessException as ex -\u0026gt; Failure(NotAuthorized(2, ex)) | ex -\u0026gt; reraise () match userResult with | Success(userText) -\u0026gt; let user = Success(parseUser(userText)) user | Failure(ex) -\u0026gt; Failure(ex) Here is what changed:\n Changed name to tryXXX to convey the fact that the method has contingencies Added precondition test, which generates a fault The signature of the function now conveys the contingencies that the user is supposed to know about  But still, there are problems:\n The code became very long and convoluted obfuscating the success code path Still, has the developer thought about the error conditions in parseUser and decided to let exceptions get out, or did she forget about it?  The return value crowd at this point is going to shout: “Get over it!! Your code doesn’t need to be elegant, it needs to be correct!”. But I disagree, obfuscating the success code path is a problem because it becomes harder to figure out if your business logic is correct. It is harder to know if you solved the problem you set out to solve in the first place.\nIn the next post we’ll see what we can do about keeping beauty and being correct.\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-11-23-exceptions-vs-return-values-to-represent-errors-in-f-iithe-critical-monad/","tags":["fsharp"],"title":"Exceptions vs. Return Values to represent errors (in F#) – II– An example problem"},{"categories":["fsharp"],"contents":"Recently I’ve been reading numerous articles on the age old question of exceptions vs. return values. There is a vast literature on the topic with very passionate opinions on one side or the other. Below is my view on it.\nFirst of all, I’ll define my terms.\n Success code path: chunk of code that is responsible to perform the main task of a function, without any regard for error conditions Contingency: an event that happens during the success code path execution that is of interest for the caller of the function.  It happens rarely It can be described in terms that the caller understands, it doesn’t refer to the implementation of the function The caller stands a chance to recover from it   Fault: an event that happens during the success code path execution that is not expected by the caller of the function.  It happens rarely It cannot be described in terms that the caller understands, it requires reference to the implementation of the function The caller has no way to recover from it    Examples of the above for a FetchUser(userName) function:\n Success code path: the code that retrieves the user from the database Contingency: the fact that the requested user is not in the database Fault: userName = null, divide by zero, stack overflow, …  The difference between Contingency and Fault is not sharp in practice and requires common sense, but it is useful none less. When in doubt, it would appear prudent to consider an event as a Contingency, so that the caller gets a chance to recover.\nIdeally, you would like a Contingency to be part of the signature of a function, so that the caller knows about it. On the other end, a Fault shouldn’t be part of the signature of a function for two reasons:\n The user cannot recover from it Being part of the signature would break encapsulation by exposing implementation details of the function  The above seems to suggest that Contingencies should be represented as return values and Faults as exceptions. As an aside, in Java the former is represented as checked exceptions, which is part of the signature. We’ll tackle checked exceptions later on.\nAn important point that is often neglected in the discussions on this topic is that there are two categories of applications: applications that care about Contingencies (Critical apps) and applications that don’t (Normal apps). I am of the opinion that the latter category is the largest.\nIn many cases you can indeed write just the success code path and, if anything goes wrong, you just clean up after yourself and exit. That is a perfectly reasonable thing to do for very many applications. You are trading off speed of development with stability. Your application can be anywhere on that continuum.\nExamples of Normal apps are: build scripts, utility applications, departmental applications where you can fix things quickly on the user machine, intranet web sites, internet web sites that are purely informative, etc …\nExamples of Critical apps are: servers, databases, operating systems, web site that sell stuff, etc …\nFor Normal apps, treating Contingencies as Fault is the right thing to do. You just slap a try … catch around your event loop/ thread/ process and you do your best to get the developer to fix the problem quickly. I think a lot of the angst of the ‘return value crowd’ is predicated on not having this distinction in mind. They are making very valid point regarding Critical apps to a crowd that is thinking about Normal apps. So the two sides are cross-talking.\nAlso, in my opinion, the main problem with Java checked exceptions is that they make writing Normal apps as cumbersome as writing Critical apps. So, reasonably, people complain.\nThe .NET framework decided to use Exceptions as the main way to convey both Faults and Contingencies. By doing so, it makes it easier to write Normal apps, but more difficult to write Critical apps.\nFor a Critical app or section of code, you’d want to:\n Express contingencies in the function signature Force/Encourage people to take an explicit decision at the calling site on how they want to manage both Contingencies and Faults for each function call  In the next post, let’s see how we can represent some of this in F#.\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-11-19-exceptions-vs-return-values-to-represent-errors-in-f-i-conceptual-view/","tags":["fsharp"],"title":"Exceptions vs. Return Values to represent errors (in F#) – Conceptual view"},{"categories":["ASP.Net Web APIs","fsharp","Type Providers"],"contents":"For a good introduction on how to use Web APIs in F#, read here. The starting point for type providers is here. This post is about how I solved a practical problem using these technologies.\nFirst, let’s discuss the scenario. In my company, we needed to log usage information for our various applications to a central repository and build a web site to access such information. I went through three different architectures for such a requirement, ending with the set of technologies described in the title.\nI found the intersection of the SQL type provider with the ASP.NET Web Api to be very sweet. Personally, I think this mix is much better than using the WFC Data Services, because the code you have to write and the infrastructure to maintain is significantly less.\nI suspect that the F# team and ASP.Net team didn’t talk to each other. It all happens because of a well defined interface (IQueryable) that both teams happen to work against.\n1st version, heavy Javascript   SQL Server Express backend  WFC Data Services middle tier in C# (autogenerated REST service from a table, you can query from the JS code)  Plenty of Javascript in the browser, calling back to the REST web services through Ajax  Here is an example of the kind of manipulation done in the JS layer:\nfunction extractVersions(sessions) { var versions = {} $.each(sessions, function (i, s) { if (typeof versions[s.Version] == \u0026#39;undefined\u0026#39;) { versions[s.Version] = 0 } else { versions[s.Version] = versions[s.Version] + 1 } }) var vs = [] for (var prop in versions) { if (versions.hasOwnProperty(prop)) vs.push({ Version: prop, Sessions: versions[prop] }) } return vs; } Pros:\n  Back-end autogenerated  I’ve learned JS pretty well  Cons:\n  Plenty of autogenerated code (crap) to debug into when things go wrong  Difficult to customize the back-end  Somehow slow, even if today’s JS engines are pretty good  More time consuming to create and maintain JS code (compared to F# or C#)  Aesthetically unsatisfying, as you really would like to do most manipulations on the server   2nd version, SOAP like web services   SQL Server Express backend  SOAP like web services middle tier in C# (coded by hand), still using the WCF Data Services infrastructure  Little Javascript in the browser exclusively for presentation, calling back to the REST web services through Ajax  Here is how one of the web services would look like: [WebGet] public IEnumerable\u0026lt;VersionSessions\u0026gt; GetVersionsForMonth(string application, bool isQS, bool isAD) { var sessions = GetSessionsForMonth(application, isQS, isAD); var hash = new Dictionary\u0026lt;string, VersionSessions\u0026gt;(); foreach (var s in sessions) { VersionSessions vs; var found = hash.TryGetValue(s.Version, out vs); if (!found) hash[s.Version] = new VersionSessions { Version = s.Version, Sessions = 0 }; else vs.Sessions += 1; } return hash.Values; }  Pros:\n  Maintainable business logic code (C# instead of JS)  Somehow faster  Easier to customize the back-end (just add another web service with the signature you want)  Cons:\n  Still plenty of manipulation code (at least now on the back-end), not very RESTy  Feels that the webservice are very ad-hoc for this particular presentation (i.e. a ViewModel, not a model)  Still not trivial to customize the back-end logic, mostly because I was using WCF Data Services, which are opaque   3rd version, using SQL Views and F# type providers   Moved the whole app to a dedicated VM  SQL Server backend with a significant layer of Views and inline table-value functions  Proper REST web services created through ASP.NET Web API and F# type providers  Little Javascript in the browser exclusively for presentation, calling back to the REST web services through Ajax  Moved all external ‘reference file’ (i.e. people in QS) to the DB. Before I was keeping business info in the database and config info in files.   Here is an example of an inline table value function:\n ALTER FUNCTION [dbo].[FUsers] (@App nvarchar(40)) RETURNS TABLE AS RETURN ( SELECT UserAlias, MAX(Application) AS Application, MAX(Start) AS LastSessionStart, MAX(Finish) AS LastSessionFinish, DATEDIFF(MINUTE, MAX(Start), MAX(Finish)) AS LastSessionTotalTime, COUNT(*) AS Sessions, MAX(Machine) AS Machine, MAX(Version) AS Version, MAX(Qs) AS Qs FROM dbo.VTotalSessions AS s WHERE (TotalTime \u0026gt; 30) and (Application = @App) GROUP BY UserAlias)  And here is an example of a type provider based web service. Most of my code works like this:\n type usersController() = inherit ApiController() let db = dbSchema.GetDataContext() member x.Get() = query { for u in db.VUsers do select u } member x.Get(app) = query { for u in db.FUsers(app) do select u } member x.Post (value:string) = () member x.Put (id:int) (value:string) = () member x.Delete (id:int) = ()  Here is how a query is represented in JS (the whole query gets passed through to SQL, both the JS part and the F# part, IQueryable magick):\n function loadOpenSessions(app, qs, cont) { var query = new oQuery() .From(\u0026#34;/users/\u0026#34; + app) .Let(\u0026#34;lastMonth\u0026#34;, lastMonth) .Let(\u0026#34;twoMinutesAgo\u0026#34;, twoMinutesAgo) .Where(\u0026#34;item =\u0026gt; item.LastSessionFinish \u0026gt; $twoMinutesAgo\u0026#34;) .Orderby(\u0026#34;UserAlias\u0026#34;) commonCall(query, qs, cont) }  Pros:\n  Purely functional business logic code (SQL), very easy to debug problems by just running the query/view  Maximum usage of SQL Server optimizer. As they say in the SQL Engine Team: “we’ve spent decades optimizing sql query engines. You are unlikely to do better with your ‘for’ loops …”  Very easy to customize the back-end, just write F# code to implement GET/POST/PUT/DELETE etc…  Moving all the state for the app (reference files included) in the DB, makes it much easier to integrate it into the business logic. It all becomes a big query for the optimizer to sort out.  No autogenerated code anywhere in the architecture  More separation between model and viewmodel. Tables are model, Views are ViewModel, F# is just a way to expose such view model to the world at large  Cons:\n  Routing algorithm for ASP.NET Web API is mysterious. It’s the only black box piece in the architecture (aka that I don’t understand it).   Sometimes either SQL is not powerful enough (I abhor Stored procedures on religious grounds) or something doesn’t map well to a REST metaphor. In such cases I have diluted the metaphor as in the code below. The good thing is that, being just code, I can do that. I’m not blocked.  type statsController() = inherit ApiController() let db = dbSchema.GetDataContext() member x.Get(app:string, isQs:string, call:string) = match call with | \u0026#34;WeeklyUsers\u0026#34; -\u0026gt; let sessions = query { for s in db.VTotalSessionsAndWeeks do where (s.Application = app \u0026amp;\u0026amp; s.Qs = Nullable (Int32.Parse(isQs))) select s } weeklyUsers sessions | \u0026#34;WeeklyTime\u0026#34; -\u0026gt; let sessions = query { for s in db.FTotalTime(app, Nullable (Int32.Parse(isQs))) do select s } weeklyTime sessions | \u0026#34;HourlyUsers\u0026#34;-\u0026gt; let users = query { for u in db.FHourlyUsers(app, Nullable (Int32.Parse(isQs))) do select u } hourlyUsers users | _ -\u0026gt; failwith \u0026#34;No call with that name\u0026#34; ","permalink":"https://peaceiris.com/MyBlog/posts/2012-09-04-retrieving-sql-server-data-with-type-providers-and-exposing-it-with-asp-net-web-apis-in-f/","tags":["fsharp"],"title":"Retrieving SQL Server data with type providers and exposing it with ASP.NET Web APIs in F#"},{"categories":["Miscellanea"],"contents":"For those of you interested in C++, Andy Sawyer now has a blog here. Here is an extended discussion on how to choose an STL container. Enjoy !!\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-06-18-and-now-andy-has-a-blog/","tags":null,"title":"And now Andy has a blog …"},{"categories":["C"],"contents":"Just a couple of trivialities and my parting thoughts.\nNested functions If your language has lambdas, you don’t need nested functions support because you can implement them using it.\nI am a heavy user of nested functions, but I’m of two minds about it. On one side, I like that they sit close to where they are used, avoiding going outside the main function body to understand them. I also like that you don’t need to pass a lot of parameters to them, as they capture the function locals. On the other side, they end up creating the impression that your functions are very long and so, in my eyes, they occasionally reduce readability. The IDE helps you out there (at least VS 11) by allowing you to collapse the lambdas.\nAn example of trivial case is below:\nBOOST_AUTO_TEST_CASE(NestedFunctions) { int x = 3; auto sumX = [\u0026] (int y) { return x + y;}; BOOST_CHECK_EQUAL(sumX(2), 3+2); } And here is a more realistic one (not written in a functional style), where readability is reduced by the three nested functions (among many other things):\nbool condor( boost::gregorian::date now, // date to evaluate double spot, // spot price underlying double v, // ATM volatility double r, // risk free rate double step, // % of spot price to keep as distance between wings int minCallShortDist, // min distance from the short call strike in steps int minPutShortDist, // min distance from the short put strike in steps int minDays, // min number of days to expiry int maxDays, // max number of days to expiry double maxDelta, // max acceptable delta value for shorts in steps double minPremium, // min accepted premium as % of step Condor\u0026 ret // return value ) { // convert params to dollar signs auto stepPr = round(step * spot); auto toUSD = [stepPr] (double x) { return round(stepPr * x);}; auto minCpr = toUSD( minCallShortDist ); auto minPpr = toUSD( minPutShortDist ); auto premiumPr = toUSD( minPremium ); // calc strike values for short legs auto atm = round(spot / stepPr) * (long) stepPr; auto callShort = atm + minCpr; auto putShort = atm - minPpr; auto addDays = [](boost::gregorian::date d, int dys) -\u0026gt; boost::gregorian::date { using namespace boost::gregorian; auto toAdd = days(dys); auto dTarget = d + toAdd; return dTarget; }; // calc min \u0026 max allowed expiry dates auto minDate = addDays(now, minDays); auto maxDate = addDays(now, maxDays); auto expiry = calcExpiry(now, 0); // find first good expiry while(expiry \u0026lt; minDate) expiry = calcExpiry(expiry, +1); Greeks g; auto scholes = [=, \u0026g] (double strike, int days, bool CorP) { return blackScholesEuro(spot, strike, days, CorP, v, r, g, true); }; // find a condor that works at this expiry auto findCondor = [=, \u0026g, \u0026ret] (int days) -\u0026gt; bool { ret.shortCallStrike = callShort; ret.shortPutStrike = putShort; auto shCallPremium = 0.0; auto shPutPremium = 0.0; // find short call strike price \u0026lt; maxDelta while(true) { shCallPremium = scholes(ret.shortCallStrike, days, true); if(g.delta \u0026lt;= maxDelta) break; else ret.shortCallStrike += stepPr; } // find short put strike price \u0026lt; maxDelta while(true) { shPutPremium = scholes(ret.shortPutStrike, days, false); if( (- g.delta) \u0026lt;= maxDelta) break; else ret.shortPutStrike -= stepPr; } // check premium is adeguate ret.longCallStrike = ret.shortCallStrike + stepPr; ret.longPutStrike = ret.shortPutStrike - stepPr; auto lgCall = scholes(ret.longCallStrike, days, true); auto lgPut = scholes(ret.longPutStrike, days, false); ret.netPremium = shCallPremium + shPutPremium - lgCall - lgPut; return ret.netPremium \u0026gt; premiumPr; }; // increases the expiry until it finds a condor or the expiry is too far out while (expiry \u0026lt; maxDate) { auto days = (expiry - now).days(); if(findCondor(days)) { ret.year = expiry.year(); ret.month = expiry.month(); ret.day = expiry.day(); return true; } expiry = calcExpiry(expiry, +1); } return false; } \nThat is quite a mouthful, isn’t it? But really the function is not that long. It is all these nested functions that makes it seems so.\nTuples Tuples are another feature toward which I have mixed feelings. They are really useful to return multiple results from a function and for rapid prototyping of concepts. But they are easy to abuse. Creating Records is almost always a better, safer way to craft your code, albeit more verbose.\nThe standard C++ has an excellent tuple library that makes working with them almost as easy as in mainstream functional languages. The below function shows creating them, getting their value, passing them to functions and deconstructing them:\nBOOST_AUTO_TEST_CASE(Tuples) { auto t = make_tuple(\"bob\", \"john\", 3, 2.3); BOOST_CHECK_EQUAL(get\u0026lt;0\u0026gt;(t), \"bob\"); BOOST_CHECK_EQUAL(get\u0026lt;2\u0026gt;(t), 3); // yep, compiler error //auto k = get\u0026lt;10\u0026gt;(t); auto t2(t); BOOST_CHECK(t2 == t); // passing as argument, returning it auto f = [] (tuple\u0026lt;string, string, int, double\u0026gt; t) { return t;}; auto t1 = f(t); BOOST_CHECK(t == t1); // automatic deconstruction string s1; string s2; int i; double d; std::tie(s1, s2, i, d) = f(t); BOOST_CHECK_EQUAL(s1, \"bob\"); // partial reconstruction string s11; std::tie(s11, ignore, ignore, ignore) = f(t); BOOST_CHECK_EQUAL(s11, \"bob\"); } Conclusion I’m sure there are some fundamental functional features that I haven’t touched on (i.e. currying, more powerful function composition, etc…). Despite that, I think we have enough material here to start drawing some conclusions. To start with, where is C++ deficient compared to mainstream functional languages for the sake of writing functional code ?\n Compiler errors: if you make a well natured error, you often get back from the compiler a long page of rubbish if you are using templates (and you are). You put your goggles on and start swimming through it to find the nugget of gold that is the root cause of your problem. I can hear you C++ gurus screaming: come on, come on, it’s not that bad. After a while you get used to it. You become proficient in rubbish swimming. That makes me think of the story of that guy who lived in a strange neighbourhood where, as soon as you open the door of you house, someone kicks you in the nuts. His wife suggested that they moved to a better part of town, but the man replied: “no worries, I got used to it”. Syntax oddity: we did our best to make the gods of syntax happy in this series of articles, but we are still far removed from Haskell, F#, etc beauty… Advanced features: if you go beyond the basics of functional languages, there is a plethora of interesting features that just make your life so much easier and bring your code to an higher level of abstraction. Things like monads (i.e. f# async workflow), type providers, Haskell’s lazy execution, Haskell’s super strong type system, Closure’s transactional memory etc… Boost is trying to bring many of these things to C++, but there is still a big gap to be filled. Temptation to cheat: you can cheat in many functional programming languages (i.e. having mutable variables), but nowhere the temptation is as strong as in C++. You need an iron discipline not to do it. The fact that sometimes cheating is the right thing to do makes it even worse.  Overall, am I going to use C++ now as my main programming language? Not really. I don’t have one of those. My general view is to always use the best language for the job at hand (yes, I even use Javascript for web pages).\nC++ has some unique characteristics (i.e. speed, cross compilation \u0026amp; simple C interfacing). I’m going to use it whenever I need these characteristics, but now I’ll be a happier user knowing that I can write decent functional code in it.\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-06-01-writing-functional-code-in-c-v-miscellaneous-and-conclusions/","tags":["C++","Functional Programming"],"title":"Writing functional code in C++ V – Miscellaneous and conclusions"},{"categories":["C"],"contents":"And here comes the guilt bit. I have the strong suspicion (but not certainty) that what I am doing here can be done with templates, but didn’t take the time to do it. With that out of the way, let’s go.\nCode for this post is here. Thanks to Steve Bower and Andy Sawyer for reviewing it.\nAlgebraic datatypes (discriminated unions in F#) are a powerful concept in functional programming. They are the main way to represent type variation in your program. Very roughly, where object orientation uses derivation, functional programming uses algebraic datatypes. An entire book could be written on the theory of this, but the goal of this post is to see how we can map them to C++ without loosing C++ness.\nWhen talking about this with C++ programmers, they always point me to boost variant. That doesn’t do it for me for several reasons.\nFirst of all, boost variants represent one of a fixed collection of types. Algebraic datatypes represent one of a fixed collection of named types. That means that a simple thing like the code below cannot be represented as variant:\ntype LivingEntity = | Person of string // name | Dog of string // name Ok, ok maybe you could represent it by ‘typifing’ things using boost strong typedef, but things get ugly syntactically. Moreover, a lot of time the name is all you care about …\ntype Switch = On | Off Are we going to strong typedef for such a simple thing? Oh boy. Even accepting the syntactic weight of all this, there are other issues in play. Discriminated unions are used extensively in functional programs. So you want a nice syntax to work with them Something like the below F# syntax:\nlet print living = match living with | Person(name) -\u0026gt; printfn \"I'm a per named %s\" name | Dog(name) -\u0026gt; printfn \"I'm a dog named %s\" name Which could be made even sweeter by using the ‘function’ keyword as below:\nlet print = function | Person(name) -\u0026gt; printfn \"I'm a per named %s\" name | Dog(name) -\u0026gt; printfn \"I'm a dog named %s\" name In boost variant, you either use the get functions or you write a visitor function. In the first case you are probably going to write a chain of ‘if’ statements or a ‘switch’ statement. Both are confusing and come with plenty of syntactic weight. I don’t really want to write a visitor like the one below for each ‘match’ in my code. The magic is gone.\nclass times_two_visitor : public \u0026lt;a href=\"http://www.boost.org/doc/libs/1_49_0/doc/html/boost/static_visitor.html\"boost::static_visitor\u0026lt;/a\u0026lt;\u0026gt; { public: void operator()(int \u0026 i) const { i *= 2; } void operator()(std::string \u0026 str) const { str += str; } }; Ok, so boost variant doesn’t really work for this. Remember that our overarching goal was to stay close to C++. The language itself has something that comes pretty close to what we want in the form of a union, or better a tagged union. Again, the types are not named, but maybe we can work that in.\nIt turns out that Jared here did all the hard work. The general idea is to use macros to hide the construction of a tagged union with methods to test the type and return the contained value.\nFor example this code:\nDU_DECLARE(LivingEntity) DU_VALUE(Person, string) DU_VALUE(Dog, string) DU_END  Becomes something like:\nstruct LivingEntity { private: LivingEntity() {} unsigned int m_kind; public: static LivingEntity Person(const string\u0026 value) { LivingEntity unionValue; unionValue.m_kind = 19; unionValue.m_Person = value; return unionValue; } bool IsPerson() const { return m_kind == 19; } const string\u0026 GetPerson() const { (void)( (!!(m_kind == 19)) || (_wassert(L\"m_kind == __LINE__\", L\"c:discriminated_union.cpp\", 19), 0) ); return m_Person; } string GetPerson() { (void)( (!!(m_kind == 19)) || (_wassert(L\"m_kind == __LINE__\", L\"c:discriminated_union.cpp\", 19), 0) ); return m_Person; } private:\nstring m_Person;\n… You can see the outline of a tagged union (i.e. m_kind) with a constructor for each type (i.e. Person) and methods to test for at type and return its value. You can also see the storage for the value (i.e. m_Person).\nThe only thing in DU_DECLARE that is different from Jared’s solution is the typedef below that allows not repeating the LivingEntity name in each DU_VALUE.\n#define DU_DECLARE(name) \\ struct name { \\ private: \\ typedef name unionName; \\ name() {} \\ unsigned int m_kind; \\ public:  #define DU_VALUE(entryName, entryType) \\ static unionName entryName(const entryType\u0026 value) { \\ unionName unionValue; \\ unionValue.m_kind = __LINE__; \\ unionValue.m_##entryName = value; \\ return unionValue; } \\ bool Is##entryName() const { return m_kind == __LINE__;} \\ const entryType\u0026 Get##entryName() const { assert(m_kind == __LINE__); return m_##entryName; } \\ entryType Get##entryName() { assert(m_kind == __LINE__); return m_##entryName; } \\ private: \\ entryType m_##entryName; \\ public:  With all of that at your disposal it becomes easy to write:\nauto entity = LivingEntity::Dog(\"Bob\"); DU_MATCH(entity) DU_CASE(Dog, BOOST_CHECK_EQUAL(value, \"Bob\");) DU_CASE(Person,BOOST_CHECK(false);) DU_MATCH_END  There are some beautiful things about this. First of all, the construction of any of such types is super simple. You even get intellisense!\nMoreover the ‘value’ variable contains whatever was passed in the constructor for the object. So this is semantically equivalent, if not syntactically, to the match statement in F#.\nObviously the code part is not limited to a single instruction:\nDU_MATCH(entity) DU_CASE(Dog, cout \u0026lt;\u0026lt; \"I should be here\"; BOOST_CHECK_EQUAL(value, \"Bob\"); ) DU_CASE(Person, BOOST_CHECK(false); ) DU_MATCH_END And for those of you addicted to braces, I venture:\nDU_MATCH(entity) DU_CASE(Dog, { cout \u0026lt;\u0026lt; \"I should be here\"; BOOST_CHECK_EQUAL(value, \"Bob\"); }) DU_CASE(Person, { BOOST_CHECK(false); }) DU_MATCH_END They all work with the same macro definition. They expand to something along the line of:\nif(false) {} else if(entity.IsDog()) { auto value = entity.GetDog(); BOOST_CHECK_EQUAL(value, \"Bob\"); } else if(entity.IsPerson()) { auto value = entity.GetPerson(); BOOST_CHECK(false); } else { throw match_exception(); } I’ve not reached the pinnacle of macro naming mastering with this one. Making them lowercase and risking a bit more on the conflict side would make the syntax much more palatable. I call it, as it is, not too bad.\nThe last ‘else’ clause assures you then if you add a new type to the discriminated union and forget to update one of the ‘MATCH’ clauses at least you get a run time error. That is not good. Functional languages would give you a compile time error, which is much better. Maybe with judicious use of templates you can bring the error at compile time.\nThe macros are trivial:\nclass match_exception: std::exception {}; #define DU_MATCH(unionName) { auto du_match_var = unionName; if(false) {} #define DU_CASE_TAG(entry, ...) \\ else if(du_match_var.Is##entry()) { \\ __VA_ARGS__ \\ } #define DU_CASE(entry, ...) \\ else if(du_match_var.Is##entry()) { \\ auto value = du_match_var.Get##entry(); \\ __VA_ARGS__ \\ } #define DU_DEFAULT(...) \\ else if(true) { __VA_ARGS__} #define DU_MATCH_END else {throw new match_exception();} }  Let’s now go back to our initial goal and see how far off we are. We were trying to do the following:\ntype LivingEntity = | Person of string | Dog of string let print = function | Person(name) -\u0026gt; printfn \"I'm a per named %s\" name | Dog(name) -\u0026gt; printfn \"I'm a dog named %s\" name And here is what we ended up with:\nDU_DECLARE(LivingEntity) DU_VALUE(Person, string) DU_VALUE(Dog, string) DU_END auto print(LivingEntity en) -\u0026gt; void { DU_MATCH(entity) DU_CASE(Dog, cout \u0026lt;\u0026lt; \"I'm a dog named \" \u0026lt;\u0026lt; value;) DU_CASE(Person, cout \u0026lt;\u0026lt; \"I'm a per named \" \u0026lt;\u0026lt; value;) DU_MATCH_END } In our Switch case:\ntype Switch = On | Off\nYou get the good looking :\nDU_DECLARE(Switch) DU_FLAG(On) DU_FLAG(Off) DU_END   And along the way we lost compile time type safety in the very common case of adding new types to the discriminated union. That’s bad.  Also some of you would strongly dislike the (ab)use of macros. As for me, it looks workable.   ","permalink":"https://peaceiris.com/MyBlog/posts/2012-04-27-writing-functional-code-in-c-iv-algebraic-datatypes/","tags":["C++","Functional Programming"],"title":"Writing functional code in C++ IV – Algebraic datatypes"},{"categories":["C"],"contents":"Now we know how to represent records and we know how to operate on them using a nice F# like syntax. But how do we store our record in a data structure in the first place?\nCode for this post is here. Thanks to Andy Sawyer and Steve Bower for reviewing this.\nAs it is often the case, C++ gives you many options that are not available in standard functional languages. A mixed blessing of some sort.\n You can store them by value or by pointer If you store them by pointer, you can use normal pointers or smart pointers If you store them by smart pointer, you can use different ones  Well, storing them by value is the simplest option, but it has two shortcomings:\n You pay the price of a full record copy whenever the object need to be copied (i.e. when you add/remove records to/from a vector and whenever the vector needs to resize itself) If you store a record in two containers, you get two different copies of it. If you modify one, the other won’t be modified  The second issue is not a problem in our scenario as records, by definition, are immutable and structurally equivalent (aka equality for them doesn’t mean pointer equality). The first issue is more tricky. Our records get a copy constructor by default which does a ‘memcpy’ of the object. That should be fast. But fast enough?\nTo answer this question (and more), I embarked in a little performance test that encompasses most ways to store a pod type in an vector like data structure. For all my test I used this struct:\nstruct Record { int Id; char k1[2]; char k2[2]; char k3[2]; char k4[2]; char k5[2]; char k6[2]; char mem[bigBlock]; void Lock() {} void Unlock() {} }; By recompiling with different values for ‘bigBlock’ I can test what happens when the record size grows. In all tests a record is initialized with this function:\nvoid record_init(Record\u0026 r, int i) { r.Id = i; strcpy(r.k1, \"0\"); strcpy(r.k2, \"0\"); strcpy(r.k3, \"0\"); strcpy(r.k4, \"0\"); strcpy(r.k5, \"0\"); strcpy(r.k6, \"0\"); memset(r.mem, '-', bigBlock); } The tests are specific to the scenario I care about: performing functional-like operations on a Range:\nstruct to_int { typedef int result_type; int operator() (const Record\u0026 r) const { return r.Id; }; }; function\u0026lt;bool (const Record\u0026)\u0026gt; filter_f = [](const Record\u0026 r) {return r.Id \u0026lt; filterNo;}; template \u0026lt;class Range\u0026gt; int accumulate_filter(const Range\u0026 r) { return boost::accumulate( r | filtered(filter_f) | transformed(to_int()), 0, plus\u0026lt;int\u0026gt;()); } The usage of a function and a functor is a bit odd. I don’t recall why I did it that way, but it doesn’t matter as it is the same for each test. What the test does is just filtering a bunch of record, transforming them (map) to ints and sum these ints.\nHow many repetitions of each test are used, how big is the record, how many records the Range contains is specified in these constants:\nconst int repetitions = 1000; const int bigBlock = 1000; const int howMany = 1000; Time is kept using this clock that wraps boost::chrono:\ntypedef boost::chrono::process_cpu_clock the_clock; struct timer { timer(): clock_(the_clock::now()) {} the_clock::times elapsed() { return (the_clock::now() - clock_).count(); } the_clock::time_point clock_; }; I have tested the following configurations. Adding records by value:\nint normal() { vector\u0026lt;Record\u0026gt; v; for (int i = 0; i \u0026lt; howMany; ++i) { Record r; record_init(r, i); v.push_back(r); } return accumulate_filter(v); } I then tested adding records using a pod_vector. This is a data structure described here and in “Imperfect C++”. It is a vector that uses as an auto_buffer as the underlying storage. An auto_buffer is a class that uses stack memory if it needs more than a certain number of bytes specified at compile time, otherwise it uses heap memory. It works well if you know at compile time that most allocations for something take at most N bytes, but some might need more. This situation is surprisingly frequent. Unfortunately, your objects need to be POD to use the pod_vector.\nI tested it in the case where the stack space is big enough (podVector\u0026lt;howMany*2\u0026gt;) and when it is not (podVector\u0026lt;howMany/10\u0026gt;).\nint podVector() { pod_vector\u0026lt;Record,size\u0026gt; v; for (int i = 0; i \u0026lt; howMany; ++i) { Record r; record_init(r, i); v.push_back(r); } return accumulate_filter(v); } I then tested just allocating the memory, without freeing it and using boost::pool in it’s ‘local’ form, which means that memory is freed when it goes out of scope (stack-like). The main drawback of the latter is that you cannot return the container/range.\nint boostallocator(WhichOne which) { boost::pool\u0026lt;\u0026gt; p(sizeof(Record)); vector\u0026lt;Record*\u0026gt; v; Record* r; for (int i = 0; i \u0026lt; howMany; ++i) { if(which == Boost) r = (Record*)p.malloc(); // memory freed at function exit else r = new Record; // oops, memory leak record_init(*r, i); v.push_back(r); } return accumulate_filter(v | indirected); } Indirected is needed because we are not talking about pointers. I also tested various variations of shared pointers. First a normal shared_ptr, then a shared_ptr initialized with the boost::singleton_pool and finally a pointer initialized with make_shared.\nint pointers(WhichOne which) { vector\u0026lt;shared_ptr\u0026lt;Record\u0026gt;\u0026gt; v; for (int i = 0; i \u0026lt; howMany; ++i) { shared_ptr\u0026lt;Record\u0026gt; r; if(which == Normal) r = shared_ptr\u0026lt;Record\u0026gt;(new Record); else if(which == Boost) r = shared_ptr\u0026lt;Record\u0026gt;((Record*)record_pool::malloc(), [](void* p) {record_pool::free(p);}); else if(which == Make) r = make_shared\u0026lt;Record\u0026gt;(); else throw \"This kind of pointer doesn't exist\"; record_init(*r, i); v.push_back(r); } return accumulate_filter(v | indirected); } Finally, I used a Loki smart pointer. This is a very elegantly designed smart pointers from “Modern C++ design”. You pass as template parameters the policies you want your smart pointer to have (aka how it should behave). I tested it like so:\ntypedef Loki::SmartPtr\u0026lt;Record, Loki::RefCounted, Loki::DisallowConversion, Loki::AssertCheck, Loki::DefaultSPStorage, LOKI_DEFAULT_CONSTNESS\u0026gt; RecordPtr; And using the following, slightly more convoluted code:\nint lokipointers(WhichOne) { vector\u0026lt;RecordPtr\u0026gt; v; for (int i = 0; i \u0026lt; howMany; ++i) { RecordPtr r = RecordPtr(new Record()); record_init(*r, i); v.push_back(r); } auto ret = accumulate_filter(v | transformed(RecordPtr::GetPointer) | indirected); return ret; } The result of my tests are in this table and at this link. I used VS10 and gcc 4.6.2 on a Windows 7 box. The first number in the (S, N) pair at the top of each column represents the size of the record, the second one represents the number of objects in the vector. To obtain reasonable numbers, the tests have been run with a different number of iteration for each pair, which means that you can compare the results vertically, but not horizontally.\n\nThere are a lot of interesting things in this table. Here are my takeaways. They are obviously specific to this single scenario. You might have different scenarios or different takeaways:\n Stack allocation is not too bad for small objects, especially for gcc Pod_vector is a good overall performer (even if you don’t get the size right), it is unfortunate that just works with POD types GCC seems to be lagging on the shared_ptr front. Also msvc implementation of the make_shared optimization gives a visible advantage There is not much advantage in using the shared pointer with the boost pooled allocator If you can use the boost local pool allocator, you should. It is faster than stack allocation (in this scenario). Remember that the memory is reclaimed when you exit the function …  So here you have it. A small detour on the performance of different schemes for allocating pod types. As it is often the case in C++, it depends …\nBTW: Andy Sawyer told me about his rough algorithm to decide which STL container to use. I reproduce it here:\nBEGIN\nA decision tree for selecting a sequence container:\n  I’m in a rush and don’t want to read the rest: use std::deque\n  Do we know ahead of time exactly how many elements will be needed (and will they all fit on our stack!) - If so, use std::array.\n  Do we need constant-time random access? (Note that we often think we do, but actually don\u0026rsquo;t - YAGNI) If so, then we can eliminate std::list/std::forward_list as candidates.\n  Do we need bidirectional iteration? (Again, we need this less often that we think we do). If so, that eliminates std::forward_list\n  Will there be a large number of in-the-middle insertion/removal? (and assuming we haven’t already eliminated them) then std::list/std::forward_list (especially when the contained type is expensive to move/copy). In extreme cases, this may be a strong enough requirement to override other constraints (e.g. the need for random access). On the other hand, it may be viable to reduce the cost of move/copy of large contained types by using containers of (smart) pointers.\n  Do we need the contents as a contiguous array? use std::vector (and call reserve if we can) - sometimes, anyway; I’ve seen cases where it\u0026rsquo;s faster to build my collection as a std::deque, then transform to std::vector later on.)\n  Use std::deque.\n  Or, to put it another way, “use std::deque unless there’s a good reason not to”. That’s probably an overly-strong statement, but it’s a reasonable starting point.\nNaturally, every case will be different - and no set of ‘rules of thumb\u0026rsquo; is going to work every time (this is one of the things which distinguish rules of thumb from laws of physics). Commonly, we don\u0026rsquo;t know ahead of time which of those criteria is going to have the most significant impact on what we\u0026rsquo;re doing; when I find myself in that situation, I\u0026rsquo;ll use std::deque; once I have a firmer idea of the criteria, I’ll go back and revisit that choice (which – quite often – is as simple as changing a typedef). And of course - as with all ‘optimisations\u0026rsquo; - measure, measure and measure again!\nEND\nNext time, we’ll go back to more traditional functional programming topics.\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-04-16-writing-functional-code-in-c-iii-performance-of-different-allocation-schemes/","tags":["C++","Functional Programming"],"title":"Writing functional code in C++ III – Performance of different allocation schemes"},{"categories":["Investing"],"contents":"In 2007 I wrote a blog post on investing. During the last five years, my view evolved a bit. People often ask me how to get a financial education. This is the latest email I sent on the topic.\nFrom: Bolognese, Luca\nSent: 04 April 2012 16:52\nTo: XXX\nSubject: RE: A financial education\nDisclaimer: this are just my personal opinions drawn from my 10+ years of investing, reading books and academic papers about it. I can justify most statements below with some academic reference, but that would make this email too long.\nAlso someone else might read the same material and come up with a different opinion. It is a field that is probabilistic in nature and doesn’t lend itself to certainties. For example, you can make a lot of money out of an investment and still be wrong to have made it. And conversely.\nOur brains don’t work well in such fields.\n The most important thing in investing is not investing, it is saving the money to invest. If you save enough and are mildly reasonable in your investments (aka you diversify), you are going to be ok. Saving is not mechanically difficult, it is motivationally difficult. The best book I found on the topic is this one. I read earlier editions, this is a new one. I don’t like the investment chapters. After that, you need to make sure that your financial matters are in order (i.e. you are ensured against catastrophes, you maximize your tax deductions, etc..). This is the field of personal finance. I’ve been suggesting this book to American audiences. It is on Amazon.co.uk, so it might be the UK version. Now that you have saved money and your finances are in order, you can start thinking about investing. The most important things in investing are: deciding what you believe in, what your risk tolerance is, how important is for your performance to track the market, what your time horizon is and how much time you want to dedicate to investing.  My risk tolerance is high. I’ve spent a lot of time learning about investing. I’m willing to see the value of my portfolio go down without experiencing emotional distress (I’ve tried it) I don’t care about my investment performance tracking the market. I don’t watch financial programs. My time horizon is long. These are money I invest for my retirement. I’m willing to invest time to keep myself up to date on investment topics and manage my portfolio I believe the following (these are the biases that colour my view): Diversification among different sources of returns is to be sought aggressively Most asset classes are not efficient because of:  Predictable flaws in human brain’s processing machinery Institutional constraints on most professional investor (aka they have to track the market they invest in closely) Short term performance incentive for professional investors   Some asset classes are intrinsically more inefficient than others (i.e. emerging markets micro stocks compared to US large stock) because that’s where the causes of inefficiencies are strongest The biggest inefficiencies are among asset classes (i.e. stocks vs bonds vs commodities) Most people (myself included) don’t have the time to do the research necessary to invest in individual stocks using the two ways that I believe are ‘right’: quant models or/and fundamental value analysis.   Some books to get you started:  A good perspective on how to think about the market and the work you need to do if you want to invest in stocks. The intelligent investor. Why diversification is important. The intelligent asset allocator. I don’t believe in static asset allocation, but you need to know what it is to believe (or not) in it. Moving beyond a static asset allocation with a quant based highly diversified, but simple to implement system. The Ivy Portfolio. I am very tempted to use this one myself Why asset classes are often mispriced. Probably the premier quant shop around. Read most quarterly letters. Systems to take advantage of such mispricing are described here. I have obtained copies of all the newsletters sent by the author going back to 1991 and backtested some of the systems. These are the system I use. But the newsletter is relatively expensive and complex to follow. If you decide to branch out into value analysis of companies. Essays of warren buffett. You would also need to read an introductory and an advanced accounting text. I don’t know UK accounting, so cannot suggest good candidates. If you are very conservative and want to just invest in Inflation Linked Bonds (or fearful of markets in general), there is a book for that: here.   With all of that out of the way, here is some practical counsel  if you have less than 20,000 pounds to invest try to find a fund or etf that invest in a diversified array of asset classes for a small price. I don’t know the UK market, so cannot suggest one. If you have more than that and are willing to dedicate a few hours a month, you can start implementing some of the systems in the Ivy Portfolio book. Maybe you integrate it with the GMO 7 years asset class forecasts to push a bit of value bias in your system. For most people that’s it. If it becomes a lifelong interest / mania as it is for me, there is a bit more that can be done, but it is unclear to me that the results are necessarily better than the simple systems described above.    Cheers,\n.luca\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-04-05-letter-on-investing/","tags":["Financial"],"title":"Letter on investing"},{"categories":["C"],"contents":"Function composition is at the core of functional programming. You start by being very confident that certain very small functions are correct, you compose them in well known ways and you end up being very confident that your final program is correct.\nYou are very confident that the initial functions are correct because they are very small and side effect free. You are very confident that your program is correct because the means of composition are well known and generate functions that are themselves side effect free.\nSuch ‘almost primitive’ functions operate on data structures. Each functional language has its own set of data structures and ‘almost primitive’ functions. Probably the most famous ones are contained in the haskell prelude, but F# has similar ones. LINQ in C# is just such a set.\nIn this article I use the term functional composition in a broad sense as ‘putting functions together’, not in the more technical sense of f(g(x)): dot operator in Haskell or ‘\u0026raquo;’ operator in F#.\nCode for this post is here. Thanks to Steve Bower and Andy Sawyer for review and comments.\nHere is an example. The F# code below filters in the odd numbers from an array and doubles them. You have two logical operations, filtering and doubling.\nlet v = [|1;2;3;4;5;6;7;8;9;0|] let transformed = v |\u0026gt; Seq.filter(fun i -\u0026gt; i % 2 = 0) |\u0026gt; Seq.map ((*) 2)  How would the code look in C++? There are many ways. One is the ‘big fat for loop’, or in C++ 11, for each:\nconst int tmp[] = {1,2,3,4,5,6,7,8,9,0}; const vector\u0026lt;int\u0026gt; v(\u0026tmp[0], \u0026tmp[10]); vector\u0026lt;int\u0026gt; filtered; for(auto i:v) { if(i % 2 == 0) filtered.push_back(i * 2); } This looks simple enough, apart from the initialization syntax that gets better with C++ 11. But it’s simplicity is misleading. We have now lost the information that our computation is composed by a filter and a map. It’s all intermingled. Obviously, the info is still there in some sense, but you need to read each line in your head and figure out the structure on your own. It is not readily apparent to the reader.\nObviously, things get much worse in a large program composed of several loops where each one does not trivial stuff. As for me, every time I indulge into the ‘big fat for loop pattern’, I end up regretting it either immediately or after some time when I have to make changes to the code. So I try to avoid it.\nWait a minute, you might say, what about STL algorithms? Aren’t you supposed to use those?\nThe syntax to call them is not very compositional. You cannot take the result of an algorithm and pass it to another easily. It is difficult to chain them that way. Everything takes two iterators, even if 99% of the times you are just using begin and end. Moreover, you have to create all sort of temporary data structures for the sake of not modifying your original one. Once you have done all of that, the syntactic weight of your code overwhelm the simplicity of what you are trying to do.\nFor example, here is the same code using ‘transform’ for the ‘map’ part of the algorithm:\nvector\u0026lt;int\u0026gt; filtered; copy_if(begin(v), end(v), back_inserter(filtered), [](int x) { return x % 2 == 0;}); vector\u0026lt;int\u0026gt; transformed; transform(begin(filtered), end(filtered), back_inserter(transformed), [](int x) { return x * 2;});  I’m not arguing that STL is a bad library, I think it is a great one. It’s just that its syntax is not very compositional. And that breaks the magic.\nLuckily, help is on the way in the form of the Range library and OvenToBoost. These libraries ‘pack’ the two iterators in a single structure and override the ‘|’ operator to come up with something as below:\nauto result = v | filtered( [] (int i) { return i % 2 == 0;}) | transformed([] (int i) { return i * 2;}); If you use Boost lambdas (not sure I’d do that), the syntax gets even better:\nauto result = v | filtered( _1 % 2 == 0) | transformed(_1 * 2); Ok, so we regained compositionality and clarity, but what price are we paying? Apart from the dependency from Boost::Range and OvenToBoost, you might think that this code would be slower than a normal for loop. And you would be right. But maybe not by as much as you would think.\nThe code for my test is here. I’m testing the perf difference between the following code engineered to put in a bad light the most pleasing syntax. A for loop:\nint sum = 0; for(vector\u0026lt;int\u0026gt;::const_iterator it = v.begin(); it != v.end(); ++it) if(*it \u0026lt; 50) sum += *it * 2; return sum; A Range based code using language lambdas (transformedF is a variation of this):\nauto lessThan50 = v | filtered( [](int i) { return i \u0026lt; 50;}) | transformedF([] (int i) { return i * 2;}); return boost::accumulate (lessThan50, 0); A Range based code using two functors:\nauto lessThan50 = v | filtered(Filterer()) | transformed(Doubler()); return boost::accumulate (lessThan50, 0);  Where:\nstruct Doubler { typedef int result_type; int operator() (int i) const { return i * 2;} }; struct Filterer { typedef int result_type; bool operator() (int i) const { return i \u0026lt; 50;} };  a Range based code using Boost lambdas:\nauto lessThan50 = v | filtered(_1 \u0026lt; 50) | transformed(_1 * 2); return boost::accumulate (lessThan50, 0); And finally, some code using the STL for_each function:\nint sum = 0; std::for_each( v.cbegin(), v.cend(), [\u0026](int i){ if( i \u0026lt; 50 ) sum += i*2; }); return sum;  Notice that I need to run the test an humongous number of times (10000000) on a 100 integers array to start seeing some consistency in results. And the differences that I see (in nanosecs below) are not huge:\n1\u0026gt; Language lambda: {1775645516;1778411400;0} 1\u0026gt; Functor lambda: {1433377701;1435209200;0} 1\u0026gt; Boost lambda: {1327829199;1326008500;0} 1\u0026gt; For loop: {1338268336;1341608600;0} 1\u0026gt; STL foreach: {1338268336;1341608600;0}  True to be told, by changing the code a bit these numbers vary and, in some configurations, the Range code takes twice as long.\nBut given how many repetitions of the test I need to run to notice the difference, I’d say that in most scenarios you should be ok.\nThe ‘|\u0026gt;’ operator over collections is the kind of functional composition, broadly defined, that I use the most, but you certainly can use it over other things as well. You’d like to write something like the below:\nBOOST_CHECK_EQUAL(pipe(\"bobby\", strlen, boost::lexical_cast\u0026lt;string, int\u0026gt;), \"5\"); And you can, once you define the following:\ntemplate\u0026lt; class A, class F1, class F2 \u0026gt; inline auto pipe(const A \u0026 a, const F1 \u0026 f1, const F2 \u0026 f2) -\u0026gt; decltype(REMOVE_REF_BUG(f2(f1(a)))) { return f2(f1(a)); } Where REMOVE_REF_BUG is a workaround for a bug in the decltype implementation under msvc (it should be fixed in VS 11):\n#ifdef _MSC_VER #define REMOVE_REF_BUG(...) remove_reference\u0026lt;decltype(__VA_ARGS__)\u0026gt;::type() #else #define REMOVE_REF_BUG(...) __VA_ARGS__ #endif I didn’t do the work of creating ‘\u0026raquo;’ , ‘\u0026laquo;’ and ‘\u0026lt;|’ F# operators or wrapping the whole lot with better syntax (i.e. operator overloading?), but it certainly can be done.\nNow that we have a good syntax for records and a good syntax for operating over collections, the next instalment will put them together and try to answer the question: how should I create collections of records and operate over them?\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-03-30-writing-functional-code-in-c-ii-function-composition/","tags":["C++","Functional Programming"],"title":"Writing functional code in C++ II – Function composition"},{"categories":["C"],"contents":"This is the first of a series of posts about writing functional code in C++. My goal is different from FC++, which is a full fledged ‘environment’ to write functional code. Instead, I want to experiment with some of the new C++ 11 language features and see if one can build reasonably looking functional code and stay pretty close to the language. The idea is to judiciously use macros and external libraries to build a thin layer on top of the language that doesn’t change the performance characteristics of it (aka it doesn’t slow it down) and integrates fine with existing C++ code.\nThink of it as an attempt to answer the question: is there a way to write C++ code in a functional style without loosing its ‘C++sness’? We won’t attempt to be as type safe or syntactically pleasing as Haskell or F# , but we’ll attempt to stay as fast and flexible as C++ and make it functional enough to be interesting.\nThanks to Steve Bower and Ganesh Sittampalam for reviewing and to Andy Sawyer for giving me so much feedback that this post can be considered a co-authorship. Code for this post is here.\nLet’s first talk about the data types that you typically find in a functional language. Let’s start with Records. They are not part of the functional model per se. You can do without them and just use algebraic data types and tuples. But they are damn convenient, and most functional languages (i.e. Haskell, Clojure, etc…) have them now. We start from them because they map naturally to C++. Records are just like structs, but immutable and having structural equality.\nIn F# your vanilla record looks like this:\ntype Person = { Name: string Id: int } Nice and simple. With C++, you become more verbose. A first attempt would be:\nstruct Person { const string Name; const int Salary; }; Which looks nice and easy, but doesn’t quite work because more often than not you need to be able to compare two records for structural equality (which means the value of their fields, not the pointer in memory, defines equality). Records in functional languages automatically support that. But the syntax gets on the ugly side:\nstruct Person { const string Name; const int Salary; bool operator==(const Person\u0026 other) const { return Salary == other.Salary \u0026\u0026 Name == other.Name;} bool operator!=(const Person\u0026 other) const { return !(*this == other);} }; We’ll see how to simplify the syntax later. The syntax on the creation side is not too bad:\nPerson p = {\u0026quot;Bobby\u0026quot;, 2};\nLet’s call the above representation, the obvious one. Let’s consider two variations on this scheme. The first one is useful if you want to make your records interoperable with C or with other C++ compilers. \nA full discussion of how to achieve these goals would be very long. It will go about discussing what POD types are and how their definition got more precise in C++ 11.\nYou can look at my experimentations on pod, standard layout and trivially constructible types here. My summary is pretty simple, if you want to achieve all the goals above, you got to use C structs that contain C-compatible types. No const, strings or STL libraries allowed.\nThe above class would then become:\nstruct Person { char Name[20]; int Salary; bool operator==(const Person\u0026 other) const { return Salary == other.Salary \u0026\u0026 !strcmp(Name,other.Name);} bool operator!=(const Person\u0026 other) const { return !(*this == other);} }; Obviously, not being able to use strings or STL collections in your record is a big limitation, but in certain cases you might be able to live with it. Let’s call this representation, the pod one.\nYou would think you can make the syntax better by doing something like the below:\nstruct _Person { int id; char name[20]; pod_equality(_Person); };  Where pod_equality is defined as below:\n#define pod_equality(Record) \\ bool operator==(const Record\u0026 other) const { \\ static_assert(std::is_trivial\u0026lt;Record\u0026gt;::value, \"Not trivially copyable\"); \\ return memcmp(this, \u0026other, sizeof(Record)) == 0;} \\ bool operator!=(const Record\u0026 other) const { return !(*this == other);} But you would be wrong (as I was for a while), as comparing memory values doesn’t work in this case because of the padding that the compiler can insert between fields. Such padding can contain random value (whatever was on the stack, for example) which would make the equality return false for structurally equal objects. Also this scheme fails for floating point types (i.e. NaN and signed zeros).\nAn alternative representation for records, which nicely separates constness from the structure of your record is below. It does have some some advantages that we’ll look at, but in its raw form it is yet more syntax:\nnamespace Mutable { struct Person { string Name; int Salary; bool operator==(const Person\u0026 other) const { return Salary == other.Salary \u0026\u0026 Name == other.Name;} bool operator!=(const Person\u0026 other) const { return !(*this == other);} }; } typedef const Mutable::Person Person;  Let’s call this representation, the immutable one. Let’s give these guys some usage and talk about their trade-offs. If you want to write a function that increase someone salary, you would write it like this:\ntemplate\u0026lt;class T\u0026gt; T rise_salary1(const T\u0026 p) { T ret = { p.Name, p.Salary + 1000 }; return ret; } This looks nice and clean, unless your record has a lot of fields. Let me tell you, in real application it probably does. For example:\nnamespace Mutable { struct foo { int value1; int value2; int value3; int value4; int value5; int value7; int value6; int value8; int value9; }; } typedef const Mutable::foo foo; foo increment_value7( const foo\u0026 f ) { foo tmp = { f.value1, f.value2, f.value3, f.value4, f.value5, f.value6, f.value7+1, f.value8 }; return tmp; } Thanks to Andy for this example. BTW: did you spot the bug at first sight? What about the other one?\nSo this syntax is problematic. True to be told, part of the problem is in the sub-optimal initialization syntax in C++. If you could use named parameters, it would be more difficult to introduce bugs, but the syntax would still be ugly. You really need something like the F# syntax:\nlet r1 = {f = 0.2; k = 3} let r2 = {r1 with f = 0.1}  Can we do something like that? Well, if we are willing to pass the Mutable one around, we can write this:\ntemplate\u0026lt;class T\u0026gt; T rise_salary2(const T\u0026 p) { T ret(p); ret.Salary += 1000; return ret; } Or even this:\ntemplate\u0026lt;class T\u0026gt; T rise_salary3(T p) { p.Salary += 1000; return p; } But that doesn’t make us happy, does it? The whole point of making things const is that you want them to be const. If you pass around mutable ones, who knows what’s going to happen inside the method?\nThere is a middle ground that might be acceptable, which is to write functions so that their interface takes immutable records, but inside the function they operate on mutable ones. This is not a bad pattern in general, as having mutable versions of your immutable records might come useful for optimizing certain algorithms. Luckily the casting rules of C++ favour the bold, so the below works:\nPerson rise_salary_m(const Person\u0026 p) { Mutable::Person ret(p); ret.Salary += 1000; return ret; } And doesn’t look too bad either.\nNow let’s talk syntax. Defining a record is still a lot of typing (and a lot of reading if you are maintaining the code). F# does it like this:\ntype Person = { Name: string Id: int } The best I came up with looks like this:\nRECORD2(Person, string, Name, int, Salary); And you need a lot of those macros depending on how many fields your record has. You can write this macro to expand to either the Obvious or Immutable representation trivially. It is a bit more complex for the Pod one because of the interesting C++ array declaration syntax with the number of elements after the name of the field.\nFor the Obvious one it looks like this:\n#define RECORD2(n, t1, f1, t2, f2) \\ struct n { \\ const t1 f1; \\ const t2 f2; \\ \\ bool operator==(const n\u0026 other) const { return f1 == other.f1 \u0026\u0026 f2 == other.f2;} \\ bool operator!=(const n\u0026 other) const { return !(*this == other);} \\ }; All the usual concerns about macros apply. Moreover all your fields need to have a meaningful == operator.\nTo summarize, we have found three different representations of records in C++ and tried to alleviate the syntax burden with some macro magick. We’ll go wild in macro-land when we talk about discriminated unions.\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-03-23-writing-functional-code-in-c-records/","tags":["C++","Functional Programming"],"title":"Writing functional code in C++ – Records"},{"categories":["C"],"contents":"Recently I got interested in C++ again. The new lambda functions in C++ 11 open up a world of opportunities for C++ programmers. I’ll talk more about how you can write functional code in C++ 11 in upcoming posts. For now let’s look at design by contract.\nDesign by contract is a development style promoted by Bertrand Meyer and it is implemented in his own Eiffel programming language. At core, it advocates using preconditions, postconditions and invariants.\nAn invariant is an assertion that always holds true for a class after the class has been fully constructed and if the code is not executing inside a method. As a user of the class, you always observe the invariant to be true. As an implementer of the class, you can be assured that the invariant is true before a method is entered and you need to make the invariant true again by the time your method exits.\nA preconditions is an assertion that needs to hold true at the start of a function, for the postcondition to be true at the end of it. Taken together, invariant, precondition and postcondition define the contract between the implementer and the user of a class.\nCode for this post is here and here. Thanks to Andy Sawyer, Steve Bower and Ganesh Sittampalam for reviewing my code and suggesting improvements.\nPreconditions are simple and everyone uses them. They are those little if statements that you put at the start of your functions to make sure that the caller has given you the right parameters.\ndouble divide(double x, double y) { if(y == 0) throw new exception(“y cannot be 0”);\n… } These little ‘if’ statements don’t really make the precondition stand out. They can be confused with other, unrelated, ‘if’ statements that do completely different semantic things. A more readable alternative is:\ndouble divide(double x, double y) { requires(y != 0); …\n} Not an impressive difference, for sure, but kind of nice. The evil macro looks like this:\n#ifndef ___PRECOND #define requires(F) {if((!(F))) throw preexception(__FILE__, __LINE__,\"Pre-condition failure: \" #F);}; #else #define requires(F) #endif Note that the exception maintains information not just about the file and line number of the failure, but also a textual representation of the failed condition. Such things you can do with macro magick.\nPostconditions are trickier. In the case of a side-effect free (pure) function, a postcondition asserts something of interest about the return value. In the case of a class, it asserts something of interest about the state of the class before and after the execution of the method.\nLet’s start with a pure function. I like to have all my assertion at the start of the function to allow reasoning about it without looking at implementation details. But that poses the problem that the result is available just at the end of the function. My solution is to enforce this idiom:\ndouble divide(double x, double y) { double result; requires(y != 0); ensures(result \u0026lt; x); // Silly, just to falsify it in tests\n… return result; } So you need to declare your result upfront. That is the biggest limitation of the overall solution in my opinion. If that is acceptable to you, the trick now is how to execute the postcondition test before the method exits. We can do that by storing a lambda and executing it in the destructor:\ntypedef std::function\u0026lt;bool ()\u0026gt; ___dbcLambda; class ___post { public: ___post(const char *file, long line, const char *expr, const ___dbcLambda\u0026 postF) : _f(postF), _file(file), _line(line), _expr(expr) {} ~___post() { if( !std::uncaught_exception() \u0026\u0026 !_f() ) { throw postexception(_file,_line,_expr); } } private: const ___dbcLambda _f; const char * const _file; const long _line; const char * const _expr; }; You might think that you shouldn’t throw exceptions in a destructor. That is something I never understood about the RAII pattern in C++. If I choose to use exceptions as my error notification method, how am I supposed to get notified if there is a problem releasing a resource in RAII, other than by throwing an exception in the destructor?\nMaybe because of this, the standard has an uncaught_exception() function that allows you to check if an exception has been thrown, so that you don’t throw another one during stack unwinding. If you really don’t like throwing in the destructor, feel free to assert.\nYou might be worried about performance, but you really shouldn’t as you can disable all these macros in Release.\nThe macro then creates a ___post class on the stack.\n#define ensures(F) \\ int ___UNIQUE_LINE = __LINE__; \\ auto ___UNIQUE_POST = ___post( __FILE__, __LINE__, \"Post-condition failure:\" #F, [\u0026](){return (F);}); The UNIQUE stuff is messy business. Part of it is by design and it is used to make sure that each __post variable has a unique name to have multiple ‘ensures’ in a function. The other part is a workaround for this msvc bug. Let me know if you want more details. I suspect there is a better way to do it.\nHere is the full enchilada …\n#define ___MERGE(a, b) a##b #define ___POST(a) ___MERGE(___postcond,a) #define ___UNIQUE_POST ___POST(__LINE__) #define ___LINE(a) ___MERGE(___line, a) #define ___UNIQUE_LINE ___LINE(__LINE__) The case in which a postcondition is used inside a method of a class is even trickier because the postcondition must be able to compare the state of the class at the entrance of the method to the state of the class at its exit. Assuming a Counter object with an Add method and assuming ‘___pre’ captures the state of the counter at the start of the method, you’d like to write something like:\nvoid Add(int x) { ensuresClass(this-\u0026gt;c_ == ___pre.c_ + x);\n… } Now, this is tricky. The only way to capture the ‘old’ state in ‘___pre’ is by making a copy of it and store it there. This is what the code below does:\n#define ensuresClass(F) \\ auto ___pre(*this); \\ auto ___UNIQUE_POST = ___post( __FILE__, __LINE__, \"Post-condition failure: \" #F, [\u0026](){return (F);}); More troubling is the possibility that the class doesn’t have a copy constructor. In that case you explicitly need to associate a value with ‘___pre2’ by passing it as the first parameter to the appropriate macro as in the code below:\nvoid Add(int x) { ensuresClass2(this-\u0026gt;c_, c_ == ___pre2 + x); } Which is implemented as follows:\n#define ensuresClass2(ASS,F) \\ auto ___pre2(ASS); \\ auto ___UNIQUE_POST = ___post( __FILE__, __LINE__, \"Post-condition failure: \" #ASS \" is ___pre2 in \" #F, [\u0026](){return (F);}); And I know about the giant ass …\nNow for invariants. The user should implement an isValid() method on his class as below:\nbool isValid() { return c_ \u0026gt;= 0;} Then he should add an ‘invariant()’ call at the start of each method, at the end of each constructor and at the start of each destructor:\nvoid Add(int x) { invariant(); requires(x \u0026lt; 10); ensures(this-\u0026gt;c_ == ___pre.c_ + x);\n… } This calls the ‘isValid’ function at the start of the method and at the end of it using the same destructor trick:\n#define invariant() \\ if(!(this-\u0026gt;isValid())) throw preexception(__FILE__, __LINE__,\"Invariant failure\"); \\ auto ___UNIQUE_INV = ___post( __FILE__, __LINE__, \"Invariant failure\", [\u0026](){return this-\u0026gt;isValid();}); All the above machinery is not at all equivalent to having such constructs in the language, but it is simple enough and with a decent enough syntax to be interesting.\nNow a caveat: I have no idea if any of this works. It does work in my examples and its behaviour seems reasonably safe to me, but I haven’t tried it out on any big codebase and haven’t stressed it enough for me to be confident recommending its usage. So, use it at your own risk, let me know how it goes.\n","permalink":"https://peaceiris.com/MyBlog/posts/2012-03-06-a-simple-scheme-to-implement-design-by-contract-in-c/","tags":["C++","Functional Programming"],"title":"A simple scheme to implement Design by Contract in C++"},{"categories":["fsharp"],"contents":"We are now going to look at a solution which is concise, efficient and gives sophisticated error messages. It is also less than 20 lines of code. We’ll be using FParsec.\nFParsec is a port of an Haskell library. It is a parser combinator library or, as I like to think of it, an internal DSL to build parsers in F#. My usual disclaimer: I’m not an expert in FParsec. It is likely that, if you are an expert, you can come up with more maintainable/efficient/elegant version of this parser.\nThe whole code is below:\nlet ws = \" \\t\\n\" let specialChars = \".)(\\\\\\n\" let pWs = spaces let pName = manyChars (noneOf (ws + specialChars)) |\u0026gt;\u0026gt; EName let pExpr, pExprRef = createParserForwardedToRef\u0026lt;Expression, Unit\u0026gt;() let curry2 f a b = f(a,b) let pFunction = pchar '\\\\' \u0026gt;\u0026gt;. pipe2 pName (pchar '.' \u0026gt;\u0026gt;. pExpr) (curry2 Function) let pApplication = pchar '(' \u0026gt;\u0026gt;. pipe2 pExpr (pWs \u0026gt;\u0026gt;. pExpr) (curry2 Application) .\u0026gt;\u0026gt; pWs .\u0026gt;\u0026gt; pchar ')' do pExprRef := pFunction \u0026lt;|\u0026gt; pApplication \u0026lt;|\u0026gt; pName let pExpressions = sepBy pExpr spaces1 This mirrors pretty closely the grammar we are trying to parse. A program is a bunch of expressions separated by whitespaces.\nlet pExpressions = sepBy pExpr spaces1\nsepBy is a combinator that takes a parser that defines what to parse and a parser that defines what the separator should be. And the separator should be one or more spaces …\npExpr is either a function, an application or a name. the operator \u0026lt;|\u0026gt; is a choice combinator that tries each parser in order. It tries the right parser just if the left parser fails and it doesn’t consume input. So it doesn’t backtrack. If you need a backtracking parser, you’ll need to get acquainted with the attempt combinator.\ndo pExprRef := pFunction \u0026lt;|\u0026gt; pApplication \u0026lt;|\u0026gt; pName A function starts with a ‘\\’, then comes a name, a dot and an expression.\nlet pFunction = pchar '\\\\' \u0026gt;\u0026gt;. pipe2 pName (pchar '.' \u0026gt;\u0026gt;. pExpr)\n(curry2 Function) I know that might look crazy (and maybe it is), but just bear with me. Someone , who I’m not sure I can name, once told me that functional programming is great to write code, but terrible to read it and debug it. The phrase stayed with me as containing a grain of truth. In any case, in the code above:\n    . is a combinator that says “use the left parser, discard its value and then use the right one, returning its value”. Try to guess what .\u0026raquo; does …\n   pipe2 is a combinator that says “apply the first parser, the second parser and then call a function passing as parameters the values returned by the two parsers curry2 is a function combinator that transform a function that takes a tuple to a function that takes the parameters as untupled  let curry2 f a b = f(a,b) An application works similarly, but differently …\nlet pApplication = pchar '(' \u0026gt;\u0026gt;. pipe2 pExpr (pWs \u0026gt;\u0026gt;. pExpr) (curry2 Application) .\u0026gt;\u0026gt; pWs .\u0026gt;\u0026gt; pchar ')' The only difference is that now we have to consume the optional whitespaces and the ‘)’ at the end. A rule of thumb that I use is to use \u0026raquo;. to flow the result through and pipeX when I need more than one result.\nThe last thing is pName, which consume chars until it finds either a whitespace or a special char.\nlet ws = \" \\t\\n\" let specialChars = \".)(\\\\\\n\" let pWs = spaces let pName = manyChars (noneOf (ws + specialChars)) |\u0026gt;\u0026gt; EName And there you have it, a lexer, a parser all in 20 lines of code. I don’t like the code that I wrote above much. I’m sure I could refine it plenty and it probably contains some bugs, but it gives an idea of what is possible with FParsec.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-09-16-adventure-in-parserland-parsing-lambda-expressions-in-f-part-v/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Adventure in parserland – parsing lambda expressions in F# – Part V"},{"categories":["fsharp"],"contents":"Let’ now look at the parser. First let’s review the grammar:\n(* \u0026lt;expression\u0026gt; ::= \u0026lt;name\u0026gt; | \u0026lt;function\u0026gt; | \u0026lt;application\u0026gt; \u0026lt;name\u0026gt; ::= non­blank character sequence \u0026lt;function\u0026gt; ::= \\ \u0026lt;name\u0026gt; . \u0026lt;body\u0026gt; \u0026lt;body\u0026gt; ::= \u0026lt;expression\u0026gt; \u0026lt;application\u0026gt; ::= ( \u0026lt;function expression\u0026gt; \u0026lt;argument expression\u0026gt; ) \u0026lt;function expression\u0026gt; ::= \u0026lt;expression\u0026gt; \u0026lt;argument expression\u0026gt; ::= \u0026lt;expression\u0026gt; *)  And the data type to represent it:\ntype Name = string and Body = Expression and Function = Name * Expression and FunctionExpression = Expression and ArgumentExpression = Expression and Expression = | EName of string | Function of Expression * Body | Application of FunctionExpression * ArgumentExpression | EOT In essence, the data type need to store all the information needed for subsequent stages of computation (i.e. beta reductions and such). The closer it is to the grammar, the better. In this case it looks pretty close.\nRemember what is the main goal of our parser:\nlet parseTextReader: TextReader -\u0026gt; seq\u0026lt;Expression\u0026gt; = textReaderToLazyList \u0026gt;\u0026gt; tokenStream \u0026gt;\u0026gt; parseExpressions We have already looked at TextReaderToLazyList and tokenStream. Now it is the time to look at parseExpressions. It’s goal is to parse the LazyList and return a sequence of expressions. The choice of returning a sequence at this point is to make the parseTextReader, which is the main function in the program, return a more ‘standard’ type.\nand parseExpressions tokens = seq { let tokens = parseOptionalWs tokens let expr, tokens = parseExpr tokens let tokens = parseOptionalWs tokens match expr with | EOT -\u0026gt; yield EOT | exp -\u0026gt; yield exp; yield! parseExpressions tokens } parseOtionalWs simply skips ahead whatever whitespaces it finds.\nand parseOptionalWs tokens = match tokens with | LazyList.Nil -\u0026gt; LazyList.empty | LazyList.Cons(h, t) -\u0026gt; match h with | Ws _ -\u0026gt; parseOptionalWs t | _ -\u0026gt; tokens parseExpr is more interesting. It is the main switch that creates expression kinds.\nlet rec parseExpr tokens = match tokens with | LazyList.Nil -\u0026gt; EOT, LazyList.empty | LazyList.Cons(h, t) -\u0026gt; match h with | EOF -\u0026gt; parseEOF tokens | Name _ -\u0026gt; parseName tokens | Lambda -\u0026gt; parseFunction tokens | OpenParens -\u0026gt; parseApplication tokens | token -\u0026gt; errorAtStart \"Expression\" token parseEOF is not.\nand parseEOF tokens = EOT, LazyList.empty parseName just returns a EName, unwrapping it from Name.\nand parseName tokens = EName (head tokens |\u0026gt; unwrapName), tail tokens Unwrap just unwraps it.\nlet unwrapName = function | Name(s) -\u0026gt; s | tok -\u0026gt; errorExpecting \"a Name\" \u0026lt;| writeToken tok parseFunction just conumes a Lambda, a name, a Dot token, a body (i.e. \\x.x)and assembles them in a Function:\nand parseFunction tokens = let tokens = consumeToken Lambda tokens let name, tokens = parseName tokens let tokens = consumeToken Dot tokens let body, tokens = parseExpr tokens Function(name, body), tokens consumeToken tries to consume a token generating an error if it doesn’t find it:\nlet consumeToken token = genericConsumeToken (fun token' _ -\u0026gt; errorExpecting (writeToken token') (writeToken token)) token genericConsumeToken is just a generalization of the function above:\nlet genericConsumeToken noMatch token = function | LazyList.Nil -\u0026gt; LazyList.empty | LazyList.Cons(h, t) as originalTokens -\u0026gt; match h with | tok when tok = token -\u0026gt; t | tok -\u0026gt; noMatch token originalTokens The last thing left to consume is an application which is in this form (func args):\nand parseApplication tokens = let tokens = consumeToken OpenParens tokens let funExpr, tokens = parseExpr tokens let tokens = parseOptionalWs tokens let argExpr, tokens = parseExpr tokens let tokens = consumeToken CloseParens tokens Application(funExpr, argExpr), tokens Various error and utility functions are defined below:\nlet errorEOF expecting = failwith (\"Expected \" + expecting + \", got EOF\") let errorExpecting expecting gotToken = failwith (\"Expected \" + expecting + \", got\" + gotToken) let errorAtStart expecting gotToken = failwith (\"Expected \" + expecting + \" which cannot start with\" + writeToken gotToken) let tail = LazyList.tail let head = LazyList.head And that is the parser. All 100+ lines of it. As you can tell it is rather formulaic to go from a grammar to a lexer and a parser, which is why you shouldn’t do it, but instead let a tool generate the code for you given the grammar or use FParsec.\nWe have written 200+ code and I don’t think we can be too proud of our achievement. It is:\n Certainly buggy Primitive in error handling Not tail recursive (big text is likely to blow up our stack) Probably inefficient  So let’s look next at a better way to do it.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-09-09-adventure-in-parserland-parsing-lambda-expressions-in-f-part-iv/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Adventure in parserland – parsing lambda expressions in F# – Part IV"},{"categories":["fsharp"],"contents":"Let’s start from the lexer. Remember, I wrote this code based on my memory of how a lexer ought to look like. I didn’t read again the relevant chapters in the Dragon book. But I think it came out all right after all.\nThe tokenStream function we looked at last time takes a LazyList and returns a LazyList. It uses the unfold method on LazyList to call matchToken on each char until the stream is empty.\nlet rec tokenStream chars = LazyList.unfold (fun chList -\u0026gt; match chList with | LazyList.Nil -\u0026gt; None | chList -\u0026gt; let token, chList' = matchToken chList Some(token, chList') ) chars  A token is what gets passed up to the parser to do syntactic analysis on. It is the vocabulary of our language. The lexer divide a phrase in words, the parser put together the words in a phrase. So, these are the words.\ntype Token = | Name of string | Dot | OpenParens | CloseParens | Lambda | Def | Ws of string | NewLine | EOF Matching is a process whereas you try to return the token that you have read plus the list of characters yet to be read. Matching a Token is defined below:\nlet matchToken = function | LazyList.Nil -\u0026gt; EOF, LazyList.empty | LazyList.Cons(h, t) as chars -\u0026gt; match h with | ch when isWs ch -\u0026gt; matchWs chars | ch when isSpecialChar ch -\u0026gt; matchSpecialChar ch t | _ -\u0026gt; matchString chars\nA token is either nothing, a whitespace, a special char or anything else.\nLet’s look at what matching each one of them means. Matching whitespaces means consuming them and remembering what was consumed.\nlet matchWs chars = let value, remainingChars = matchSeriesOfChars isWs chars Ws value, remainingChars matchSeriesOfChars takes a predicate and a LazyList of chars and returns the string composed of all the consecutive chars for which the predicate is true, plus, as always, the remaining chars to be matched. In this case the predicate returns true if the char is a whitespace.\nTo write matchSeriesOfChars I need a function that reverses a LazyList. Not having found such thing, I wrote it.\nlet reversell l = let rec go l' a = match l', a with | LazyList.Nil, a -\u0026gt; a | LazyList.Cons(h, t), a -\u0026gt; go t (LazyList.cons h a) go l LazyList.empty Then I wrote matchSeriesOfChars. The function uses an accumulator. It adds to the front whenever the predicate is true, it reverses it and translates it to a string (I could have reversed the string instead, it might have been better).\nlet matchSeriesOfChars comparer chars = let rec go result = function | LazyList.Nil -\u0026gt; charListToString(reversell result), LazyList.empty | LazyList.Cons(h, t) -\u0026gt; if comparer h then go (LazyList.cons h result) t else charListToString (reversell result), LazyList.cons h t go LazyList.empty chars These are predicates we’ll use later on to recognize characters:\nlet isInString (ch: char) (s: string) = s.IndexOf(ch) \u0026lt;\u0026gt; -1 let isWs (chr: char) = isInString chr wsChars let isNameChar (chr: char) = not (isInString chr (wsChars + specialChars)) let isSpecialChar ch = isInString ch specialChars wsChar and specialChars are defined below:\nlet wsChars = \" \\t\" let charTokens = Map.ofList [ '.' , Dot '(' , OpenParens ')' , CloseParens '\\\\', Lambda '\\n', NewLine ]\nlet specialChars = charTokens |\u0026gt; Map.fold (fun s k v -\u0026gt; s + k.ToString()) \"\" Getting back to the more important matching functions, matching a special character is defined as a simple lookup in the charToken map:\nlet matchSpecialChar ch chars = Map.find ch charTokens, chars We are left with matchString, this simply matches the characters until it finds a char that cannot be part of a name. It then looks it up in a list of special strings. If it finds it, it returns it, otherwise it just returns the name.\nlet stringTokens = Map.ofList [ \"Def\", Def ] let matchString chars = let value, remainingChars = matchSeriesOfChars isNameChar chars let specialString = Map.tryFind value stringTokens if specialString.IsSome then specialString.Value, remainingChars else Name(value), remainingChars And we are done with the lexer, all of 100+ lines of it …\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-09-02-adventure-in-parserland-parsing-lambda-expressions-in-f-part-iii/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Adventure in parserland – parsing lambda expressions in F# – Part III"},{"categories":["fsharp"],"contents":"The parser starts simple with the following two functions to parse either a string or a file. I use the XXX_Readers_ because I want to lazy read character by character.\nlet parseString s = let reader = new StringReader(s) parseTextReader reader let parseFile fileName = let reader = new StreamReader(fileName: string) parseTextReader reader The whole parser is in the following two lines:\nlet parseTextReader: TextReader -\u0026gt; seq\u0026lt;Expression\u0026gt; = textReaderToLazyList \u0026gt;\u0026gt; tokenStream \u0026gt;\u0026gt; parseExpressions I need to specify the signature otherwise the compiler gets confused : wait, does it take a StringReader or a StreamReader? You better tell me!\nThe function is a composite of three functions applied in sequence:\n Translate a TextReader to a LazyList Translate a LazyList to a LazyList (lexer) Translate a LazyList to a LazyList (parser)  My usage of LazyList as the workhorse for the program is because I want to match on the head of the stream of chars/tokens in a lazy way.\nI love it when a program naturally decomposes in such simple understandable pieces. I impute some of that to functional programming. For one reason or another, in my 15+ years of object oriented programming, I’ve rarely got to the core of a problem with such immediacy.\nA sequence of operations likes the above would be lost in a protected overridden implementation of a base class somewhere (or something else equally long to pronounce). The beauty would be lost somewhere in the vast machinery required to support it.\nIn any case, TextReaderToLazyList is a trivial generator function that uses the unfold function of LazyList to read a character at the time.\nlet textReaderToLazyList textReader = LazyList.unfold (fun (ts:TextReader) -\u0026gt; let ch = ts.Read() if ch = -1 then None else Some(char ch, ts)) textReader The next step is to look at either the lexer, going bottom up, or the parser, going top down.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-08-26-adventure-in-parserland-parsing-lambda-expressions-in-f-part-ii/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Adventure in parserland – parsing lambda expressions in F# – Part II"},{"categories":["fsharp"],"contents":"This is part of my ‘things that I do in the empty spaces between one meeting and the next one, which might end up being vaguely interesting’. It is a lambda expression parser.\nThe full source code is here.\nI actually have two versions of it: one written longhand and the other one written with FParsec. Just to be clear: I’m no expert of either.\nAnd just to be more clear: I think writing most parsers longhand in the way I am about to show is crazy. You either use FParsec or fslex / fsyacc.\nI have a strong distaste for additional compilation steps. I think it lingers on from MFC project types of 15/20 years ago. I was one of these crazy folks that would generate the project, wrap the generated code (with some generalizations) in my own library and use that one from then on.\nSo I prefer FParsec. I’m ok rewriting left recursive rules and its performance has never been a problem for me. Here is a table that compares the different approaches.\nBut I started wondering about coding a a recursive descent parser for a simple grammar by hand, fully knowing the foolishness of the idea. Thanks to Jose for code reviewing it.\nThe inspiration for the grammar comes from this book.\n(* \u0026lt;expression\u0026gt; ::= \u0026lt;name\u0026gt; | \u0026lt;function\u0026gt; | \u0026lt;application\u0026gt; \u0026lt;name\u0026gt; ::= non­blank character sequence \u0026lt;function\u0026gt; ::= \\ \u0026lt;name\u0026gt; . \u0026lt;body\u0026gt; \u0026lt;body\u0026gt; ::= \u0026lt;expression\u0026gt; \u0026lt;application\u0026gt; ::= ( \u0026lt;function expression\u0026gt; \u0026lt;argument expression\u0026gt; ) \u0026lt;function expression\u0026gt; ::= \u0026lt;expression\u0026gt; \u0026lt;argument expression\u0026gt; ::= \u0026lt;expression\u0026gt; *)  In English, an expression is either a name, a function or an application. A name is a bunch of characters (better defined in the code). A function is ‘\\’, a name, ‘.’ and an expression. An application is ‘(‘, an expression, whitespaces, an expression and ‘)’.\nSome testcases for the above grammar and the parsers written to parse it are below. It should be intuitive what this code does just by the name of the functions. Even it isn’t, check that the expressions symbol contains valid productions from the grammar above.\nmodule Test open Microsoft.FSharp.Collections open Xunit open LambdaEngine open Parser open Lexer open FParser let writeTokenStream stream = Seq.fold (fun acc token -\u0026gt; acc + writeToken token) \"\" stream let rec writeExpr = function | EName(s) -\u0026gt; s | Function(expr, body) -\u0026gt; writeToken Lambda + writeExpr expr + writeToken Dot + writeExpr body | Application(funExpr, argExpr) -\u0026gt; writeToken OpenParens + writeExpr funExpr + writeToken (Ws(\" \")) + writeExpr argExpr + writeToken CloseParens | EOT -\u0026gt; \"\" let tokenStreams = [ \"\" \"(\\xs.xs \\y.(y \\x.y))\" \"(\\xst.xst \\y.(y \\x.y))\" \" \" \"x\" \"(x y)\" ] let expressions = [ \"\" \"(\\x.x \\y.(y \\x.y))\" \"x\" \"(x y)\" ] let stringToCharList s = let textReader = new System.IO.StringReader(s) textReaderToLazyList textReader [\u0026lt;Fact\u0026gt;] let testTokenizer () = let testTokenStream s = let stream = tokenStream \u0026lt;| stringToCharList s let s1 = writeTokenStream stream Assert.Equal(s, s1) tokenStreams |\u0026gt; List.iter testTokenStream let testExpr parseFunction s = let exprs = parseFunction s let s1 = exprs |\u0026gt; Seq.fold (fun s expr -\u0026gt; s + writeExpr expr) \"\" Assert.Equal(s, s1) [\u0026lt;Fact\u0026gt;] let testParser () = expressions |\u0026gt; List.iter (testExpr parseString) [\u0026lt;Fact\u0026gt;] let testFParser () = expressions |\u0026gt; List.iter (testExpr fparseString) In the next instalment, we’ll start looking at the real code for the parser.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-08-19-adventure-in-parserland-parsing-lambda-expressions-in-f-part-i/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Adventure in parserland – parsing lambda expressions in F# – Part I"},{"categories":["fsharp"],"contents":"Let’s talk about the environment now. This is the part of the interpreter that I like the least. It is a global variable and it contains a list of (string, LispVal) where the LispVal is mutable.\ntype Env = (string * LispVal ref) list ref This is pretty bad. First of all, it immediately cuts off any option of running interpreters in different threads. Moreover, it makes a lot of functions in the evaluator to have side effects. That makes it much harder to reason about them.\nIn a world where I am provided with infinite time and energy, I would change it. In this world, I won’t. If you try your hand at doing it, make sure that you pass all the testcases before declaring victory. The scope rules of Scheme are not all that obvious. A code reviewer called them the Italian scoping rules because he thought I got them wrong …\nIn any case, there isn’t much to the symbol table management. You can create an empty one:\nlet nullEnv (): Env = ref List.empty Check if a variable is bound:\nlet keyEq name (k, _) = name = k let isBound var (env: Env) = !env |\u0026gt; List.exists (keyEq var) Get a variable out:\nlet getVar var (env: Env) = let result = !env |\u0026gt; List.tryFind (keyEq var) match result with | None -\u0026gt; throw (UnboundVar(\"Getting an unbound variable: \" , var)) | Some(_, r) -\u0026gt; !r Set the value of an existing variable:\nlet setVar var value (env:Env) = let result = !env |\u0026gt; List.tryFind (keyEq var) match result with | Some(_, v) -\u0026gt; v := value ; value | None -\u0026gt; throw (UnboundVar(\"Setting an unbound variable: \" , var)) Or define a new variable in the environment. Note that if the variable already exist, its value gets set.\nlet define (env:Env) var value = let result = !env |\u0026gt; List.tryFind (keyEq var) match result with | Some(_, v) -\u0026gt; v := value ; value | None -\u0026gt; env := [var, ref value] @ !env; value You can also bind a list of (string, LispVal) to the environment by prepending it to the existing ones: let bindVars bindings (env:Env) = ref ((bindings |\u0026gt; List.map (fun (n, v) -\u0026gt; n , ref v)) @ !env) Once you accept the evil of the global mutable variable scheme, these functions are easy enough.\nThe only piece left is error management. This is where my implementation differs from the Haskell version the most. In essence, I throw exception and catch them to report errors, while the Haskell version uses a monad to propagate the error information.\nI have a LispError that represents everything that can go wrong:\ntype LispError = | NumArgs of int * LispVal list | TypeMismatch of string * LispVal | ParseError of string * FParsec.Error.ParserError | BadSpecialForm of string * LispVal | NotFunction of string * string | UnboundVar of string * string | Default of string | IOError of string I wrap it in an exception:\nexception LispException of LispError This is what I throw in various places in the code.\nlet throw le = raise (LispException(le)) I then catch it at the outer layer:\nlet evalString env expr = try expr |\u0026gt; readExpr |\u0026gt; eval env with | LispException(error) -\u0026gt; String (showError error) And display the error by using the below function:\nlet showError = function | NumArgs(expected, found) -\u0026gt; \"Expected \" + expected.ToString() + \" args; found values \" + unwordsList found | TypeMismatch(expected, found) -\u0026gt; \"Invalid type: expected \" + expected + \", found \" + showVal found | ParseError(msg, _) -\u0026gt; \"Parse Errror\" + msg | BadSpecialForm(message, form) -\u0026gt; message + showVal form | NotFunction(message, func) -\u0026gt; message + func | UnboundVar(message, varName) -\u0026gt; message + varName | Default(message) -\u0026gt; message | IOError(message) -\u0026gt; message And that’s all there is to it. I hope you guys and gals enjoyed this seven part extravagance. Cheers.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-08-12-write-yourself-a-scheme-in-48-hours-in-f-part-vii/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Write Yourself a Scheme in 48 Hours in F# – Part VII"},{"categories":["fsharp"],"contents":"The evaluator takes as an input a LispVal. Where does it come from? There must be something that converts your textual input into it. That is the job of the parser.\nI have used FParsec to build my parser. FParsec is a fantastic library to build parsers. It is a perfect showcase of the composition potential that functional code yields. When you write an FParsec parser you compose many little parsers to create the one parser that works for your language. The resulting code looks very much like your language grammar, but you don’t need a separate code generation compilation step to produce it.\nThere is one element of ugliness in the syntax to create recursive parsers. You need to define two global variables that can be referred to before they are constructed. This is an artefact of how F# works. So you need a line in your code that looks like this:\nlet parseExpr, parseExprRef : LispParser * LispParser ref = createParserForwardedToRef() With that piece of machinery out of the way, we can focus on the parser itself. Our goal here is to parse expressions and generate LispVal. We need a LispParser like the below (the second generic parameter is for advanced usage).\ntype LispParser = Parser\u0026lt;LispVal, unit\u0026gt; We need to parse all the kind of expressions that the user can type. Notice in the below the use of a computation expression to simplify the syntax. Also note that lists and dotted lists look very much the same until you encounter the ‘.’ character. You could disambiguate the situation by extracting out the commonality in a separate kind of expression. I decided instead to instruct the parser to backtrack if it gets it wrong (attempt). This is slower, but keeps the code identical to our conceptual model. I value that greatly.\ndo parseExprRef := parseAtom \u0026lt;|\u0026gt; parseString \u0026lt;|\u0026gt; parseNumber \u0026lt;|\u0026gt; parseQuoted \u0026lt;|\u0026gt; parse { do! chr '(' let! x = (attempt parseList) \u0026lt;|\u0026gt; parseDottedList do! chr ')' return x } Let’s start from the top. Parsing an atom means parsing something that starts with a letter or symbol and continues with letters, symbols or digits. Also “#t” and “#f” can be resolved at parsing time.\nlet parseAtom : LispParser = parse { let! first = letter \u0026lt;|\u0026gt; symbol let! rest = manyChars (letter \u0026lt;|\u0026gt; symbol \u0026lt;|\u0026gt; digit) return match first.ToString() + rest with | \"#t\" -\u0026gt; Bool true | \"#f\" -\u0026gt; Bool false | atom -\u0026gt; Atom atom } A string is just a bunch of chars (except ‘\\’) surrounded by ‘ ” ’.\nlet parseString : LispParser = parse { do! chr '\"' let! xs = manyChars (noneOf \"\\\"\") do! chr '\"' return String(xs) } A number is just one or more digits. I am afraid we just support integers at this stage …\nlet parseNumber : LispParser = many1Chars digit |\u0026gt;\u0026gt; (System.Int32.Parse \u0026gt;\u0026gt; Number) A quoted expression is jut a ‘\\’ followed by an expression.\nlet parseQuoted : LispParser = chr '\\'' \u0026gt;\u0026gt;. parseExpr |\u0026gt;\u0026gt; fun expr -\u0026gt; List [Atom \"quote\"; expr]  A list is just a bunch of expressions separate by at least one space.\nlet parseList : LispParser = sepBy parseExpr spaces1 |\u0026gt;\u0026gt; List A dotted list starts in the same way (hence the backtracking above), but then has a dot, one or more spaces and an expression.\nlet parseDottedList : LispParser = parse { let! head = endBy parseExpr spaces1 let! tail = chr '.' \u0026gt;\u0026gt;. spaces1 \u0026gt;\u0026gt;. parseExpr return DottedList (head, tail) } And here are a bunch of functions used throughout the code, presented here for completeness.\nlet spaces1 : LispParser\u0026lt;unit\u0026gt; = skipMany1 whitespace let chr c = skipChar c let endBy p sep = many (p .\u0026gt;\u0026gt; sep) let symbol : LispParser\u0026lt;char\u0026gt; = anyOf \"!$%\u0026|*+-/:\u0026lt;=\u0026gt;?@^_~#\"  This is all the code you need to translate text to a LispVal to feed the evaluator. That is pretty impressive.\nThere is also a function to go the other way, from a LispVal to text. It is used in implementing the testcases and to print out diagnostics.\nlet rec showVal = function | String contents -\u0026gt; \"\\\"\" + contents + \"\\\"\" | Atom name -\u0026gt; name | Number num -\u0026gt; num.ToString() | Bool t -\u0026gt; if t then \"#t\" else \"#f\" | List l -\u0026gt; \"(\" + unwordsList l + \")\" | DottedList (head, tail) -\u0026gt; \"(\" + unwordsList head + \" . \" + showVal tail + \")\" | PrimitiveFunc(_) -\u0026gt; \"\u0026lt;primitive\u0026gt;\" | Port (_) -\u0026gt; \"\u0026lt;IO port\u0026gt;\" | Func({ parms = parms; varargs = varargs; body = body; closure = closure }) -\u0026gt; \"(lambda (\" + unwordsList (parms |\u0026gt; List.map (String)) + (match varargs with | None -\u0026gt; \"\" | Some(arg) -\u0026gt; \" . \" + arg) + \") ...)\" and unwordsList = List.map showVal \u0026gt;\u0026gt; String.concat \" \"  ","permalink":"https://peaceiris.com/MyBlog/posts/2011-08-05-write-yourself-a-scheme-in-48-hours-in-f-part-vi/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Write Yourself a Scheme in 48 Hours in F# – Part VI"},{"categories":["fsharp"],"contents":"We have one loose end to tie in the evaluator: the primitive operators. These are things that the interpreter knows intrinsically. There is a list of them below.\nlet rec primitives = [ \"+\", numericBinop (+) \"-\", numericBinop (-) \"*\", numericBinop (*) \"/\", numericBinop (/) \"mod\", numericBinop (%) \"=\", numBoolBinop (=) \"\u0026lt;\", numBoolBinop (\u0026lt;) \"\u0026gt;\", numBoolBinop (\u0026gt;) \"/=\", numBoolBinop (\u0026lt;\u0026gt;) \"\u0026gt;=\", numBoolBinop (\u0026gt;=) \"\u0026lt;=\", numBoolBinop (\u0026lt;=) \"\u0026\u0026\", boolBoolBinop (\u0026\u0026) \"||\", boolBoolBinop (||) \"string=?\", strBoolBinop (=) \"string\u0026gt;?\", strBoolBinop (\u0026gt;) \"string\u0026lt;?\", strBoolBinop (\u0026lt;) \"string\u0026lt;=?\", strBoolBinop (\u0026lt;=) \"string\u0026gt;=?\", strBoolBinop (\u0026gt;=) \"car\", car \"cdr\", cdr \"cons\", cons \"eq?\", eqv \"eqv?\", eqv \"equal?\", equal // IO primitives \"apply\", applyProc \"open-input-file\", makePort FileAccess.Read \"open-output-file\", makePort FileAccess.Write \"close-input-port\", closePort \"close-output-port\", closePort \"read\", readProc \"write\", writeProc \"read-contents\", readContents \"read-all\", readAll ] Having seen the above list, it now becomes clearer why the primitiveBindings function was defined as such. It just binds these pairs into the environment.\nlet primitiveBindings () = (nullEnv ()) |\u0026gt; bindVars [ for v, f in primitives -\u0026gt; v, PrimitiveFunc f ]  numericBinop unpacks the numbers, applies the provided operator and packs the result back in the Number.\nlet numericBinop op parms = if List.length parms \u0026lt; 2 then throw \u0026lt;| NumArgs(2, parms) else parms |\u0026gt; List.map unpackNum |\u0026gt; foldl1 op |\u0026gt; Number While we are at it, we can define _fold1 (_it tends to be useful)\nlet foldl1 op = function | h::t -\u0026gt; List.fold op h t | [] -\u0026gt; throw (Default(\"Expected a not empty list, got an empty list\")) The other XBinops work similarly …\nlet boolBinop unpacker op args = match args with | [ left; right ] -\u0026gt; Bool (op (unpacker left) (unpacker right)) | _ -\u0026gt; throw (NumArgs(2,args)) let numBoolBinop = boolBinop unpackNum let strBoolBinop = boolBinop unpackStr let boolBoolBinop = boolBinop unpackBool We now have to look at the family of unpackers. They all work rather similarly. Notice Scheme making an effort to get a number out of a string and to get anything out of a list. Strong type folks won’t like that. Oh well, just remove these lines …\nlet rec unpackNum = function | Number n -\u0026gt; n | String n -\u0026gt; let success, result = System.Int32.TryParse n if success then result else throw (TypeMismatch(\"number\", String n)) | List [n] -\u0026gt; unpackNum n | notNumber -\u0026gt; throw (TypeMismatch(\"number\", notNumber)) let rec unpackStr = function | String s -\u0026gt; s | Number n -\u0026gt; n.ToString() | Bool b -\u0026gt; b.ToString() | List [s] -\u0026gt; unpackStr s | noString -\u0026gt; throw (TypeMismatch(\"string\", noString)) let rec unpackBool = function | Bool b -\u0026gt; b | List [b] -\u0026gt; unpackBool b | noBool -\u0026gt; throw (TypeMismatch(\"boolean\", noBool)) Now back to the list of primitive operators, there are the signature LISP operators car, cdr and cons. Just understanding the first line for each function should be enough to get an idea of what they do.\nlet car = function | [List (x :: _)] -\u0026gt; x | [DottedList (x :: _, _)] -\u0026gt; x | [badArg] -\u0026gt; throw (TypeMismatch(\"pair\", badArg)) | badArgList -\u0026gt; throw (NumArgs(1, badArgList)) let cdr = function | [List (x :: xs)] -\u0026gt; List xs | [DottedList ([xs], x)] -\u0026gt; x | [DottedList ((_ :: xs), x)] -\u0026gt; DottedList (xs, x) | [badArg] -\u0026gt; throw (TypeMismatch(\"pair\", badArg)) | badArgList -\u0026gt; throw (NumArgs(1, badArgList)) let cons = function | [x; List xs] -\u0026gt; List (x :: xs) | [x; DottedList (xs, xlast)] -\u0026gt; DottedList (x :: xs, xlast) | [x1; x2] -\u0026gt; DottedList([x1], x2) | badArgList -\u0026gt; throw (NumArgs(2, badArgList)) We then need to work our way to implement eqv (aka eq? in Scheme). We first define a function that tests that two LispVal are the same. It should be pretty self explanatory (the list piece is kind of cute).\nlet rec eqvPrim e1 e2 = match e1, e2 with | (Bool b1, Bool b2) -\u0026gt; b1 = b2 | (Number n1, Number n2) -\u0026gt; n1 = n2 | (String s1, String s2) -\u0026gt; s1 = s2 | (Atom a1, Atom a2) -\u0026gt; a1 = a2 | (DottedList (xs, x), DottedList(ys, y)) -\u0026gt; eqvPrim (List (xs @ [x])) (List (ys @ [y])) | (List l1, List l2) -\u0026gt; l1.Length = l2.Length \u0026\u0026 List.forall2 eqvPrim l1 l2 | _ -\u0026gt; false  Now we wrap the result in a Bool. Doing it this way avoid repeating the wrapping in each single line of eqvPrim (thanks to Tobias for spotting this refactoring).\nlet eqv = function | [e1; e2] -\u0026gt; Bool (eqvPrim e1 e2) | badArgList -\u0026gt; throw (NumArgs (2, badArgList)) Equal? checks if there is any unpacking scheme that can be used to test equality of the two elements of a two element list.\nlet equal = function | [arg1; arg2] -\u0026gt; let unpackEqual = numUnpackEq arg1 arg2 || strUnpackEq arg1 arg2 || boolUnpackEq arg1 arg2 Bool (eqvPrim arg1 arg2 || unpackEqual) | argsList -\u0026gt; throw (NumArgs(2, argsList)) We need to define equality of packed primitive types. We do it nicely below.\nlet tryUnpacker (unpack : LispVal -\u0026gt; 'a) (op : 'a -\u0026gt; 'a -\u0026gt; bool) arg1 arg2 = try op (unpack arg1) (unpack arg2) with _ -\u0026gt; false let numUnpackEq = tryUnpacker unpackNum (=) let strUnpackEq = tryUnpacker unpackStr (=) let boolUnpackEq = tryUnpacker unpackBool (=) The apply statement maps more or less directly to our apply function.\napplyProc = function | [func; List args] -\u0026gt; apply func args | func :: args -\u0026gt; apply func args | [] -\u0026gt; throw (Default(\"Expecting a function, got an empty list\")) And we are left with the I/O processing functions. We are simply wrapping a FileStream in a Port.\nlet makePort fileAccess = fileIOFunction (fun fileName -\u0026gt; File.Open(fileName,FileMode.OpenOrCreate, fileAccess) |\u0026gt; Port) let closePort = function | [Port(port)] -\u0026gt; port.Close() ; Bool true | _ -\u0026gt; Bool false  We then can read and write from it. Notice how the lack of arguments makes us do it from the standard Console.\nlet rec readProc port = let parseReader (reader:TextReader) = reader.ReadLine() |\u0026gt; readExpr match port with | [] -\u0026gt; parseReader(System.Console.In) | [Port(port)] -\u0026gt; use reader = new StreamReader(port) parseReader (reader) | args -\u0026gt; throw (NumArgs(1, args)) let writeProc objPort = let write obj (writer: TextWriter) = writer.Write(showVal obj) ; Bool true match objPort with | [obj] -\u0026gt; write obj (System.Console.Out) | [obj ; Port(port)] -\u0026gt; use writer = new StreamWriter(port) write obj writer | args -\u0026gt; throw (NumArgs(1, args)) There you go. A full evaluator in two blog posts!! Next up, the parser.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-07-29-write-yourself-a-scheme-in-48-hours-part-iv-2/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Write Yourself a Scheme in 48 Hours in F# – Part V"},{"categories":["fsharp"],"contents":"It is the evaluator turn. It is a big file, let’s see if I can fit it in a single post.\nAptly enough, the most important function is called eval.\neval env = function | String _ as v -\u0026gt; v | Number _ as v -\u0026gt; v | Bool _ as v -\u0026gt; v | Atom var -\u0026gt; getVar var env | List [Atom \"quote\"; v] -\u0026gt; v | List [Atom \"if\"; pred; conseq; alt] -\u0026gt; evalIf env pred conseq alt | List [Atom \"load\"; fileName] -\u0026gt; load [fileName] |\u0026gt; List.map (eval env) |\u0026gt; last | List [Atom \"set!\" ; Atom var ; form] -\u0026gt; env |\u0026gt; setVar var (eval env form) | List [Atom \"define\"; Atom var; form] -\u0026gt; define env var (eval env form) | List (Atom \"define\" :: (List (Atom var :: parms) :: body)) -\u0026gt; makeNormalFunc env parms body |\u0026gt; define env var | List (Atom \"define\" :: (DottedList ((Atom var :: parms), varargs) :: body)) -\u0026gt; makeVarargs varargs env parms body |\u0026gt; define env var | List (Atom \"lambda\" :: (List parms :: body)) -\u0026gt; makeNormalFunc env parms body | List (Atom \"lambda\" :: (DottedList(parms, varargs) :: body)) -\u0026gt; makeVarargs varargs env parms body | List (Atom \"lambda\" :: ((Atom _) as varargs :: body)) -\u0026gt; makeVarargs varargs env [] body | List (func :: args) -\u0026gt; let f = eval env func let argVals = List.map (eval env) args apply f argVals | badForm -\u0026gt; throw (BadSpecialForm(\"Unrecognized special form\", badForm)) This is the core of the evaluator. It takes as an input the LispVal generated by the parser and an environment and returns a LispVal that is the result of the reduction. As a side effect, it occasionally modify the environment. I carefully crafted the previous phrase to maximize the discomfort of the functional programmers tuned in. Such fun 🙂\nMore seriously (?), here is what it does:\n If it is a String, Number of Bool, just return it If it is an Atom, return its value If it is a quote statement, return what is quoted (read your little schemer manual) If it is an if statement, evaluate it (see below) If it is a load statement, load the file (see below) and evaluate each expression using the current environment. Return the last expression in the file If it is a set!, set the value of the passed variable to the evaluated form If it is a define, do almost the same as above (except that you don’t throw if the variable doesn’t exist, but you create it) If it is a define that defines a function (it has that shape), create a ‘function slot’ in the environment. That is a (functionName, FuncRecord) pair (see below) If it is a lambda, return the FuncRecord that describe the inline function If it is a function call, evaluate the expression that describe the function (yes, you can do that in Lisp!!), evaluate the arguments, and apply the function to the arguments Otherwise, it must be a bad form, throw it back to the calling function to do something meaningful with it  We have a bunch of ‘see below’ to take care of. We’ll look at them in order.\nFirst the ‘if’ statement. If the evaluated predicate is Bool(True) evaluate the consequent, otherwise evaluate the alternative. For some reason, I wrote it the other way around.\nand // 1a. If the evaluation of the pred is false evaluate alt, else evaluate cons evalIf env pred conseq alt = match eval env pred with | Bool(false) -\u0026gt; eval env alt | _ -\u0026gt; eval env conseq Then there is the load function. It reads all the test and gets out the list of LispVal contained in it.\nlet load = fileIOFunction (fun fileName -\u0026gt; File.ReadAllText(fileName) |\u0026gt; readExprList) ReadExprList is part of the parser. We’ll look at it then. Sufficient here to say that it takes a string and returns a list of LispVal.\nFileIOFunction just encapsulates a common pattern in all the file access functions. I don’t like such mechanical factorization of methods, without any real reusability outside the immediate surroundings of the code. But I like repetition even less.\nlet fileIOFunction func = function | [String fileName] -\u0026gt; func (fileName) | [] -\u0026gt; throw (IOError(\"No file name\")) | args -\u0026gt; throw (NumArgs(1, args)) A family of functions create FuncRecord given appropriate parameters. I seem to have lost memory of the contortions related to the last one. If I end up having to work again on this code, I’ll need to figure it out again. Note to myself, please comment this kind of code next time.\nlet makeFunc varargs env parms body = Func ({parms = (List.map showVal parms); varargs = varargs; body = body; closure = env}) let makeNormalFunc = makeFunc None let makeVarargs = showVal \u0026gt;\u0026gt; Some \u0026gt;\u0026gt; makeFunc apply is the other workhorse function in the evaluator. The best way to understand it is to start from the bottom (where bindVars starts the line). We are binding the arguments and the variable arguments in the closure that has been passed in. We then evaluate the body. But the body is just a list of LispVal, so we just need to evaluate them in sequence and return the result of the last one.\nand apply func args = match func with | PrimitiveFunc(f) -\u0026gt; f args | Func ({parms = parms; varargs = varargs; body = body; closure = closure}) -\u0026gt; let invalidNonVarargs = args.Length \u0026lt;\u0026gt; parms.Length \u0026\u0026 varargs.IsNone let invalidVarargs = args.Length \u0026lt; parms.Length \u0026\u0026 varargs.IsSome if invalidVarargs || invalidNonVarargs then throw (NumArgs(parms.Length, args)) else let remainingArgs = args |\u0026gt; Seq.skip parms.Length |\u0026gt; Seq.toList let evalBody env = body |\u0026gt; List.map (eval env) |\u0026gt; last let rec zip xs1 xs2 acc = match xs1, xs2 with | x1::xs1, x2::xs2 -\u0026gt; zip xs1 xs2 ((x1, x2)::acc) | _ -\u0026gt; acc let bindVarArgs arg env = match arg with | Some(argName) -\u0026gt; bindVars [argName, (List remainingArgs)] env | None -\u0026gt; env bindVars (zip parms args []) closure |\u0026gt; bindVarArgs varargs |\u0026gt; evalBody | funcName -\u0026gt; throw (NotFunction(\"Expecting a function, getting \", showVal funcName)) This is enough for one post. Next time we’ll finish the evaluator.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-07-22-write-yourself-a-scheme-in-48-hours-part-iv/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Write Yourself a Scheme in 48 Hours in F# – Part IV"},{"categories":["fsharp"],"contents":"Very often my code ends up having the following form: parse an input to create an intermediate data structure and evaluate the structure to produce an output. Strangely, many years ago, when my code was object oriented, that wasn’t the case. Or at least I wasn’t explicitly aware of it.\nWhen you write an interpreter or a compiler, things always work out like that, but I see the same pattern in almost everything I produce: from financial backtesting to chart libraries. Sometimes when, out of laziness or stupidity, I forego the intermediate structure, I end up in the end having to retrofit it in. Simply processing input and generating output at the same time rarely cuts it. But it is tempting because you get going pretty fast and I’m tricked into it occasionally.\nHence the first thing that I find myself reasoning about is often the particular form of such intermediate structure. In this case it looks like the following:\ntype Env = (string * LispVal ref) list ref and FuncRecord = { parms: string list; varargs: string option; body: LispVal list; closure: Env} and LispVal = | Atom of string | List of LispVal list | DottedList of LispVal list * LispVal | Number of int | String of string | Bool of bool | PrimitiveFunc of (LispVal list -\u0026gt; LispVal) | Func of FuncRecord | Port of System.IO.FileStream This LispVal structure has one constructor for each kind of expression (production) that is allowed in Scheme. Or at least that ones I support …\nIt is important that each one stores all the information that is necessary for the evaluator to evaluate the expression. No more, no less. Here is a brief description:\n Atom: it is a kind of a constant in Scheme. This is probably the worst definition ever given for it. Please read about it in your little schemer book. List: is the main Scheme type. It represents a list of expressions. DottedList: this is the bizarre Scheme way to pass optional parameters Number: is a number 🙂 You will discover which kind of number when we talk about the parser String : is a string Bool: #t, #f PrimitiveFunc: is the representation for the primitive operators/functions that are burned into the interpreter. It is just a function that takes a list of LispVal and returns a LispVal Func: is a user defined function. Notice that the body of it is simply a list of LispVal. This is why LISP is so powerful. Also notice that a closure gets passed to it for the ‘captured’ variables. Port: is a slightly goofy representation of an in/out stream Anything else (i.e. macros) is not supported, but this would be the first piece to change if they were.  The only remaining code to address is:\ntype Env = (string * LispVal ref) list ref\nThis is the symbol table and it is ugly. It is not multithread safe either. But it works and it is close enough to the Haskell version so I decided to retain it. A proper code review would ‘strongly suggest’ rewriting the code to pass it around to each function instead of using ‘ref’ or using the state monad encapsulated in a computation expression. Any of these solutions is left as an exercise to the reader (use the testcases to validate that you get it right).\nWe could go in many different direction from here. We could talk about:\n The evaluator The parser The symbol table Error handling  To keep with the top – down approach I’ve been espousing. I’ll probably talk about the evaluator next.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-07-15-write-yourself-a-scheme-in-48-hours-in-f-part-iii/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Write Yourself a Scheme in 48 Hours in F# – Part III"},{"categories":["fsharp"],"contents":"Usually, when I do blog posts that are all about code, I write them ‘bottom up’. I start talking about the most primitive types and functions and build up from there toward higher abstractions. I think this is a pretty common way of doing it.\nFor this series I’m going to try the opposite. I start with the code that creates the REPL window and move down from there toward the guts of the interpreter. I hold the opinion that, if the code is written right, this should be ok. The naming scheme and general structure of it should allow understanding it at different levels.\nOr at least I hope so.\nLet’s start from the main function. Depending on the number of arguments it either runs the REPL window or executes whatever is in the file passed in as the first argument using the other arguments as parameters.\n[\u0026lt;EntryPoint\u0026gt;] let main(args: string[]) = match Array.toList args with | [] -\u0026gt; runRepl () | filename :: args -\u0026gt; runOne filename args 0 The latter case is coded in the below function. It first load all the primitive operators (i.e. ‘+’, ‘-‘ etc…) and the standard library. The word ‘load’ above is a little misleading. In reality it adds them to the environment. It then proceeds to add the arguments that were passed on. As the last step, it evaluates the ‘load’ command by using the newly created environment, it transforms the returned token to a string and prints it.\nlet runOne (filename : string) (args : list\u0026lt;string\u0026gt;) = let env = primitiveBindings () |\u0026gt; loadStdLib |\u0026gt; bindVars [ \"args\", List (List.map String args) ] List [Atom \"load\"; String filename] |\u0026gt; eval env |\u0026gt; showVal |\u0026gt; printStr Running the REPL windows is equally simple. Load the primitive operators and the standard library, show a prompt and evaluate the input until the input is ‘Quit’.\nlet runRepl () = let env = primitiveBindings () |\u0026gt; loadStdLib until (fun s -\u0026gt; s = \"Quit\" || s = \"quit\") (fun () -\u0026gt; readPrompt \"Lisp\u0026gt;\u0026gt;\u0026gt; \") (evalAndPrint env) readPrompt is pretty simple:\nlet printStr (s: string) = Console.Write(s) let readPrompt (s: string) = printStr s ; Console.ReadLine () EvalAndPrint is written as a chain of functions (lookup the ‘\u0026raquo;’ operator in F#) and just evaluate the string, transform the result to a string, prints it and newline it.\nlet newLine () = Console.WriteLine() let evalAndPrint env = evalString env \u0026gt;\u0026gt; showVal \u0026gt;\u0026gt; printStr \u0026gt;\u0026gt; newLine evalString parses the string and evaluates the expression. Note the exception management. This is a result of my decision of throwing an exception every time something goes wrong instead of using a monad to pass the state around. I think it is pretty clear, but haskellers might disagre. This is one of the main differences from the Haskell version.\nlet evalString env expr = try expr |\u0026gt; readExpr |\u0026gt; eval env with | LispException(error) -\u0026gt; String (showError error) For the sake of completeness, here is until. Maybe there is a library function somewhere that I could have used?\nlet rec until pred prompter evaluator = let result = prompter () if not (pred result) then evaluator result until pred prompter evaluator Back on the main flow of the code, loadStdLib just loads the standard file and returns the populated environment.\nlet loadStdLib env = eval env (List [Atom \"load\"; String \"stdlib.scm\"]) |\u0026gt; ignore env primitiveBindings creates a new empty environment and adds a bunch of pairs (primitiveName, LispVal –\u0026gt; LispVal). LispVal is a representation of a Scheme expression, so the second part of the tuple is simply a reduction from one expression to another (hopefully simpler in some sense). We’ll talk more about LispVal in upcoming posts.\nlet primitiveBindings () = (nullEnv ()) |\u0026gt; bindVars [ for v, f in primitives -\u0026gt; v, PrimitiveFunc f ]  There you have it. That’s the full implementation for the REPL window. Next post, we’ll look at LispEval and the evaluator.\n","permalink":"https://peaceiris.com/MyBlog/posts/2011-07-08-write-yourself-a-scheme-in-48-hours-in-f-part-ii/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Write Yourself a Scheme in 48 Hours in F# – Part II"},{"categories":["fsharp"],"contents":"Hi, I’m back. I’ve finally sorted out the guidelines for blogging in Credit Suisse.\nHere is something I have been playing around with in the spare time between one meeting and the next one. It is a Scheme interpreter that includes a REPL window. The full code is here.\nAll the smarts for it come from this Wiki Book. I just ported the code to F# (and modified it a bit). I thought the comparison might be interesting, so here we go. Thanks to Tobias and Jose for reviewing the code, find one bug and suggest improvements.\nBefore we start looking at the real code, here is what we are trying to accomplish in form of test cases. If you are a bit rusty on LISP syntax, you might want to try and see if you understand what it does.\nOur goal is to make all this XUnit test cases pass. Each of the lists below contains the Scheme statement and the result to display in the REPL window.\nopen Xunit open Lisp.Repl open Lisp.Parser open Lisp.SymbolTable let eval env = evalString env \u0026gt;\u0026gt; showVal let initEnv () = primitiveBindings () |\u0026gt; loadStdLib let test tests = let env = initEnv () tests |\u0026gt; List.iter (fun (expr, result) -\u0026gt; Assert.Equal(result, eval env expr)) [\u0026lt;Fact\u0026gt;] let simpleEval() = let tests = [ \"(+ 2 2)\", \"4\" \"(+ 2 (- 4 1))\", \"5\" \"(- (+ 4 6 3) 3 5 2)\", \"3\" ] test tests [\u0026lt;Fact\u0026gt;] let errorCheck() = let tests = [ \"(+ 2 \\\"two\\\")\", \"\\\"Invalid type: expected number, found \\\"two\\\"\\\"\" \"(+ 2)\", \"\\\"Expected 2 args; found values 2\\\"\" \"(what? 2)\", \"\\\"Getting an unbound variable: what?\\\"\" ] test tests [\u0026lt;Fact\u0026gt;] let moreEval() = let tests = [ \"(\u0026lt; 2 3)\", \"#t\" \"(\u0026gt; 2 3)\", \"#f\" \"(\u0026gt;= 3 3)\", \"#t\" \"(string=? \\\"test\\\" \\\"test\\\")\", \"#t\" \"(string=? \\\"abcd\\\" \\\"dsft\\\")\", \"#f\" \"(if (\u0026gt; 2 3) \\\"no\\\" \\\"yes\\\")\", \"\\\"yes\\\"\" \"(if (= 3 3) (+ 2 3 (- 5 1)) \\\"unequal\\\")\", \"9\" \"(cdr '(a simple test))\", \"(simple test)\" \"(car (cdr '(a simple test)))\", \"simple\" \"(car '((this is) a test))\", \"(this is)\" \"(cons '(this is) 'test)\", \"((this is) . test)\" \"(cons '(this is) '())\", \"((this is))\" \"(eqv? 1 3)\", \"#f\" \"(eqv? 3 3)\", \"#t\" \"(eqv? 'atom 'atom)\", \"#t\" ] test tests [\u0026lt;Fact\u0026gt;] let assignement() = let tests = [ \"(define x 3)\", \"3\" \"(+ x 2)\", \"5\" \"(+ y 2)\", \"\\\"Getting an unbound variable: y\\\"\" \"(define y 5)\", \"5\" \"(+ x (- y 2))\", \"6\" \"(define str \\\"A string\\\")\", \"\\\"A string\\\"\" \"(\u0026lt; str \\\"The string\\\")\", \"\\\"Invalid type: expected number, found \\\"A string\\\"\\\"\" \"(string\u0026lt;? str \\\"The string\\\")\", \"#t\" ] test tests [\u0026lt;Fact\u0026gt;] let closure() = let tests = [ \"(define (f x y) (+ x y))\", \"(lambda (\\\"x\\\" \\\"y\\\") ...)\" \"(f 1 2)\", \"3\" \"(f 1 2 3)\", \"\\\"Expected 2 args; found values 1 2 3\\\"\" \"(define (factorial x) (if (= x 1) 1 (* x (factorial (- x 1)))))\", \"(lambda (\\\"x\\\") ...)\" \"(factorial 10)\", \"3628800\" \"(define (counter inc) (lambda (x) (set! inc (+ x inc)) inc))\", \"(lambda (\\\"inc\\\") ...)\" \"(define my-count (counter 5))\", \"(lambda (\\\"x\\\") ...)\" \"(my-count 3)\", \"8\" \"(my-count 6)\", \"14\" \"(my-count 5)\", \"19\" ] test tests [\u0026lt;Fact\u0026gt;] let predefinedFunctions() = let tests = [ \"(map (curry + 2) '(1 2 3 4))\", \"(3 4 5 6)\" \"(filter even? '(1 2 3 4))\", \"(2 4)\" ] test tests [\u0026lt;Fact\u0026gt;] let varargsCountCheck() = let tests = [ \"(define (sum x y . lst) (fold + (* x y) lst))\", \"(lambda (\\\"x\\\" \\\"y\\\" . lst) ...)\" \"(sum 1 2 3)\", \"5\" \"(sum 1 1 1)\", \"2\" \"(sum 1 2)\", \"2\" \"(sum 1)\", \"\\\"Expected 2 args; found values 1\\\"\" ] test tests ","permalink":"https://peaceiris.com/MyBlog/posts/2011-06-30-write-yourself-a-scheme-in-48-hours-in-f-part-i/","tags":["fsharp","Lambda expressions","Parsing"],"title":"Write Yourself a Scheme in 48 Hours in F# – Part I"},{"categories":["fsharp"],"contents":"Yep, here is my interview with the Deep Fried Bytes guys on various software topics. Enjoy.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-03-31-i-have-been-deep-fried/","tags":["Miscellanea"],"title":"I have been DEEP FRIED!"},{"categories":["fsharp"],"contents":"I wanted to experiment with MVVM and WPF in F#, so I decided to create a little graphical interface for the csv file that drives the spread tracking application. When I started I thought I needed some kind of a grid with Submit/Cancel buttons, but the more I thought about it, the more I realized that I wouldn’t need them.\nSee, I’ve always be one to complain about our current paradigm of Open File / Close File / Save File arguing that the user shouldn’t know about an entity called ‘file’. He shouldn’t be exposed to the fact that the application is just an in-memory copy of an hard disk artifact. His mental model should simply be: I open a document, I work on it, I close it, if needed I can make a copy; if I have problems I can revert to a previous version of the same document; If I make an error I can use ‘undo’ to revert it. There are no files/save/submit/cancel in such paradigm. There is no file system.\nOn the technical side I wanted to experiment with MVVM, even if in this case, the paradigm is overkilled (can really use this word?), given the simplicity of the application.\nIn any case, the ViewModel is in F#. It uses two utility classes:\n// TODO: refactor to remove code repetition below [\u0026lt;AbstractClass\u0026gt;] type ViewModelBase () = let propertyChanged = new Event\u0026lt;PropertyChangedEventHandler, PropertyChangedEventArgs\u0026gt;() interface INotifyPropertyChanged with [\u0026lt;CLIEvent\u0026gt;] member this.PropertyChanged = propertyChanged.Publish member internal this.RaisePropertyChangedEvent(propertyName:string) = if not(propertyName = null) then let e = new PropertyChangedEventArgs(propertyName) let i = this :\u0026gt; INotifyPropertyChanged propertyChanged.Trigger(this, e) type ObservableCollectionWithChanges\u0026lt;'a when 'a :\u0026gt; INotifyPropertyChanged\u0026gt; () = inherit ObservableCollection\u0026lt;'a\u0026gt; () let propertyChanged = new Event\u0026lt;PropertyChangedEventHandler, PropertyChangedEventArgs\u0026gt;() member c.PropertyChanged = propertyChanged.Publish member private c.RaisePropertyChangedEvent(propertyName:string) = if not(propertyName = null) then let e = new PropertyChangedEventArgs(propertyName) let i = c :\u0026gt; INotifyPropertyChanged propertyChanged.Trigger(c, e) member c.Add(o) = base.Add(o) o.PropertyChanged.Add(fun x -\u0026gt; c.RaisePropertyChangedEvent(\"\")) The first one is used as a base for all the viewmodel entities in the application, the second one serves as the base for all the collections. They both define the customary PropertyChanged event. The latter adds itself as an observer to each object added to the collection so that, whenever one changes, it gets notified and can notify its own observers. Look at the c.Add method. A lot of repetitive code here, I would heed the advice of the comment on top if this were production code.\nEach line in the csv file is represented as a ResultViewModel, hence the following:\ntype ResultViewModel (d:DateTime, sLong, sShort, tStop) = inherit ViewModelBase () let mutable date = d let mutable stockLong = sLong let mutable stockShort = sShort let mutable trailingStop = tStop new () = new ResultViewModel(DateTime.Today, \"\", \"\", 0) member r.Date with get() = date and set newValue = date \u0026lt;- newValue base.RaisePropertyChangedEvent(\"Date\") member r.StockLong with get() = stockLong and set newValue = stockLong \u0026lt;- newValue base.RaisePropertyChangedEvent(\"StockLong\") member r.StockShort with get() = stockShort and set newValue = stockShort \u0026lt;- newValue base.RaisePropertyChangedEvent(\"StockShort\") member r.TrailingStop with get() = trailingStop and set newValue = trailingStop \u0026lt;- newValue base.RaisePropertyChangedEvent(\"TrailingStop\") member r.IsThereAnError = r.TrailingStop \u0026lt; 0 || r.TrailingStop \u0026gt; 100 I need the empty constructor to be able to hook up to the DataGrid add-new capability. There might be an event I could use instead, but this is simple enough (even if a bit goofy).\nThe main view model class then looks like the following:\ntype MainViewModel (fileName:string) as self = inherit ViewModelBase () let mutable results = new ObservableCollectionWithChanges\u0026lt;ResultViewModel\u0026gt;() let loadResults () = parseFile fileName |\u0026gt; Array.iter (fun (d,sl, ss, ts) -\u0026gt; results.Add(new ResultViewModel(d, sl, ss, ts))) do loadResults () results.CollectionChanged.Add(fun e -\u0026gt; self.WriteResults()) results.PropertyChanged.Add(fun e -\u0026gt; self.WriteResults()) member m.Results with get() = results and set newValue = results \u0026lt;- newValue base.RaisePropertyChangedEvent(\"Results\") member m.WriteResults () = let rs = results |\u0026gt; Seq.map (fun r -\u0026gt; r.Date, r.StockLong, r.StockShort, r.TrailingStop) let thereAreErrors = results |\u0026gt; Seq.exists (fun r -\u0026gt; r.IsThereAnError) if not thereAreErrors then writeFile fileName rs Things here are more interesting. First of all, in the constructor I load the results calling my model (which I created in Part I of this series). I then subscribe to both the events fired by the collection of results. The former is triggered when an object is added/removed, the latter is triggered when an object changes one of its properties. When one of them fires, I simply write the new state back to the file. This allows me to get rid of Submit/Cancel buttons. What the user sees on the screen is synchronized with the disk at all times. The user doesn’t need to know about the file system.\nIf this were real, I would also implement an undo/redo mechanism. In such case, my reliance on object events might be unwise. I would probably route all the user changes through a command mechanism, so that they can be undo more easily.\nThat’s it for the modelview. The View itself is as follows:\n\u0026lt;Window x:Class=\"SpreadTradingWPF.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:spreadTrading=\"clr-namespace:SpreadTradingWPF\" Title=\"Spread Trading\" Height=\"350\" Width=\"525\" SizeToContent=\"WidthAndHeight\"\u0026gt; \u0026lt;Window.Resources\u0026gt; \u0026lt;spreadTrading:DateToShortStringConverter x:Key=\"DateToShortStringC\" /\u0026gt; \u0026lt;LinearGradientBrush x:Key=\"BlueLightGradientBrush\" StartPoint=\"0,0\" EndPoint=\"0,1\"\u0026gt; \u0026lt;GradientStop Offset=\"0\" Color=\"#FFEAF3FF\"/\u0026gt; \u0026lt;GradientStop Offset=\"0.654\" Color=\"#FFC0DEFF\"/\u0026gt; \u0026lt;GradientStop Offset=\"1\" Color=\"#FFC0D9FB\"/\u0026gt; \u0026lt;/LinearGradientBrush\u0026gt; \u0026lt;Style TargetType=\"{x:Type DataGrid}\"\u0026gt; \u0026lt;Setter Property=\"Margin\" Value=\"5\" /\u0026gt; \u0026lt;Setter Property=\"Background\" Value=\"{StaticResource BlueLightGradientBrush}\" /\u0026gt; \u0026lt;Setter Property=\"BorderBrush\" Value=\"#FFA6CCF2\" /\u0026gt; \u0026lt;Setter Property=\"RowBackground\" Value=\"White\" /\u0026gt; \u0026lt;Setter Property=\"AlternatingRowBackground\" Value=\"#FDFFD0\" /\u0026gt; \u0026lt;Setter Property=\"HorizontalGridLinesBrush\" Value=\"Transparent\" /\u0026gt; \u0026lt;Setter Property=\"VerticalGridLinesBrush\" Value=\"#FFD3D0\" /\u0026gt; \u0026lt;Setter Property=\"RowHeaderWidth\" Value=\"20\" /\u0026gt; \u0026lt;/Style\u0026gt; \u0026lt;/Window.Resources\u0026gt; \u0026lt;StackPanel HorizontalAlignment=\"Center\" Name=\"stackPanel1\" VerticalAlignment=\"Top\" Margin=\"20\"\u0026gt; \u0026lt;TextBlock Text=\"Spread Trading\" Width=\"135\" HorizontalAlignment=\"Center\" FontSize=\"18\" FontWeight=\"Bold\" FontStretch=\"ExtraExpanded\" /\u0026gt; \u0026lt;DataGrid Height=\"Auto\" Width=\"Auto\" Margin=\"5\" ItemsSource=\"{Binding Results}\" CanUserAddRows =\"True\" CanUserDeleteRows=\"True\" AutoGenerateColumns=\"False\"\u0026gt; \u0026lt;DataGrid.RowValidationRules\u0026gt; \u0026lt;spreadTrading:ResultValidationRule ValidationStep=\"UpdatedValue\"/\u0026gt; \u0026lt;/DataGrid.RowValidationRules\u0026gt; \u0026lt;DataGrid.RowValidationErrorTemplate\u0026gt; \u0026lt;ControlTemplate\u0026gt; \u0026lt;Grid Margin=\"0,-2,0,-2\" ToolTip=\"{Binding RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type DataGridRow}}, Path=(Validation.Errors)[].ErrorContent}\"\u0026gt; \u0026lt;Ellipse StrokeThickness=\"0\" Fill=\"Red\" Width=\"{TemplateBinding FontSize}\" Height=\"{TemplateBinding FontSize}\" /\u0026gt; \u0026lt;TextBlock Text=\"!\" FontSize=\"{TemplateBinding FontSize}\" FontWeight=\"Bold\" Foreground=\"White\" HorizontalAlignment=\"Center\" /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/ControlTemplate\u0026gt; \u0026lt;/DataGrid.RowValidationErrorTemplate\u0026gt; \u0026lt;DataGrid.Columns\u0026gt; \u0026lt;DataGridTextColumn Header=\"Date\" Binding=\"{Binding Date, Converter= {StaticResource DateToShortStringC}}\" IsReadOnly=\"false\"/\u0026gt; \u0026lt;DataGridTextColumn Header=\"Long\" Binding=\"{Binding StockLong}\"/\u0026gt; \u0026lt;DataGridTextColumn Header=\"Short\" Binding=\"{Binding StockShort}\" /\u0026gt; \u0026lt;DataGridTextColumn Header=\"Stop\" Binding=\"{Binding TrailingStop}\" /\u0026gt; \u0026lt;/DataGrid.Columns\u0026gt; \u0026lt;/DataGrid\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/Window\u0026gt;  Notice that I styled the grid and I used the right incantations to get validation errors and to bind things properly. The DateToShortString converter used for the date field might be mildly interesting. It’s in the Utilities.cs file together with a validation rule that just delegates to the IsThereAnError method on each entity. In a bigger application, you could write this code in a much more reusable way.\n[ValueConversion(typeof (DateTime), typeof (string))] public class DateToShortStringConverter : IValueConverter { public Object Convert( Object value, Type targetType, Object parameter, CultureInfo culture) { var date = (DateTime) value; return date.ToShortDateString(); } public object ConvertBack( object value, Type targetType, object parameter, CultureInfo culture) { string strValue = value as string; DateTime resultDateTime; if (DateTime.TryParse(strValue, out resultDateTime)) { return resultDateTime; } return DependencyProperty.UnsetValue; } } public class ResultValidationRule : ValidationRule { public override ValidationResult Validate(object value, CultureInfo cultureInfo) { var result = (value as BindingGroup).Items[0] as ResultViewModel; if(result.IsThereAnError) return new ValidationResult(false, \"TrailingStop must be between 0 and 100\"); else return ValidationResult.ValidResult; } } After all these niceties, this is what you get.\n\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-03-19-tracking-spread-trades-in-f-and-wpf-mvvm-part-ii/","tags":["fsharp","Financial"],"title":"Tracking spread trades in F# (and WPF MVVM) – Part II"},{"categories":["fsharp","Investing"],"contents":"I have a bunch of spread trades open. Spread trades are trades where you buy something and you sell something else generally in the same amount. You hope to profit from the widening of the spread between the price of the two instruments.\nI place stop loss orders or trailing stops for all my trades. I have various tool that automatically notify me when a stop loss or trailing stop is hit. For spread trades I don’t have such a tool, hence I decided to build it.\nI defined maximum adverse excursion for a spread trade as the percentage difference between the current value of ‘long price’ / ‘short price’ and its maximum value from the point the trade was placed (aka Current(‘long price’ / ‘short price’) / max (‘long price’ / ‘short price’) – 1 ). This goes from 0 to 100. If the maximum adverse excursion is larger than the trailing stop (using closing prices only), then I want to be notified by email.\nI decided to create a simple exe and use Task Scheduler to run it at the end of the trading day. The program reads a file with all the open spread trades, downloads their prices, calculates maximum adverse excursion and sends an email if it is larger than the trailing stop. I also built a little WPF veneer to manipulate the configuration file.\nHere is what my common.fs file looks like.\nnamespace Spread module internal Common = open System let internal isValidDate s = let v, _ = DateTime.TryParse(s) v let internal isValidTrailingStop s = let v1, n = Int32.TryParse(s) if not(v1) then false else n \u0026gt;= 0 \u0026\u0026 n \u0026lt;= 100 let internal isValidTicker (t:string) = not(t.Contains(\",\")) let internal isValidLine (l:string) = l.Split([|','|]).Length = 4 let internal elseThrow message expression = if not(expression) then raise message let internal elseThrowi i message expression = if not(expression) then failwith (sprintf \"On line %i : %s\" i message)  Notice the isValidTicker function. Yep, I’m using a CSV file to store the list of spread trades. Also I often end up using the little _elseThrow_� functions that I originally used in the Excel functions library to check preconditions.\nHere is an example of using them for the parseLine function:\n// parse a line in the csv config file, assumes valid csv, dates and trailing stop in [0,100] let internal parseLine lineNumber line = isValidLine line |\u0026gt; elseThrowi lineNumber \"badly formatted line\" let values = line.Split([|','|]) isValidDate values.[0] |\u0026gt; elseThrowi lineNumber \"badly formatted date\" isValidTicker values.[1] |\u0026gt; elseThrowi lineNumber \"long ticker has a comma in it\" isValidTicker values.[2] |\u0026gt; elseThrowi lineNumber \"short ticker has a comma in it\" isValidTrailingStop values.[3] |\u0026gt; elseThrowi lineNumber \"trailing stop has to be between 0 and 100 included\" DateTime.Parse(values.[0]), values.[1].Trim(), values.[2].Trim(), int values.[3]  As you can see, the csv format is (dateOfTrade, longTicker, shortTicker, trailingStop). Let’s now look and the FsCheck testcase for this function.\nlet writeLine (date:DateTime) (tickerLong:string) (tickerShort:string) (trailingStopValue:int) = sprintf \"%s,%s,%s,%i\" (date.ToShortDateString()) tickerLong tickerShort trailingStopValue [\u0026lt;Fact;Category(\"Fast Tests\")\u0026gt;] let can_parse_valid_lines () = let prop_parseLine (lineNumber:int) date tickerLong tickerShort trailingStopValue = let line = writeLine date tickerLong tickerShort trailingStopValue let values = line.Split([|','|]) (isValidLine(line) \u0026\u0026 isValidDate values.[0] \u0026\u0026 isValidTicker values.[1] \u0026\u0026 isValidTicker values.[2] \u0026\u0026 isValidTrailingStop values.[3]) ==\u0026gt; lazy let actual = parseLine lineNumber line (date, tickerLong.Trim(), tickerShort.Trim(), trailingStopValue) = actual check config prop_parseLine In FsCheck you state properties of your functions and FsCheck generates random values to test them. In this case I’m asserting that, given a date, tickerLong, tickerShort, trailingStopValue, I can write them to a string, read them back and I get the same values. Frankly, I was skeptical on the utility of such exercise, but I was wrong. That’s how I discovered that tickers cannot have commas in them (among other things).\nTo hook up FsCheck and XUnit (aka to run FsCheck property checking as normal testcases), you need to write the below black magic code.\nlet xUnitRunner = { new IRunner with member x.OnArguments(_,_,_) = () member x.OnShrink(_,_) = () member x.OnFinished(name, result) = match result with | True data -\u0026gt; Assert.True(true) | _ -\u0026gt; failwith (testFinishedToString name result) } let config = {quick with Runner = xUnitRunner} Also, to run XUnit with your brand new .net 4.0 project, you need to add xunit.gui.exe.config to the XUnit directory with the following content:\n    While we are talking about such trivialities, I compile my testcases as executable, so that I can easily run them under debug. I also add the InternalsVisibleTo attribute, so that I can test internal stuff. Many of my algorithms are in internal functions and I want to test them in isolation.\n[\u0026lt;assembly:InternalsVisibleTo(\"SpreadTrackingTests\")\u0026gt;] do   Given the previous function, I can then parse text and files with the following:\nlet internal parseText (lines:string) = lines.Trim().Split([|'\\n'|]) |\u0026gt; Array.mapi parseLine let public parseFile fileName = File.ReadAllText fileName |\u0026gt; parseText I need to load closing prices. I’m using my own library to load prices. That library is pretty badly designed. Also, the function below should be factorized in several sub-functions. It kind of shows how you can write spaghetti code in a beautiful functional language as F# if you really try hard. But let’s not worry about such subtleties for now …\nlet internal loadClosingPrices (endDate:DateTime) tickersStartDate = // format parameters to conform to loadTickersAsync let tickersLong, tickersShort = tickersStartDate |\u0026gt; Array.map (fun (startDate:DateTime, ticker1:string, ticker2:string, _) -\u0026gt; (ticker1, {Start = startDate; End = endDate}), (ticker2, {Start = startDate; End = endDate})) |\u0026gt; Array.unzip let prices = tickersShort |\u0026gt; Array.append tickersLong |\u0026gt; Array.toList |\u0026gt; loadTickersAsync |\u0026gt; Async.RunSynchronously |\u0026gt; Array.map (fun (ticker, span, obs) -\u0026gt; ticker, obs (*|\u0026gt; asHappened 1. |\u0026gt; adjusted adjStart*)) let len = tickersLong.Length let longObs = Array.sub prices 0 len let shortObs = Array.sub prices len len // removes divs and splits let choosePrices observation = match observation.Event with Price(pr) -\u0026gt; Some(observation) | _ -\u0026gt; None let combineOverTickerObservations f tickerObservations = tickerObservations |\u0026gt; Array.map (fun (ticker, observations) -\u0026gt; ticker, observations |\u0026gt; List.choose f |\u0026gt; List.rev) let longPrices = combineOverTickerObservations choosePrices longObs let shortPrices = combineOverTickerObservations choosePrices shortObs longPrices, shortPrices In the above, tickerStartDate is an array of (trade date * long ticker * short ticker * trailingStop) which is what is produced by our parseLine function. The function first separates out long tickers from short ones.\nlet tickersLong, tickersShort = tickersStartDate |\u0026gt; Array.map (fun (startDate:DateTime, ticker1:string, ticker2:string, _) -\u0026gt; (ticker1, {Start = startDate; End = endDate}), (ticker2, {Start = startDate; End = endDate})) |\u0026gt; Array.unzip It then puts them together again in a single Array, to be able to pass it to the loadTickerAsync functions. It runs the function, waits for the results and then returns an array of (ticker * observations).\nlet prices = tickersShort |\u0026gt; Array.append tickersLong |\u0026gt; Array.toList |\u0026gt; loadTickersAsync |\u0026gt; Async.RunSynchronously |\u0026gt; Array.map (fun (ticker, span, obs) -\u0026gt; ticker, obs |\u0026gt; asHappened 1. |\u0026gt; adjusted adjStart)  The data is downloaded as it comes from Yahoo, which is a mix of adjusted and not adjusted data. asHappened transforms it so that everything is as it really happened, adjusted then adjusts it for the effect of dividends and splits. Think of this two function as ‘make the data right’.\nWe then split them again to get the long and short series. The point of merging them and splitting them is to call loadTickersAsync just once instead of twice. There are better ways to do it.\nlet len = tickersLong.Length let longObs = Array.sub prices 0 len let shortObs = Array.sub prices len len At this point we remove the observations that represents dividends or splits, as we are interested just in prices and we return the resulting observations.\nlet choosePrices observation = match observation.Event with Price(pr) -\u0026gt; Some(observation) | _ -\u0026gt; None let combineOverTickerObservations f tickerObservations = tickerObservations |\u0026gt; Array.map (fun (ticker, observations) -\u0026gt; ticker, observations |\u0026gt; List.choose f |\u0026gt; List.rev) let longPrices = combineOverTickerObservations choosePrices longObs let shortPrices = combineOverTickerObservations choosePrices shortObs longPrices, shortPrices The List.rev at the end is interesting. Somewhere in the loadTickerAsync/asHappened/adjusted triad of functions I end up reversing the list. I should fix the bug instead of workaround it, but this is just a blog post, not production code, so I’ll let it slip.\nNow that we have our price observations, we need to extract the price values and calculate the sequence of ratios (long price / short price).\nlet internal calcRatioSeries longPrices shortPrices = let extractPrice obs = match obs.Event with Price(pr) -\u0026gt; pr.Close | _ -\u0026gt; failwith \"At this point divs and splits should have been removed\" let longValues = longPrices |\u0026gt; List.map extractPrice let shortValues = shortPrices |\u0026gt; List.map extractPrice shortValues |\u0026gt; List.map2 (/) longValues Having this ratio series, we can calculate the maximum adverse excursion, incorrectly called trailing stop below.\nlet internal calcTrailingStop ratioSeries = List.head ratioSeries / List.max ratioSeries - 1. We then create a function that puts it all together.\ntype public Result = {RatioName:string; CurrentTrailing:int; TrailingStop:int} with override x.ToString() = x.RatioName + \"\\t\\t\" + x.CurrentTrailing.ToString() + \"\\t\\t\" + x.TrailingStop.ToString() // reads a csv file (startDate, longTicker, shortTicker, trailingStop) and returns an array of results let public processFile fileName endDate = let fileInfo = parseFile fileName let longPrices, shortPrices = loadClosingPrices endDate fileInfo let ratioSeries = Array.map2 (fun l s -\u0026gt; fst l + \"/\" + fst s, calcRatioSeries (snd l) (snd s)) longPrices shortPrices ratioSeries |\u0026gt; Array.mapi (fun i (name, series) -\u0026gt; let (_,_,_,ts) = fileInfo.[i] {RatioName = name; CurrentTrailing = - int (Math.Round (calcTrailingStop series * 100., 0)); TrailingStop = ts}) The function takes a fileName and an endDate, the latter parameter is for the sake of testcases that has to work in the past, so that the data doesn’t change on them.\nNow we need to send an email. The code below works for me:\nlet sendEmail smtpServer port fromField toField subject body (user:string) (password:string) = let client = new SmtpClient(smtpServer, port) client.Credentials \u0026lt;- new NetworkCredential(user, password) client.EnableSsl \u0026lt;- true client.Send(fromField, toField, subject, body) // gets the password from a file under C: so that when I post it on my blog I don't forget to delete it let getPassword () = File.ReadAllText(@\"D:\\Documents and Settings\\Luca\\My Documents\\config.txt\") Almost done, in the main part of the program, we gather the data, create the content of the email and send it out:\ndo let file = \"spreads.csv\" let spreads = processFile file DateTime.Today let mutable builder = new System.Text.StringBuilder() builder \u0026lt;- builder.AppendLine(\"Name\\t\\tCurrent\\t\\tStop\") for s in spreads do builder \u0026lt;- builder.AppendLine(s.ToString()) let password = getPassword() sendEmail \"smtp.gmail.com\" 587 \"***@***.com\" \"***@***.com\" \"Alert Trigger Spread\" (builder.ToString()) \"lucabolg@gmail.com\" password;; Next stop, the WPF veneer on top of the file.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-03-13-tracking-spread-trades-in-f-and-hooking-up-xunit-and-fscheck-part-1/","tags":["fsharp","Financial"],"title":"Tracking spread trades in F# (and hooking up XUnit and FsCheck) – Part 1"},{"categories":["fsharp"],"contents":"I’m working on a program to keep track of paired trades with trailing stops. I need to download stock prices, so I thought I might reuse some old code of mine. Here is the updated framework.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-26-downloading-stock-prices-divs-and-splits-in-f-updated-to-visual-studio-2010/","tags":["fsharp","Financial"],"title":"Downloading stock prices, divs and splits in F# updated to Visual Studio 2010"},{"categories":["fsharp"],"contents":"The last post is here. In this post we’ll look at how things work under the cover and to why I came to believe that they shouldn’t work this way.\nFirst of all each one of the functions to create charts looks something like this:\nstatic member bar (?y,?x, ?isValueShownAsLabel, ?markerSize, ?markerStyle, ?color, ?xname, ?yname, ?seriesName, ?title, ?drawingStyle) = let c = Create (SeriesChartType.Bar, x, y, isValueShownAsLabel, markerSize, markerStyle, color, xname, yname, seriesName, title) c.Series.[0].[\"DrawingStyle\"] \u0026lt;- defaultArg drawingStyle (c.Series.[0].[\"DrawingStyle\"]) c This returns an object of type lc (this is the type of ‘c’). But lc inherits from Chart which is the main class in the Microsoft Chart Controls.\ntype lc() = inherit Chart() I should have said at the start that you need to reference such controls.\n#r \"System.Windows.Forms.DataVisualization.dll\" open System.Collections open System.Drawing open System.IO open System.Windows.Forms open System.Windows.Forms.DataVisualization.Charting open System.Windows.Forms.DataVisualization.Charting.Utilities open System It is convenient that the return value of each function is a subtype of Chart. You can then go and customize this object as you like (i.e. changing graphical appearance) before calling display. Given the Chart inherits from Control you can code the display method as follows:\nlet display (c:lc) = let copy () = let stream = new MemoryStream() c.SaveImage(stream, Imaging.ImageFormat.Bmp) let bmp = new Bitmap(stream) Clipboard.SetDataObject(bmp) c.KeyDown.Add(fun e -\u0026gt; if e.Control = true \u0026\u0026 e.KeyCode = Keys.C then copy ()) let pressToCopy = \"(press CTRL+C to copy)\" let name = if c.Titles.Count = 0 then sprintf \"%s %s \" \"lc\" pressToCopy else sprintf \"%s %s \" c.Titles.[0].Text pressToCopy let f = new Form(Text = name, Size = new Size(800,600), TopMost = true) c.Dock \u0026lt;- DockStyle.Fill f.Controls.Add(c) f.Show() c Apart from a bit of convolutions to implement a Copy function, this just put the Chart control on a newly created Form. The Create method called inside bar looks like the following.\nstatic let Create (chartType, x, y, isValueShownAsLabel, markerSize, markerStyle, color, xname, yname, seriesName, title) = let c = new lc() let a = new ChartArea() let s = new Series() s.ChartType \u0026lt;- chartType c.ChartAreas.Add(a) c.Series.Add(s) match x, y with | Some(x), None -\u0026gt; failwith \"You cannot pass only x to a chart drawing function\" | Some(x), Some(y) -\u0026gt; s.Points.DataBindXY(x, [|y|]) | None, Some(y) -\u0026gt; s.Points.DataBindY([|y|]) | None, None -\u0026gt; () s.IsValueShownAsLabel \u0026lt;- defaultArg isValueShownAsLabel s.IsValueShownAsLabel s.MarkerSize \u0026lt;- defaultArg markerSize s.MarkerSize s.MarkerStyle \u0026lt;- defaultArg markerStyle s.MarkerStyle s.Color \u0026lt;- defaultArg color s.Color a.AxisX.MajorGrid.Enabled \u0026lt;- false a.AxisY.MajorGrid.Enabled \u0026lt;- false match xname with | Some(xname) -\u0026gt; a.AxisX.Title \u0026lt;- xname a.AxisX.TitleFont \u0026lt;- axisFont a.AxisX.TitleForeColor \u0026lt;- axisColor | _ -\u0026gt; () match yname with | Some(yname) -\u0026gt; a.AxisY.Title \u0026lt;- yname a.AxisY.TitleFont \u0026lt;- axisFont a.AxisY.TitleForeColor \u0026lt;- axisColor | _ -\u0026gt; () match seriesName with | Some(seriesName) -\u0026gt; s.Name \u0026lt;- seriesName | _ -\u0026gt; () match title with | Some(title) -\u0026gt; let t = c.Titles.Add(title: string) t.Font \u0026lt;- titleFont t.ForeColor \u0026lt;- titleColor | _ -\u0026gt; () c Pretty standard imperative code here. Creating a chart and assigning its properties. Read the documentation for the Chart Control to understand what I’m doing here. I’m not even sure I remember what I’m doing. Given that we have our own lc class (which is a type of Chart) we can then override the ‘+’ operator and ‘++’ operator to do what is needed.\nstatic member (+) (c1:lc, c2:lc) = let c = copyChart(c1) c1.ChartAreas |\u0026gt; Seq.iter (fun a -\u0026gt; addAreaAndSeries c a c1.Series) let lastArea = c.ChartAreas |\u0026gt; Seq.nth ((c.ChartAreas |\u0026gt; Seq.length) - 1) c2.Series |\u0026gt; Seq.iter(fun s -\u0026gt; c.Series.Add(copySeries s c lastArea.Name)) let l = c.Legends.Add(\"\") l.Font \u0026lt;- legendFont c static member (++) (c1:lc, c2:lc) = let c = copyChart(c1) c1.ChartAreas |\u0026gt; Seq.iter (fun a -\u0026gt; addAreaAndSeries c a c1.Series) let lastArea = c.ChartAreas |\u0026gt; Seq.nth ((c.ChartAreas |\u0026gt; Seq.length) - 1) addAreaAndSeries c c2.ChartAreas.[0] c2.Series let firstArea = c.ChartAreas |\u0026gt; Seq.nth ((c.ChartAreas |\u0026gt; Seq.length) - 1) c2.ChartAreas |\u0026gt; Seq.skip 1 |\u0026gt; Seq.iter (fun a -\u0026gt; addAreaAndSeries c a c2.Series) c  Apart from some other utility functions, this is how it all works. Why do I say that it is wrong? It is my opinion that the right way to do it would be to use ‘+’, ‘++’ and all the lc.XXX functions to create an object model that is completely independent from the Microsoft Chart controls. The display method would then translate it to the appropriate displayable Chart. It would work like a compiler translating to IL and then a Jitter producing native code. This would:\n Make possible to do more interesting compositions of graphs. Now I’m very constrained in what I can do by the fact that I’m working directly with Chart objects Make possible to change the backend. Using something different than Microsoft Chart controls to draw the chart  Why I have not done it? I didn’t know that was the right design until I used the wrong one. Now that I know, I have no time to do it.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-19-lchart-displaying-charts-in-f-part-iii/","tags":["fsharp"],"title":"LChart: displaying charts in F# – Part III"},{"categories":["Uncategorized"],"contents":"FYI I imported all the posts from the old MSDN blog to this one. Hence this post doesn\u0026rsquo;t make sense anymore. I left it here for memory sake. BTW: I am also back in msft now (30/11/2018).\nThis is my last post on this blog. My new blog is here: http://www.lucabol.com \nI accepted a role as Director for Credit Suisse in London. I’m excited by the opportunity to work in the financial industry, a long-standing desire of mine. I’m also excited to write more F# code and to be closer to Italy, where my extended family is.\nThe past ten years in Microsoft have been a wild ride. I’m proud to have been part of ObjectSpaces, Generics, LINQ and F# (and much more …). I’ve been lucky to be able to post on this blog and present at conferences about such innovative technologies. It has all been a lot of fun. I’m sure the next ten years will be as good.\nI’ll see you guys on my new blog.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-19-luca-bolognese-leaves-microsoft/","tags":["Miscellanea"],"title":"Luca Bolognese leaves Microsoft"},{"categories":["fsharp"],"contents":"In the previous post on my old blog I showed how to display simple charts with LChart. In this one we’ll talk about more complex charts. I wanted to define a little language for graphs for the sake of creating a more complex chart in a single line of code. Remember, the scenario here is: I got some data, I want to display it quickly in the fsi. The language has two operators: ‘+’ and ‘++’.\n‘+’ allows you to to superimpose things on a chart as in the following example.\nlc.scatter(y) + lc.line(y) |\u0026gt; display Notice how I can superimpose two graphs of a different type and display the result.\n\nNotice on the upper right corner a bizarre (Series1, Series2) legend. What I wanted to do, but didn’t get around to do, was to allow a syntax like\nlc.scatter(y) + lc.line(y) + lc.legend(“Players”) |\u0026gt; display It should be relatively trivial to add it to the code. Also notice that the ‘y’ parameter in the second chart is not needed. Data flows freely from left to right. So you can write the equivalent code below. This is a feature that caused all sort of grief. With hindsight it’s not worth the hassle. That’s why you always need to write your code at least twice to get it right.\nlc.scatter(y) + lc.line() |\u0026gt; display  Some other, more elaborate charts follows. Notice how data flows from left to right until I introduce a new variable (i.e. the two lc.boxplot  instructions plot different boxplots)\nlc.scatter(y, markerSize = 10) + lc.column() + lc.boxplot() + lc.line() + lc.column(x) + lc.boxplot()|\u0026gt; display \nThings would be better with names for axis, titles and such. I’m not including them for the sake of simplicity.\nlc.scatter(y, markerSize = 10) + lc.column() + (lc.line(x) + lc.column()) + lc.scatter(markerSize = 20) |\u0026gt; display \nIf you remember the previous post, we talked about boxplots and how you generally want to have more than one on a graph. You can do that with the ‘+’ operator and get this ugly chart. More work is needed here.\nlc.boxplot(y = y, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\", color = Color.Blue, whiskerPercentile = 5, percentile = 30, showAverage = false, showMedian = false, showUnusualValues = true) + lc.boxplot(y = x) |\u0026gt; display   ‘++’ allows you to create new charts below the chart you already have as in:\nlet h = [1.;2.5;3.1;4.;4.8;6.0;7.5;8.;9.1;15.] let w = h |\u0026gt; List.map (fun h -\u0026gt; h * 1.2) lc.line(h) + lc.column() ++ lc.line(w) ++ lc.bubble() |\u0026gt; display \nNotice the left to right flowing of information here as well. In the next installment we’ll take a look at how things are implemented and why it’s all wrong.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-17-lchart-displaying-charts-in-f-part-ii/","tags":["fsharp"],"title":"LChart: displaying charts in F# – Part II"},{"categories":["Uncategorized"],"contents":"I want to use F# as a exploratory data analysis language (like R). But I don’t know how to get the same nice graphic capabilities. So I decided to create them. Here is a library to draw charts in F#. It steals ideas from this book and this R package. It is nothing more than a wrapper on top of the Microsoft Chart Controls to give it a more ‘exploratory’ one line calling syntax. It is also rough work in progress: I don’t wrap all the chart types and there are bugs in the ones I wrap. Also the architecture is all wrong (more on this in another post). But it’s a start and it kind of works. Attached the full code.\nI will continue this series in my new blog at wordpress: http://lucabolognese.wordpress.com/. The reason I need a new blog will be explained in an upcoming post.\nPart II is now here.\nOk, let’s start. How do I draw a chart?\nlet x = [1.;2.5;3.1;4.;4.8;6.0;7.5;8.;9.1;15.] let y = [1.6;2.1;1.4;4.;2.3;1.9;2.4;1.4;5.;2.9] lc.scatter(x, y) |\u0026gt; display X and Y are just some make up data. lc is the name of a class (????) and scatter is a static method on it. scatter doesn’t display the chart, it just produces a an object that represents the chart. Display displays the chart. The reason for using the bizarre lc static class is that I want it to be short so that it is easy to type in the fsi.exe. At the same time it needs to support optional parameters (which are not supported on top level functions in F#).\nYou get a window with this chart on it. You can press CTRL+C to copy it (as I did to post it here).\n\nYou might want to customize the chart a bit by passing some of these famous optional parameters:\nlc.scatter(x = x, y = y, markerSize = 10, markerStyle = MarkerStyle.Diamond, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\") |\u0026gt; display  \nOr you might want to print different types of charts:\nlc.line(y = y, markerSize = 10, markerStyle = MarkerStyle.Diamond, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\", isValueShownAsLabel = true, color = Color.Red) |\u0026gt; display  \nlc.spline(x = x, y = y, markerSize = 10, markerStyle = MarkerStyle.Diamond, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\", isValueShownAsLabel = true, color = Color.Red) |\u0026gt; display  \nlc.stepline(x = x, y = y, markerSize = 10, markerStyle = MarkerStyle.Diamond, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\", isValueShownAsLabel = true, color = Color.Red) |\u0026gt; display \nlc.bar(y = y, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\", isValueShownAsLabel = true, drawingStyle = \"Emboss\") |\u0026gt; display  \n lc.column(y = y, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\", isValueShownAsLabel = true, drawingStyle = \"Cylinder\") |\u0026gt; display  \nlc.boxplot(y = y, xname = \"Players\", yname = \"Ratings\", title = \"Players' Ratings\", color = Color.Blue, whiskerPercentile = 5, percentile = 30, showAverage = false, showMedian = false, showUnusualValues = true) |\u0026gt; display  \nOk, the last one is weird. You probably want more than one boxplot in a chart. I\u0026rsquo;ll show you how to do that in the next post.\nThe next post will be on how to have more than one series on the same chart and more than one chart in the same windows. Something like the below:\n\nChartPlotter.fsx\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-17-lchart-displaying-charts-in-f-part-i/","tags":["fsharp"],"title":"LChart: displaying charts in F# – Part I"},{"categories":["Uncategorized"],"contents":"Here is a link to the home page: http://code.msdn.microsoft.com/FinancialFunctions/Wiki/View.aspx?title=Home\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-16-excel-financial-functions-upgraded-to-visual-studio-2010-rc/","tags":["fsharp"],"title":"Excel Financial Functions upgraded to Visual Studio 2010 RC"},{"categories":["Uncategorized"],"contents":"My crazy agent framework now works with RC: http://code.msdn.microsoft.com/LAgent\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-15-new-version-of-lagent-compatible-with-vs-2010-rc-online/","tags":["fsharp"],"title":"New version of LAgent compatible with VS 2010 RC online"},{"categories":["Uncategorized"],"contents":"I always forget the pattern to use to create a functioning MailboxProcessor in F#. I mean, which piece has to be async and how to structure the recursive loop. When I find myself in that kind of a situation situation, my instincts scream at me: “Wrap it and make it work how your mind expects it to work”. So here is a simplification of the paradigm.\nLet’s see how some standard MailboxProcessor code looks like:\nlet counter0 = MailboxProcessor.Start(fun inbox -\u0026gt; let rec loop n = async { let! msg = inbox.Receive() return! loop(n+msg) } loop 0) This keeps a running sum of the messages it receives. The only part that is really unique to this guy is “n + msg”. All the rest is infrastructure.\nYou’d probably prefer to write code like the following:\nlet counter1 = MailboxProcessor.SpawnAgent( (fun msg n -\u0026gt; msg + n), 0) Yep, just one line of code. But, is it possible? Let’s look at one way of doing it:\ntype AfterError\u0026lt;'state\u0026gt; = | ContinueProcessing of 'state | StopProcessing | RestartProcessing type MailboxProcessor\u0026lt;'a\u0026gt; with static member public SpawnAgent\u0026lt;'b\u0026gt;(messageHandler :'a-\u0026gt;'b-\u0026gt;'b,\ninitialState : 'b, ?timeout:'b -\u0026gt; int, ?timeoutHandler:'b -\u0026gt; AfterError\u0026lt;'b\u0026gt;,\n?errorHandler:\nException -\u0026gt; 'a option -\u0026gt; 'b -\u0026gt; AfterError\u0026lt;'b\u0026gt;)\n: MailboxProcessor\u0026lt;'a\u0026gt; = let timeout = defaultArg timeout (fun _ -\u0026gt; -1) let timeoutHandler = defaultArg timeoutHandler (fun state –\u0026gt;\nContinueProcessing(state)) let errorHandler = defaultArg errorHandler (fun _ _ state –\u0026gt;\nContinueProcessing(state)) MailboxProcessor.Start(fun inbox -\u0026gt; let rec loop(state) = async { let! msg = inbox.TryReceive(timeout(state)) try match msg with | None -\u0026gt; match timeoutHandler state with | ContinueProcessing(newState) -\u0026gt;\nreturn! loop(newState) | StopProcessing -\u0026gt; return () | RestartProcessing -\u0026gt; return! loop(initialState) | Some(m) -\u0026gt; return! loop(messageHandler m state) with | ex -\u0026gt; match errorHandler ex msg state with | ContinueProcessing(newState) -\u0026gt; return! loop(newState) | StopProcessing -\u0026gt; return () | RestartProcessing -\u0026gt; return! loop(initialState) } loop(initialState)) The funny formatting is because I have to fit it in the small horizontal space of this blog. In any case, this is just a simple (?) wrapper for the MailboxProcessor pattern. The function takes two necessary parameters and two optional ones:\n messageHandler: a function to execute when a message comes in, it takes the message and the current state as parameters and returns the new state. initialState: the initial state for the MailboxProcessor timeoutHandler: a function that is executed whenever a timeout occurs. It takes as a parameter the current state and returns one of ContinueProcessing(newState), StopProcessing or RestartProcessing errorHandler: a function that gets call if an exception is generated inside the messageHandler function. It takes the exception, the message, the current state and returns ContinueProcessing(newState), StopProcessing or RestartProcessing  An example of how to use errorHandler to implement the CountingAgent in the Expert F# book follows:\ntype msg = Increment of int | Fetch of AsyncReplyChannel\u0026lt;int\u0026gt; | Stop exception StopException type CountingAgent() = let counter = MailboxProcessor.SpawnAgent((fun msg n -\u0026gt; match msg with | Increment m -\u0026gt; n + m | Stop -\u0026gt; raise(StopException) | Fetch replyChannel -\u0026gt; do replyChannel.Reply(n) n ), 0, errorHandler = (fun _ _ _ -\u0026gt; StopProcessing)) member a.Increment(n) = counter.Post(Increment(n)) member a.Stop() = counter.Post(Stop) member a.Fetch() = counter.PostAndReply(fun replyChannel -\u0026gt; Fetch(replyChannel)) let counter2 = CountingAgent() counter2.Increment(1) counter2.Fetch() counter2.Increment(2) counter2.Fetch() counter2.Stop()  Sometimes your agent doesn’t need a state, it is purely stateless. Something as simple as the following:\nlet echo = MailboxProcessor\u0026lt;_\u0026gt;.SpawnWorker(fun msg -\u0026gt; printfn \"%s\" msg) You can easily make that happen by using this toned down version of an agent, called worker:\nstatic member public SpawnWorker(messageHandler, ?timeout, ?timeoutHandler,?errorHandler) = let timeout = defaultArg timeout (fun () -\u0026gt; -1) let timeoutHandler = defaultArg timeoutHandler (fun _ -\u0026gt; ContinueProcessing(())) let errorHandler = defaultArg errorHandler (fun _ _ -\u0026gt; ContinueProcessing(())) MailboxProcessor.SpawnAgent((fun msg _ -\u0026gt; messageHandler msg; ()),\n(), timeout, timeoutHandler,\n(fun ex msg _ -\u0026gt; errorHandler ex msg))\nGiven that they are parallel, you might want to run a whole bunch of them at the same time. You might want something that looks like a worker, but that, under the cover, execute each messageHandler in parallel. Something like:\ntype msg1 = Message1 | Message2 of int | Message3 of string let a = MailboxProcessor.SpawnParallelWorker(function | Message1 -\u0026gt; printfn \"Message1\"; | Message2 n -\u0026gt; printfn \"Message2 %i\" n; | Message3 _ -\u0026gt; failwith \"I failed\" , 10 , errorHandler = (fun ex _ -\u0026gt; printfn \"%A\" ex; ContinueProcessing())) a.Post(Message1) a.Post(Message2(100)) a.Post(Message3(\"abc\")) a.Post(Message2(100))\nIn this example, the different messages, are likely to cause things to print out of order. Notice the number 10 above which is how many workers you want to process your messages. This is implemented by round-robin messages to the various workers:\nstatic member public SpawnParallelWorker(messageHandler, howMany, ?timeout,\n?timeoutHandler,?errorHandler) = let timeout = defaultArg timeout (fun () -\u0026gt; -1) let timeoutHandler = defaultArg timeoutHandler (fun _ -\u0026gt; ContinueProcessing(())) let errorHandler = defaultArg errorHandler (fun _ _ -\u0026gt; ContinueProcessing(())) MailboxProcessor\u0026lt;'a\u0026gt;.SpawnAgent((fun msg (workers:MailboxProcessor\u0026lt;'a\u0026gt; array, index) -\u0026gt; workers.[index].Post msg (workers, (index + 1) % howMany)) , (Array.init howMany\n(fun _ -\u0026gt; MailboxProcessor\u0026lt;'a\u0026gt;.SpawnWorker(\nmessageHandler, timeout, timeoutHandler,\nerrorHandler)), 0)) One drawback with the current code is that it doesn’t supports cancellations. It should be possible to wrap that too, but I haven’t done it (yet). If you don’t want to cut and paste the code, it is inside the AgentSystem.fs file here.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-12-a-simpler-f-mailboxprocessor/","tags":["fsharp"],"title":"A simpler F# MailboxProcessor"},{"categories":["Uncategorized"],"contents":"If you live in London and work with F#, you should join http://www.meetup.com/FSharpLondon/\nAlso, if you don’t work with F#, but you’d like too, and you live in London you should join it. Also if you don’t live in London, but you’d like to and you’d like not to work on F# … Ok, you get the point.\n","permalink":"https://peaceiris.com/MyBlog/posts/2010-02-11-the-functional-londoners-meetup-group/","tags":["fsharp"],"title":"The F#unctional Londoners Meetup Group"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  If you stare long enough at agents, you start to realize that they are just ‘glorified locks’. They are a convenient programming model to protect a resource from concurrent access. The programming model is convenient because both the client and the server can write their code without worrying about concurrency problems, and yet the program runs in parallel. Protecting a resource sounds a lot like state encapsulation and the concept of state encapsulation is what object orientation is all about.\nSo you start thinking if there is a way to enhance vanilla objects to make them agents. You want to reuse all the concepts that you are familiar with (i.e. inheritance, visibility rules, etc…) and you want your clients to call agents as if they were calling normal objects. Obviously, under the cover, the method calls won’t execute immediately, but they would be queued. Let’s look at an example.\nThis is our simple counter agent:\ntype CounterMessage = | Add of int | Print let counterF = fun msg count -\u0026gt; match msg with | Add(i) -\u0026gt; count + i | Print -\u0026gt; printfn \"The value is %i\" count; count let c1 = spawnAgent counterF 0 c1 \u0026lt;-- Add(3) c1 \u0026lt;—Print As nice as this looks, there are unfamiliar things in this model:\n The communication is through messages. This requires packing and unpacking which, albeit easy in F#, is unfamiliar and feels like machinery that we’d like to get rid off. The management of state is bizarre, it gets passed into the lambda and returned from it instead of being represented as fields and properties on the agent  My best attempt at creating an object-like syntax follows:\ntype Counter() = let w = new WorkQueue() let mutable count = 0 member c.Add x = w.Queue (fun () -\u0026gt; count \u0026lt;- count + x ) member c.Print () = w.Queue (fun () -\u0026gt; printfn \"The value is %i\" count ) let c = new Counter() c.Add 3 c.Print With this syntax, you write your agents like you write your vanilla classes except:\n You need a private field of type WorkQueue You need to write your methods as lambdas passed to the WorkQueue.Queue function Your methods cannot return values  The most worrisome of these constraints is 2. because you can easily forget about it. If you do forget, then everything compiles just fine, but it doesn’t do what you expect. That’s pure badness. I haven’t found a way to enforce it. This is a place where the language could help me. Other than that, the whole model works rather nicely.\nRegarding the third point, you can concoct a programming model that allows you to return values from your methods. Here it is:\nmember c.CountTask = w.QueueWithTask(fun () -\u0026gt; count ) member c.CountAsync = w.QueueWithAsync(fun () -\u0026gt; count ) printfn \"The count using Task is %i\" (c.CountTask.Result) The first method returns a Task; the second method returns an AsyncResultCell. Both are ways to represent a promise. The latter allows a natural integration with the async block in F# as in the following code:\nAsync.RunSynchronously ( async { let! count = c.CountAsync printfn \"The countusing Async is %i\" count }) As for myself, I don’t like methods returning values. Every time I use them, I end up going back and thinking about my problem in a traditional way, aka as method calls that return results, instead of thinking about it in a more actor oriented fashion. I end up waiting for these promises to be materialized and, by doing so, I limit the amount of parallelism that I unleash. As a matter of fact, the whole business of hiding the message passing nature of the programming model is dubious. It makes for a nicer syntax, but you need to make an extra effort in your mind to translate it to what it really is: just message passing with a nice syntactical veneer. I haven’t decided yet which model I like the most.\nYou should have a sense of what WorkQueue is. In essence, it is a Mailbox of lambdas (look at the red bold code below).\ntype WorkQueue() = let workQueue = spawnWorker (fun f -\u0026gt; f()) member w.Queue (f) = workQueue \u0026lt;-- f member w.QueueWithTask f : Task\u0026lt;'T\u0026gt; = let source = new TaskCompletionSource\u0026lt;_\u0026gt;() workQueue \u0026lt;-- (fun () -\u0026gt; f() |\u0026gt; source.SetResult) source.Task member w.QueueWithAsync (f:unit -\u0026gt; 'T) : Async\u0026lt;'T\u0026gt; = let result = new AsyncResultCell\u0026lt;'T\u0026gt;() workQueue \u0026lt;-- (fun () -\u0026gt; f() |\u0026gt; result.RegisterResult ) result.AsyncWaitResult member w.Restart () = workQueue \u0026lt;-! Restart member w.Stop () = workQueue \u0026lt;-! Stop member w.SetErrorHandler(h) = let managerF = fun (_, name:string, ex:Exception, _, _, _) -\u0026gt; h name ex let manager = spawnWorker managerF workQueue \u0026lt;-! SetManager manager member w.SetName(name) = workQueue \u0026lt;-! SetName(name) member w.SetQueueHandler(g) = workQueue \u0026lt;-! SetWorkerHandler(g) member w.SetTimeoutHandler(timeout, f) = workQueue \u0026lt;-! SetTimeoutHandler(timeout, f) I implemented all the services that are in the message passing model. The two are equivalent as expressing power goes. In case you wonder how a real piece of code looks like using this model, here is an ActiveObject version of the map reduce algorithm. One of these days, I will gather the strength to go trough this code and explain what it does, but not today 🙂\n#load \"AgentSystem.fs\" open AgentSystem.LAgent open System open System.Collections open System.Collections.Generic open System.Threading type IOutput\u0026lt;'out_key, 'out_value\u0026gt; = abstract Reduced: 'out_key -\u0026gt; seq\u0026lt;'out_value\u0026gt; -\u0026gt; unit abstract MapReduceDone: unit -\u0026gt; unit type Mapper\u0026lt;'in_key, 'in_value, 'my_out_key, 'out_value when 'my_out_key : comparison\u0026gt;\n(map:'in_key -\u0026gt; 'in_value -\u0026gt; seq\u0026lt;'my_out_key * 'out_value\u0026gt;, i, partitionF) = let w = new WorkQueue() let mutable reducerTracker: BitArray = null let mutable controller = Unchecked.defaultof\u0026lt;Controller\u0026lt;'in_key, 'in_value, 'my_out_key, 'out_value\u0026gt;\u0026gt; let mutable reducers = Unchecked.defaultof\u0026lt;Reducer\u0026lt;'in_key, 'in_value, 'my_out_key, 'out_value\u0026gt; array\u0026gt; member m.Init c reds = w.Queue (fun () -\u0026gt; controller \u0026lt;- c reducers \u0026lt;- reds reducerTracker \u0026lt;- new BitArray(reducers.Length, false)) member m.Process inKey inValue = w.Queue (fun () -\u0026gt; let outKeyValues = map inKey inValue outKeyValues |\u0026gt; Seq.iter (fun (outKey, outValue) -\u0026gt; let reducerUsed = partitionF outKey (reducers.Length) reducerTracker.Set(reducerUsed, true) reducers.[reducerUsed].Add(outKey, outValue))) member m.Done () = w.Queue (fun () -\u0026gt; controller.MapDone i reducerTracker) member m.Stop () = w.Stop () and Reducer\u0026lt;'in_key, 'in_value, 'out_key, 'out_value when 'out_key :\ncomparison\u0026gt;(reduce:'out_key -\u0026gt; seq\u0026lt;'out_value\u0026gt; -\u0026gt; seq\u0026lt;'out_value\u0026gt;, i, output:IOutput\u0026lt;'out_key, 'out_value\u0026gt;) = let w = new WorkQueue() let mutable workItems = new List\u0026lt;'out_key * 'out_value\u0026gt;() let mutable controller = Unchecked.defaultof\u0026lt;Controller\u0026lt;'in_key, 'in_value, 'out_key, 'out_value\u0026gt;\u0026gt; member r.Init c = w.Queue (fun () -\u0026gt; controller \u0026lt;- c) member r.StartReduction () = w.Queue (fun () -\u0026gt; workItems |\u0026gt; Seq.groupBy fst |\u0026gt; Seq.sortBy fst |\u0026gt; Seq.map (fun (key, values) -\u0026gt; (key, reduce key (values |\u0026gt; Seq.map snd))) |\u0026gt; Seq.iter (fun (key, value) -\u0026gt; output.Reduced key value) controller.ReductionDone i) member r.Add (outKey:'out_key, outValue:'out_value) : unit = w.Queue (fun () -\u0026gt; workItems.Add((outKey, outValue))) member m.Stop () = w.Stop () and Controller\u0026lt;'in_key, 'in_value, 'out_key, 'out_value when 'out_key : comparison\u0026gt;(output:IOutput\u0026lt;'out_key, 'out_value\u0026gt;) = let w = new WorkQueue() let mutable mapperTracker: BitArray = null let mutable reducerUsedByMappers: BitArray = null let mutable reducerDone: BitArray = null let mutable mappers = Unchecked.defaultof\u0026lt;Mapper\u0026lt;'in_key, 'in_value, 'out_key, 'out_value\u0026gt; array\u0026gt; let mutable reducers = Unchecked.defaultof\u0026lt;Reducer\u0026lt;'in_key, 'in_value, 'out_key, 'out_value\u0026gt; array\u0026gt; let BAtoSeq (b:BitArray) = [for x in b do yield x] member c.Init maps reds = w.Queue (fun () -\u0026gt; mappers \u0026lt;- maps reducers \u0026lt;- reds mapperTracker \u0026lt;- new BitArray(mappers.Length, false) reducerUsedByMappers \u0026lt;- new BitArray(reducers.Length, false) reducerDone \u0026lt;- new BitArray(reducers.Length, false)) member c.MapDone (i : int) (reducerTracker : BitArray) : unit = w.Queue (fun () -\u0026gt; mapperTracker.Set(i, true) let reducerUsedByMappers = reducerUsedByMappers.Or(reducerTracker) if not( BAtoSeq mapperTracker |\u0026gt; Seq.exists(fun bit -\u0026gt; bit = false)) then BAtoSeq reducerUsedByMappers |\u0026gt; Seq.iteri (fun i r -\u0026gt; if r = true then reducers.[i].StartReduction ()) mappers |\u0026gt; Seq.iter (fun m -\u0026gt; m.Stop ()) ) member c.ReductionDone (i: int) : unit = w.Queue (fun () -\u0026gt; reducerDone.Set(i, true) if BAtoSeq reducerDone |\u0026gt; Seq.forall2 (fun x y -\u0026gt; x = y) (BAtoSeq reducerUsedByMappers) then output.MapReduceDone () reducers |\u0026gt; Seq.iter (fun r -\u0026gt; r.Stop ()) c.Stop() ) member m.Stop () = w.Stop () let mapReduce (inputs:seq\u0026lt;'in_key * 'in_value\u0026gt;) (map:'in_key -\u0026gt; 'in_value -\u0026gt; seq\u0026lt;'out_key * 'out_value\u0026gt;) (reduce:'out_key -\u0026gt; seq\u0026lt;'out_value\u0026gt; -\u0026gt; seq\u0026lt;'out_value\u0026gt;) (output:IOutput\u0026lt;'out_key, 'out_value\u0026gt;) M R partitionF = let len = inputs |\u0026gt; Seq.length let M = if len \u0026lt; M then len else M let mappers = Array.init M (fun i -\u0026gt; new Mapper\u0026lt;'in_key, 'in_value, 'out_key, 'out_value\u0026gt;(map, i, partitionF)) let reducers = Array.init R (fun i -\u0026gt; new Reducer\u0026lt;'in_key, 'in_value, 'out_key, 'out_value\u0026gt;(reduce, i, output)) let controller = new Controller\u0026lt;'in_key, 'in_value, 'out_key, 'out_value\u0026gt;(output) mappers |\u0026gt; Array.iter (fun m -\u0026gt; m.Init controller reducers) reducers |\u0026gt; Array.iter (fun r -\u0026gt; r. Init controller ) controller.Init mappers reducers inputs |\u0026gt; Seq.iteri (fun i (inKey, inValue) -\u0026gt; mappers.[i % M].Process inKey inValue) mappers |\u0026gt; Seq.iter (fun m -\u0026gt; m.Done ()) let partitionF = fun key M -\u0026gt; abs(key.GetHashCode()) % M let map = fun (fileName:string) (fileContent:string) -\u0026gt; let l = new List\u0026lt;string * int\u0026gt;() let wordDelims = [|' ';',';';';'.';':';'?';'!';'(';')';'n';'t';'f';'r';'b'|] fileContent.Split(wordDelims) |\u0026gt; Seq.iter (fun word -\u0026gt; l.Add((word, 1))) l :\u0026gt; seq\u0026lt;string * int\u0026gt; let reduce = fun key (values:seq\u0026lt;int\u0026gt;) -\u0026gt; [values |\u0026gt; Seq.sum] |\u0026gt; seq\u0026lt;int\u0026gt; let printer () = { new IOutput\u0026lt;string, int\u0026gt; with member o.Reduced key values = printfn \"%A %A\" key values member o.MapReduceDone () = printfn \"All done!!\"} let testInput =\n[\"File1\", \"I was going to the airport when I saw someone crossing\"; \"File2\", \"I was going home when I saw you coming toward me\"] mapReduce testInput map reduce (printer ()) 2 2 partitionF open System.IO open System.Text let gatherer(step) = let w = new WorkQueue() let data = new List\u0026lt;string * int\u0026gt;() let counter = ref 0 { new IOutput\u0026lt;string, int\u0026gt; with member o.Reduced key values = w.Queue (fun () -\u0026gt; if !counter % step = 0 then printfn \"Processed %i words. Now processing %s\" !counter key data.Add((key, values |\u0026gt; Seq.hd)) counter := !counter + 1) member o.MapReduceDone () = w.Queue (fun () -\u0026gt; data |\u0026gt; Seq.distinctBy (fun (key, _) -\u0026gt; key.ToLower()) |\u0026gt; Seq.filter (fun (key, _) -\u0026gt; not(key = \"\" || key = \"\"\" || (fst (Double.TryParse(key))))) |\u0026gt; Seq.to_array |\u0026gt; Array.sortBy snd |\u0026gt; Array.rev |\u0026gt; Seq.take 20 |\u0026gt; Seq.iter (fun (key, value) -\u0026gt; printfn \"%Att%A\" key value) printfn \"All done!!\") } let splitBook howManyBlocks fileName = let buffers = Array.init howManyBlocks (fun _ -\u0026gt; new StringBuilder()) fileName |\u0026gt; File.ReadAllLines |\u0026gt; Array.iteri (fun i line -\u0026gt; buffers.[i % (howManyBlocks)].Append(line) |\u0026gt; ignore) buffers let blocks1 = __SOURCE_DIRECTORY__ + \"kjv10.txt\" |\u0026gt; splitBook 100 let blocks2 = __SOURCE_DIRECTORY__ + \"warandpeace.txt\" |\u0026gt; splitBook 100 let input = blocks1 |\u0026gt; Array.append blocks2 |\u0026gt; Array.mapi (fun i b -\u0026gt; i.ToString(), b.ToString()) //mapReduce input map reduce (gatherer(1000)) 20 20 partitionF type BookSplitter () = let blocks = new List\u0026lt;string * string\u0026gt;() member b.Split howManyBlocks fileName = let b = fileName |\u0026gt; splitBook howManyBlocks |\u0026gt; Array.mapi (fun i b -\u0026gt; i.ToString(), b.ToString()) blocks.AddRange(b) member b.Blocks () = blocks.ToArray() :\u0026gt; seq\u0026lt;string * string\u0026gt; type WordCounter () = let w = new WorkQueue() let words = new Dictionary\u0026lt;string,int\u0026gt;() let worker(wordCounter:WordCounter, ev:EventWaitHandle) = let w1 = new WorkQueue() { new IOutput\u0026lt;string, int\u0026gt; with member o.Reduced key values = w1.Queue (fun() -\u0026gt; wordCounter.AddWord key (values |\u0026gt; Seq.hd)) member o.MapReduceDone () = w1.Queue(fun () -\u0026gt; ev.Set() |\u0026gt; ignore) } member c.AddWord word count = let exist, value = words.TryGetValue(word) if exist then words.[word] \u0026lt;- value + count else words.Add(word, count) member c.Add fileName = w.Queue (fun () -\u0026gt; let s = new BookSplitter() fileName |\u0026gt; s.Split 100 let ev = new EventWaitHandle(false, EventResetMode.AutoReset) let blocks = s.Blocks () mapReduce blocks map reduce (worker(c, ev)) 20 20 partitionF ev.WaitOne() |\u0026gt; ignore ) member c.Words = w.QueueWithAsync (fun () -\u0026gt; words |\u0026gt; Seq.to_array |\u0026gt; Array.map (fun kv -\u0026gt; kv.Key, kv.Value) ) let wc = new WordCounter() wc.Add (__SOURCE_DIRECTORY__ + \"kjv10.txt\") wc.Add (__SOURCE_DIRECTORY__ + \"warandpeace.txt\") let wordsToPrint = async { let! words = wc.Words return words |\u0026gt; Seq.distinctBy (fun (key, _) -\u0026gt; key.ToLower()) |\u0026gt; Seq.filter (fun (key, _) -\u0026gt; not(key = \"\" || key = \"\"\" || (fst (Double.TryParse(key))))) |\u0026gt; Seq.to_array |\u0026gt; Array.sortBy snd |\u0026gt; Array.rev |\u0026gt; Seq.take 20 |\u0026gt; Seq.iter (fun (key, value) -\u0026gt; printfn \"%Att%A\" key value)} Async.RunSynchronously wordsToPrint Thread.Sleep(15000) printfn \"Closed session\"  ","permalink":"https://peaceiris.com/MyBlog/posts/2009-12-10-lagent-an-agent-framework-in-f-part-x-activeobject/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – Part X – ActiveObject"},{"categories":["Uncategorized"],"contents":"In case you are training to play the part of a first generation Italian immigrant in a Broadway show or if you want to understand why I never short msft stock: http://microsoftpdc.com/Sessions/FT11\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-11-23-my-pdc-session-is-online-future-directions-for-c-and-visual-basic/","tags":["csharp","VB"],"title":"My PDC session is online - “Future directions for C# and Visual Basic”"},{"categories":["Uncategorized"],"contents":"I’ll be in Los Angeles next week for PDC 2009. My session is called “Future Directions for C# and Visual Basic” and it comes on Tuesday immediately after the first keynote.\nI’m planning on spending the first half of the session talking about the biggest trends influencing C# and VB. The second part will be about more future looking features we are playing with these days.\nMy deck has just two slides, as always. It’s all about watching me typing code on stage, hoping that I make crazy errors …\nThere are several other interesting language related sessions at PDC. Here is a list of them (please notice that the times might change). Also feel free to drop by the languages booth and chat. My team and I will be there most of the time.\n  Day  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Time\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Title\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Presenter\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Room\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Tues 11/17  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 11:00 - 12:00 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Future Directions for C# and Visual Basic\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Luca Bolognese \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Hall F \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Tues 11/17  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 11:00 - 12:00 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Accelerated Windows Application Development with Microsoft Visual C++ 2010\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Boris Jabes \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 408B \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Tues 11/17  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 12:30 - 13:15 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Dynamic Binding in C# 4\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Mads Torgersen \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Hall F \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Tues 11/17  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 12:30 - 13:15 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Using Dynamic Languages to Build Scriptable Applications\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Dino Viehland \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 403AB \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Tues 11/17  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 13:30 - 14:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;C++ Forever: Interactive Applications in the Age of Manycore\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Rick Molloy \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 515B \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Tues 11/17  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 16:30 - 17:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Manycore and the Microsoft .NET Framework 4: A Match Made in Microsoft Visual Studio 2010\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Stephen Toub \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 502A \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Tues 11/17  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 16:30 - 17:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Code Contracts and Pex: Power Charge Your Assertions and Unit Tests\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Mike Barnett, Nikolai Tillmann \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 408A \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Wed 11/18  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 11:30 - 12:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Microsoft Perspectives on the Future of Programming\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Panel \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Petree Hall C \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Wed 11/18  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 12:00 - 13:00 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;F# for Architects – Hitting the Sweet Spot\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Chris Smith \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; VS and .NET Pavillion \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Wed 11/18  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 13:00 - 13:45 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Code Like the Wind with Microsoft Visual Basic 2010\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Lucian Wischik \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Petree Hall D \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Wed 11/18  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 13:00 - 13:45 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Future of Garbage Collection\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Patrick Dussud \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Petree Hall C \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Wed 11/18  \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 13:00 - 13:45 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Microsoft Project Code Name “M”: The Data and Modeling Language\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Don Box, Jeff Pinkston \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 408A \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Thu  \u0026lt;p\u0026gt; 11/19 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 08:30 - 09:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;PLINQ: LINQ, but Faster!\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Ed Essey, Igor Ostrovsky \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 515A \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Thu  \u0026lt;p\u0026gt; 11/19 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 10:00 - 11:00 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;A Lap around Microsoft Visual Studio 2010 for the Visual Basic Developer \u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Lisa Feigenbaum \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; VS and .NET Pavillion \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Thu  \u0026lt;p\u0026gt; 11/19 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 10:00 - 11:00 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Axum: A .NET Language for Safe and Scalable Concurrency\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Niklas Gustafsson \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 515A \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Thu  \u0026lt;p\u0026gt; 11/1\u0026lt;br /\u0026gt; 9 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 11:30 - 12:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;F# for Parallel and Asynchronous Programming\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Luke Hoban \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 515A \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Thu  \u0026lt;p\u0026gt; 11/19 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 12:45 - 13:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Microsoft Visual C# IDE Tips and Tricks\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; DJ Park \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Petree Hall D \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;     Thu  \u0026lt;p\u0026gt; 11/19\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;96\u0026quot;\u0026gt; \u0026lt;p\u0026gt; 12:45 - 13:30 \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;502\u0026quot;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Microsoft Visual Basic IDE Tips and Tricks\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;147\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Dustin Campbell \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;117\u0026quot;\u0026gt; \u0026lt;p\u0026gt; Petree Hall C \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt;   ","permalink":"https://peaceiris.com/MyBlog/posts/2009-11-13-luca-at-pdc-2009-next-week/","tags":["csharp","fsharp","VB"],"title":"Luca at PDC 2009 next week"},{"categories":["Uncategorized"],"contents":"Or maybe not, please do not hold me responsible if you lose money following this system. Having said that, it is my opinion that there are very few concepts that are important in investing. Three big ones are value, diversification and momentum. This post is about the latter two and how to use C# to create a simple trading system that uses both.\nDiversification is ‘not put all your eggs in one basket’ (contrary to ‘put all of them in one basket and watch that basket’). I don’t believe you can ‘watch’ very much in financial markets, so I tend to prefer diversification.\nMomentum is a mysterious tendency of financial prices that have risen the most in the recent past, to continue outperforming in the close future. In essence, buying the top stocks/sectors/asset classes tends to outperform buying the bottom ones over horizons from three months to one year.\nThe idea then is to rank some assets (i.e. ETFs) by how fast they have risen in the past, go long the top ones and short the bottom ones. There are hundreds of variations of this basic strategy, we’ll add the rule that we won’t buy assets that are below their 200 days moving average or sell short assets that are above it.\nI’m writing this code with VS 2010 Beta 2 (which hasn’t shipped yet). It should be trivial to modify it to run on B1 (or maybe it does run on it already). I attach the code and data files to this post.\nstruct Event { internal Event(DateTime date, double price) { Date = date; Price = price; } internal readonly DateTime Date; internal readonly double Price; } We’ll use this simple structure to load the closing price for a particular date. My use of internal is kind of bizarre. Actually the whole code might look strange. It is an interesting (maybe un-elegant) mix of object orientation and functional programming.\nclass Summary { internal Summary(string ticker, string name, string assetClass, string assetSubClass, double? weekly, double? fourWeeks, double? threeMonths, double? sixMonths, double? oneYear, double? stdDev, double price, double? mav200) { Ticker = ticker; Name = name; AssetClass = assetClass; AssetSubClass = assetSubClass; // Abracadabra ... LRS = (fourWeeks + threeMonths + sixMonths + oneYear) / 4; Weekly = weekly; FourWeeks = fourWeeks; ThreeMonths = threeMonths; SixMonths = sixMonths; OneYear = oneYear; StdDev = stdDev; Mav200 = mav200; Price = price; } internal readonly string Ticker; internal readonly string Name; internal readonly string AssetClass; internal readonly string AssetSubClass; internal readonly double? LRS; internal readonly double? Weekly; internal readonly double? FourWeeks; internal readonly double? ThreeMonths; internal readonly double? SixMonths; internal readonly double? OneYear; internal readonly double? StdDev; internal readonly double? Mav200; internal double Price; internal static void Banner() { Console.Write(\"{0,-6}\", \"Ticker\"); Console.Write(\"{0,-50}\", \"Name\"); Console.Write(\"{0,-12}\", \"Asset Class\"); //Console.Write(\"{0,-30}t\", \"Asset SubClass\"; Console.Write(\"{0,4}\", \"RS\"); Console.Write(\"{0,4}\", \"1Wk\"); Console.Write(\"{0,4}\", \"4Wk\"); Console.Write(\"{0,4}\", \"3Ms\"); Console.Write(\"{0,4}\", \"6Ms\"); Console.Write(\"{0,4}\", \"1Yr\"); Console.Write(\"{0,6}\", \"Vol\"); Console.WriteLine(\"{0,2}\", \"Mv\"); //Console.Write(\"{0,6}\", \"Pr\"); //Console.WriteLine(\"{0,6}\", \"M200\"); } internal void Print() { Console.Write(\"{0,-6}\", Ticker); Console.Write(\"{0,-50}\", new String(Name.Take(48).ToArray())); Console.Write(\"{0,-12}\", new String(AssetClass.Take(10).ToArray())); //Console.Write(\"{0,-30}t\", new String(AssetSubClass.Take(28).ToArray())); Console.Write(\"{0,4:N0}\", LRS * 100); Console.Write(\"{0,4:N0}\", Weekly * 100); Console.Write(\"{0,4:N0}\", FourWeeks * 100); Console.Write(\"{0,4:N0}\", ThreeMonths * 100); Console.Write(\"{0,4:N0}\", SixMonths * 100); Console.Write(\"{0,4:N0}\", OneYear * 100); Console.Write(\"{0,6:N0}\", StdDev * 100); if (Price \u0026lt;= Mav200) Console.WriteLine(\"{0,2}\", \"X\"); else Console.WriteLine(); //Console.Write(\"{0,6:N2}\", Price); //Console.WriteLine(\"{0,6:N2}\", Mav200); } } The class Summary above is how I want to present my results. A few comments on the code. I use Nullable because some of this values can be null (i.e. not enough history), but I still don’t want to worry about it. It ends up working rather neatly.\nI also print the results out to Console, which is crazy. I really should be using WPF/Silverlight as the presentation layer. Also the {0,4:N0} notation might be unfamiliar to some of you, but this is how mad Console guys like myself avoid using real UI frameworks. Sometimes we print things in color too.\nThe real meat is in the following line:\nLRS = (fourWeeks + threeMonths + sixMonths + oneYear) / 4; That is our highway to richness. It’s a very elaborated quant formula, never before shown, that calculate a magick relative strength (aka momentum) factor as the average of the performance of four weeks, three months, six months and one year.\nclass TimeSeries { internal readonly string Ticker; readonly DateTime _start; readonly Dictionary\u0026lt;DateTime, double\u0026gt; _adjDictionary; readonly string _name; readonly string _assetClass; readonly string _assetSubClass; internal TimeSeries(string ticker, string name, string assetClass, string assetSubClass, IEnumerable\u0026lt;Event\u0026gt; events) { Ticker = ticker; _name = name; _assetClass = assetClass; _assetSubClass = assetSubClass; _start = events.Last().Date; _adjDictionary = events.ToDictionary(e =\u0026gt; e.Date, e =\u0026gt; e.Price); } I then built myself a little TimeSeries class that represents a series of (date, price). I choose a dictionary to store it because of my assumption that I will be accessing it by date a lot. In retrospect, I was kind of right and kind of wrong. It doesn’t really matter much.\nbool GetPrice(DateTime when, out double price, out double shift) { // To nullify the effect of hours/min/sec/millisec being different from 0 when = new DateTime(when.Year, when.Month, when.Day); var found = false; shift = 1; double aPrice = ; while (when \u0026gt;= _start \u0026\u0026 !found) { if (_adjDictionary.TryGetValue(when, out aPrice)) { found = true; } when = when.AddDays(-1); shift -= 1; } price = aPrice; return found; } A TimeSeries can give you back the price at a particular date. This looks bizarre and complex, but there is a reason for it. I might ask for a date that doesn’t have a price associated with it (i.e. holidays, week-ends). In such cases I want to return the previous price which could be N days in the past.\nI also want to return how many days in the past I had to go, so that other calculations (i.e. Return) can modify their end date by the same amount. Also I might not find such a price at all, in which case I don’t want to throw an exception, but instead notify the caller. In retrospect, I should have used double? to signify ‘price not found’.\ndouble? GetReturn(DateTime start, DateTime end) { var startPrice = 0.0; var endPrice = 0.0; var shift = 0.0; var foundEnd = GetPrice(end, out endPrice, out shift); var foundStart = GetPrice(start.AddDays(shift), out startPrice, out shift); if (!foundStart || !foundEnd) return null; else return endPrice / startPrice - 1; } We can now go and calculate the return between two dates. Also the TimeSeries object needs to perform a little more calculations.\ninternal double? LastWeekReturn() { return GetReturn(DateTime.Now.AddDays(-7), DateTime.Now); } internal double? Last4WeeksReturn() { return GetReturn(DateTime.Now.AddDays(-28), DateTime.Now); } internal double? Last3MonthsReturn() { return GetReturn(DateTime.Now.AddMonths(-3), DateTime.Now); } internal double? Last6MonthsReturn() { return GetReturn(DateTime.Now.AddMonths(-6), DateTime.Now); } internal double? LastYearReturn() { return GetReturn(DateTime.Now.AddYears(-1), DateTime.Now); } internal double? StdDev() { var now = DateTime.Now; now = new DateTime(now.Year, now.Month, now.Day); var limit = now.AddYears(-3); var rets = new List\u0026lt;double\u0026gt;(); while (now \u0026gt;= _start.AddDays(12) \u0026\u0026 now \u0026gt;= limit) { var ret = GetReturn(now.AddDays(-7), now); rets.Add(ret.Value); now = now.AddDays(-7); } var mean = rets.Average(); var variance = rets.Select(r =\u0026gt; Math.Pow(r - mean, 2)).Sum(); var weeklyStdDev = Math.Sqrt(variance / rets.Count); return weeklyStdDev * Math.Sqrt(40); } internal double? MAV200() { return _adjDictionary\n.ToList()\n.OrderByDescending(k =\u0026gt; k.Key)\n.Take(200)\n.Average(k =\u0026gt; k.Value); } internal double TodayPrice() { var price = 0.0; var shift = 0.0; GetPrice(DateTime.Now, out price, out shift); return price; } internal Summary GetSummary() { return new Summary(Ticker, _name, _assetClass, _assetSubClass, LastWeekReturn(), Last4WeeksReturn(), Last3MonthsReturn(),\nLast6MonthsReturn(), LastYearReturn(), StdDev(), TodayPrice(),\nMAV200()); } } Nothing particularly interesting in this code. Just a bunch of calculations. The MAV200 is the 200 days moving average of closing prices. It shows a more functional way of doing things. The StdDev function is instead very imperative.\nWe now can work on downloading the prices. This is how you construct the right URL:\nstatic string CreateUrl(string ticker, DateTime start, DateTime end) { return @\"http://ichart.finance.yahoo.com/table.csv?s=\" + ticker + \"\u0026a=\"\n+ (start.Month - 1).ToString() + \"\u0026b=\" + start.Day.ToString() + \"\u0026c=\"\n+ start.Year.ToString() + \"\u0026d=\" + (end.Month - 1).ToString() + \"\u0026e=\"\n+ end.Day.ToString() + \"\u0026f=\" + end.Year.ToString() + \"\u0026g=d\u0026ignore=.csv\"; }  And let’s set how many concurrent connections we are going to use …\nServicePointManager.DefaultConnectionLimit = 10; On my machine, setting this number too high causes errors to be returned. I’m not sure on which side of the connection the problem lies.\nWe can then load all the tickers we want to load from a file. One of the files has Leveraged ETFs, which I want to filter out because they tend to pop up always at the top.\nvar tickers = //File.ReadAllLines(\"ETFs.csv\") //File.ReadAllLines(\"ETFTest.csv\") File.ReadAllLines(\"AssetClasses.csv\") .Skip(1) .Select(l =\u0026gt; l.Split(new[] { ',' })) .Where(v =\u0026gt; v[2] != \"Leveraged\") .Select(values =\u0026gt; Tuple.Create(values[], values[1], values[2], values[3])) .ToArray(); var len = tickers.Length; var start = DateTime.Now.AddYears(-2); var end = DateTime.Now; var cevent = new CountdownEvent(len); var summaries = new Summary[len]; And then load all of them, making sure to make an asynchronous call so not to keep the thread busy.\nfor(var i = 0; i \u0026lt; len; i++) { var t = tickers[i]; var url = CreateUrl(t.Item1, start, end); using (var webClient = new WebClient()) { webClient.DownloadStringCompleted +=\nnew DownloadStringCompletedEventHandler(downloadStringCompleted); webClient.DownloadStringAsync(new Uri(url), Tuple.Create(t, cevent, summaries, i)); } } cevent.Wait();  Notice the use of a Countdown event to wait for all the thread to complete before printing out the results. Also notice the new Tuple class used to package things to send around.\nWe can then print out the top and bottom 15%:\nvar top15perc = summaries .Where(s =\u0026gt; s.LRS.HasValue) .OrderByDescending(s =\u0026gt; s.LRS) .Take((int)(len * 0.15)); var bottom15perc = summaries .Where(s =\u0026gt; s.LRS.HasValue) .OrderBy(s =\u0026gt; s.LRS) .Take((int)(len * 0.15)); Console.WriteLine(); Summary.Banner(); Console.WriteLine(\"TOP 15%\"); foreach(var s in top15perc) s.Print(); Console.WriteLine(); Console.WriteLine(\"Bottom 15%\"); foreach (var s in bottom15perc) s.Print();  Here is what we do when a request comes back with data:\nstatic void downloadStringCompleted(object sender, DownloadStringCompletedEventArgs e) { var bigTuple =\n(Tuple\u0026lt;Tuple\u0026lt;string, string, string, string\u0026gt;, CountdownEvent, Summary[], int\u0026gt;)\ne.UserState; var tuple = bigTuple.Item1; var cevent = bigTuple.Item2; var summaries = bigTuple.Item3; var i = bigTuple.Item4; var ticker = tuple.Item1; var name = tuple.Item2; var asset = tuple.Item3; var subAsset = tuple.Item4; if (e.Error == null) { var adjustedPrices = e.Result .Split(new[] { 'n' }) .Skip(1) .Select(l =\u0026gt; l.Split(new[] { ',' })) .Where(l =\u0026gt; l.Length == 7) .Select(v =\u0026gt; new Event(DateTime.Parse(v[]), Double.Parse(v[6]))); var timeSeries = new TimeSeries(ticker, name, asset, subAsset, adjustedPrices); summaries[i] = timeSeries.GetSummary(); cevent.Signal(); Console.Write(\"{0} \", ticker); } else { Console.WriteLine(\"[{0} ERROR] \", ticker); //Console.WriteLine(e.Error); summaries[i] = new Summary(ticker, name, \"ERROR\", \"ERROR\", , , , , , ,,); cevent.Signal(); } } We first unpack the Tuple we sent out originally, we then extract the Date and Price, create a Summary object and store it in the summaries array. It’s important to remember to Signal to the cevent in the error case as well because we want to print out the results even if some downloading failed.\nAnd here is what you get for your effort:\n\nSystemCodeAndData.zip\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-09-22-becoming-really-rich-with-c/","tags":["csharp","Financial"],"title":"Becoming really rich with C#"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  Let’s now use our mapReduce to do something more interesting, for example finding the frequency of words in several books. Now the agent that processes the output needs to be a bit more complex.\nlet gathererF = fun msg (data:List\u0026lt;string * int\u0026gt;, counter, step) -\u0026gt; match msg with | Reduced(key, value) -\u0026gt; if counter % step = 0 then printfn \"Processed %i words. Now processing %s\" counter key data.Add((key, value |\u0026gt; Seq.hd)) data, counter + 1, step | MapReduceDone -\u0026gt; data |\u0026gt; Seq.distinctBy (fun (key, _) -\u0026gt; key.ToLower()) |\u0026gt; Seq.filter (fun (key, _) -\u0026gt; not(key = \"\" || key = \"\"\" ||\n(fst (Double.TryParse(key))))) |\u0026gt; Seq.to_array |\u0026gt; Array.sortBy snd |\u0026gt; Array.rev |\u0026gt; Seq.take 20 |\u0026gt; Seq.iter (fun (key, value) -\u0026gt; printfn \"%Att%A\" key value) printfn \"All done!!\" data, counter, step let gatherer = spawnAgent gathererF (new List\u0026lt;string * int\u0026gt;(), , 1000) Every time a new word is reduced, a message is printed out and the result is added to a running list. When everything is done such a list is printed out by first manipulating it to reduce weirdness and limit the number of items. BTW: there are at least two bugs in this code, maybe more (late night quick-and-dirty-see-if-the-algo-works kind of coding).\nWe want to maximize the number of processors to use, so let’s split the books in chunks so that they can be operated in parallel. The code below roughly does it (I say roughly because it doesn’t chunk the lines in the right order, but for this particular case it doesn’t matter).\nlet gatherer = spawnAgent gathererF (new List\u0026lt;string * int\u0026gt;(), , 1000) let splitBook howManyBlocks fileName = let buffers = Array.init howManyBlocks (fun _ -\u0026gt; new StringBuilder()) fileName |\u0026gt; File.ReadAllLines |\u0026gt; Array.iteri (fun i line -\u0026gt; buffers.[i % (howManyBlocks)].Append(line) |\u0026gt; ignore) buffers let blocks1 = \"C:UserslucabolDesktopAgentsAgentskjv10.txt\" |\u0026gt; splitBook 100 let blocks2 = \"C:UserslucabolDesktopAgentsAgentswarandpeace.txt\" |\u0026gt; splitBook 100 let input = blocks1 |\u0026gt; Array.append blocks2 |\u0026gt; Array.mapi (fun i b -\u0026gt; i.ToString(), b.ToString()) And let’s execute!!\nmapReduce input map reduce gatherer 20 20 partitionF On my machine I get the following, which could be the right result.\n\"a\" 16147 \"And\" 13071 \"I\" 11349 \"unto\" 8125 \"as\" 6400 \"her\" 5865 \"which\" 5544 \"from\" 5378 \"at\" 5175 \"on\" 5155 \"have\" 5135 \"me\" 5068 \"my\" 4629 \"this\" 3782 \"out\" 3653 \"ye\" 3399 \"when\" 3312 \"an\" 2841 \"upon\" 2558 \"so\" 2489 All done!! ","permalink":"https://peaceiris.com/MyBlog/posts/2009-09-18-lagent-an-agent-framework-in-f-part-ix-counting-words/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – Part IX – Counting words …"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  For this post I use a newer version of the framework that I just uploaded on CodeGallery. In the process of using LAgent I grew more and more unhappy with the weakly typed way of sending messages. The code that implements that feature is nasty: full of upcasts and downcasts. I was losing faith in it. Bugs were cropping up in all sorts of scenarios (i.e. using generic union types as messages).\nIn the end I decided to re-architecture the framework so to make it strongly typed. In essence now each agent can just receive messages of a single type. The limitations that this design choice introduces (i.e. more limited hot swapping) are compensated by the catching of errors at compile time and the streamlining of the code. I left the old framework on the site in case you disagree with me.\nIn any case, today’s post is about MapReduce. It assumes that you know what it is (link to the original Google paper that served as inspiration is here: Google Research Publication- MapReduce). What would it take to implement an in-memory MapReduce using my agent framework?\nLet’s start with the user model.\nlet mapReduce (inputs:seq\u0026lt;'in_key * 'in_value\u0026gt;) (map:'in_key -\u0026gt; 'in_value -\u0026gt; seq\u0026lt;'out_key * 'out_value\u0026gt;) (reduce:'out_key -\u0026gt; seq\u0026lt;'out_value\u0026gt; -\u0026gt; seq\u0026lt;'reducedValues\u0026gt;) outputAgent M R partitionF =  mapReduce takes seven parameters:\n inputs: a sequence of input key/value pairs. map: this function operates on each input key/value pair. It returns a sequence of output key/value pairs. The type of the output sequence can be different from the type of the inputs. reduce: this function operates on an output key and all the values associated with it. It returns a sequence of reduced values (i.e. the average of all the values for this key) ouputAgent: this is the agent that gets notified every time a new output key has been reduced and at the end when all the operation ends. M: how many mapper agents to instantiate R: how many reducer agents to instantiate partitionF: the partition function used to choose which of the reducers is associated with a key  Let’s look at how to use this function to find how often each word is used in a set of files. First a simple partition function can be defined as:\nlet partitionF = fun key M -\u0026gt; abs(key.GetHashCode()) % M  Given a key and some buckets, it picks one of the buckets. Its type is: ‘a –\u0026gt; int –\u0026gt; int, so it’s fairly reusable.\nLet’s also create a basic agent that just prints out the reduced values:\nlet printer = spawnWorker (fun msg -\u0026gt; match msg with | Reduced(key, value) -\u0026gt; printfn \"%A %A\" key value | MapReduceDone -\u0026gt; printfn \"All done!!\") The agent gets notified whenever a new key is reduced or the algorithm ends. It is useful to be notified immediately instead of waiting for everything to be done. If I hadn’t written this code using agents I would have not realized that possibility. I would simply have framed the problem as a function that takes an input and returns an output. Agents force you to think explicitly about the parallelism in your app. That’s a good thing.\nThe mapping function simply split the content of a file into words and adds a word/1 pair to the list. I know that there are much better ways to do this (i.e. regular expressions for the parsing and summing words counts inside the function), but I wanted to test the basic framework capabilities and doing it this way does it better.\nlet map = fun (fileName:string) (fileContent:string) -\u0026gt; let l = new List\u0026lt;string * int\u0026gt;() let wordDelims = [|' ';',';';';'.';':';'?';'!';'(';')';'n';'t';'f';'r';'b'|] fileContent.Split(wordDelims) |\u0026gt; Seq.iter (fun word -\u0026gt; l.Add((word, 1))) l :\u0026gt; seq\u0026lt;string * int\u0026gt; The reducer function simply sums the various word statistics sent by the mappers:\nlet reduce = fun key (values:seq\u0026lt;int\u0026gt;) -\u0026gt; [values |\u0026gt; Seq.sum] |\u0026gt; seq\u0026lt;int\u0026gt; Now we can create some fake input to check that it works:\nlet testInput = [\"File1\", \"I was going to the airport when I saw someone crossing\";\n\"File2\", \"I was going home when I saw you coming toward me\"]  And execute the mapReduce:\nmapReduce testInput map reduce printer 2 2 partitionF On my machine I get the following. You might get a different order because of the async/parallel processing involved. If I wanted a stable order I would need to change the printer agent to cache results on Reduced and process them on MapReduceDone (see next post).\n\u0026ldquo;I\u0026rdquo; [4]\n\u0026ldquo;crossing\u0026rdquo; [1]\n\u0026ldquo;going\u0026rdquo; [2]\n\u0026ldquo;home\u0026rdquo; [1]\n\u0026ldquo;me\u0026rdquo; [1]\n\u0026ldquo;the\u0026rdquo; [1]\n\u0026ldquo;toward\u0026rdquo; [1]\n\u0026ldquo;airport\u0026rdquo; [1]\n\u0026ldquo;coming\u0026rdquo; [1]\n\u0026ldquo;saw\u0026rdquo; [2]\n\u0026ldquo;someone\u0026rdquo; [1]\n\u0026ldquo;to\u0026rdquo; [1]\n\u0026ldquo;was\u0026rdquo; [2]\n\u0026ldquo;when\u0026rdquo; [2]\n\u0026ldquo;you\u0026rdquo; [1]\nIn the next post we’ll process some real books …\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-09-04-lagent-an-agent-framework-in-f-part-viii-implementing-mapreduce-user-model/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – Part VIII  - Implementing MapReduce (user model)"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  Here is an application that uses the framework we have been creating. It is an auction application and it is described in more detail here.\nLet’s go through it.\ntype AuctionMessage = | Offer of int * AsyncAgent // Make a bid | Inquire of AsyncAgent // Check the status and AuctionReply = | StartBidding | Status of int * DateTime // Asked sum and expiration | BestOffer // Ours is the best offer | BeatenOffer of int // Yours is beaten by another offer | AuctionConcluded of // Auction concluded AsyncAgent * AsyncAgent | AuctionFailed // Failed without any bids | AuctionOver // Bidding is closed let timeToShutdown = 3000 let bidIncrement = 10  This is the format of the messages that the clients can send and the action agent can reply to. F# is really good at this sort of thing. First, we need an auction agent:\nlet auctionAgent seller minBid closing = let agent = spawnAgent (fun msg (isConcluded, maxBid, maxBidder) -\u0026gt; match msg with | Offer (_, client) when isConcluded -\u0026gt; client \u0026lt;-- AuctionOver (isConcluded, maxBid, maxBidder) | Offer(bid, client) when not(isConcluded) -\u0026gt; if bid \u0026gt;= maxBid + bidIncrement then if maxBid \u0026gt;= minBid then maxBidder \u0026lt;-- BeatenOffer bid client \u0026lt;-- BestOffer (isConcluded, bid, client) else client \u0026lt;-- BeatenOffer maxBid (isConcluded, maxBid, maxBidder) | Inquire client -\u0026gt; client \u0026lt;-- Status(maxBid, closing) (isConcluded, maxBid, maxBidder)) (false, (minBid - bidIncrement), spawnWorker (fun _ -\u0026gt; ()))  Notice that, if the action is concluded, the agent replies to offers by sending an AuctionOver message. If the auction is still open, then, in case the bid is higher than the max, it sets a new max and notify the two parties involved; otherwise it notifies the bidder that the offer wasn’t successful. Also you can ask for the status of the auction.\nThis is what the code above says. Maybe the code is simpler than words. Anyhow, we need to treat the case where no message is received for some amount of time.\nagent \u0026lt;-- SetTimeoutHandler (closing - DateTime.Now).Milliseconds (fun (isConcluded: bool, maxBid, maxBidder) -\u0026gt; if maxBid \u0026gt;= minBid then let reply = AuctionConcluded(seller, maxBidder) maxBidder \u0026lt;-- reply seller \u0026lt;-- reply else seller \u0026lt;-- AuctionFailed agent \u0026lt;-- SetTimeoutHandler timeToShutdown (fun (_:bool, _:int,_:AsyncAgent) -\u0026gt; StopProcessing) ContinueProcessing (true, maxBid, maxBidder)) agent  We start by waiting for the amount of time to the closing of the auction. If we get no messages, then two things might happen: we have an offer that is more than the minimum or we don’t. If we do, we tell everyone that it’s finished. Otherwise, we tell the seller that its item wasn’t successful. In any case, we prepare the agent to shutdown by setting its next timeout to be timeoutToShutdown.\nIt is interesting that we set the timeout handler inside the timeout handler. This is not a problem because of the nature of message processing (aka it processes one message at the time).\nWe then need a bunch of of symbols …\nmodule Auction = let random = new Random() let minBid = 100 let closing = DateTime.Now.AddMilliseconds 10000. let seller = spawnWorker (fun (msg:AuctionReply) -\u0026gt; ()) let auction = auctionAgent seller minBid closing Not a very smart seller we have here … Next up is our definition of a client.\nlet rec c = spawnAgent ( fun msg (max, current) -\u0026gt; let processBid (aMax, aCurrent) = if aMax \u0026gt;= top then log \"too high for me\" (aMax, aCurrent) elif aCurrent \u0026lt; aMax then let aCurrent = aMax + increment Thread.Sleep (1 + random.Next 1000) auction \u0026lt;-- Offer(aCurrent, c) (aMax, aCurrent) else (aMax, aCurrent) match msg with | StartBidding -\u0026gt; auction \u0026lt;-- Inquire c (max, current) | Status(maxBid,_) -\u0026gt; log \u0026lt;| sprintf \"status(%d)\" maxBid let s = processBid (maxBid, current) c \u0026lt;-- SetTimeoutHandler timeToShutdown (fun _ -\u0026gt; StopProcessing) s | BestOffer -\u0026gt; log \u0026lt;| sprintf \"bestOffer(%d)\" current processBid(max, current) | BeatenOffer maxBid -\u0026gt; log \u0026lt;| sprintf \"beatenOffer(%d)\" maxBid processBid(maxBid, current) | AuctionConcluded(seller, maxBidder) -\u0026gt; log \"auctionConcluded\" c \u0026lt;-- Stop (max, current) | AuctionOver -\u0026gt; log \"auctionOver\" c \u0026lt;-- Stop (max, current)) (0,0) c Something that I like about agents is the fact that you need to understand just small snippets of code at the time. For example, you can read the processing for BestOffer and figure out if it makes sense. I have an easy time personalizing them as in : “Ok, the guy just got a notification that there has been a better offer, what is he going to do next?”.\nThe code should be self explanatory for the most part. In essence, if you can offer more, do it otherwise wait for the auction to end. I’m not even sure the processing is completely right. I confess I’m just trying to do the same as Matthews code from the link above.\nWe can then start up the whole thing and enjoy the cool output.\nopen Auction (client 1 20 200) \u0026lt;-- StartBidding (client 2 10 300) \u0026lt;-- StartBidding (client 3 30 150) \u0026lt;-- StartBidding Console.ReadLine() |\u0026gt; ignore  Now for the nasty part. Implementing the framework.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-07-10-lagent-an-agent-framework-in-f-part-vii-an-auction-application/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – part VII – An auction application"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …   Hot swapping of code Let’s get back a couple of steps and consider what happens when you get an error. Sure, your agent will continue processing messages, but it might be doing the wrong thing. Your message handling code might be buggy.\nIdeally you’d want to patch things on the fly. You’d want to replace the message processing code for an agent without stopping it.\nHere is how you do it:\nlet counter2 = spawnAgent (fun msg state -\u0026gt; printfn \"From %i to %i\" state (state + msg);\nstate + msg) 0 counter2 \u0026lt;-- 2 counter2 \u0026lt;-- SetAgentHandler(fun msg state –\u0026gt;\nprintfn \"From %i to %i via multiplication\" state (state * msg); msg * state) counter2 \u0026lt;-- 3 Which generates:\n **From 0 to 2\n  From 2 to 6 via multiplication**\n After the agent receives a SetAgentHandler message, it switch from a ‘+’ agent to a ‘*’ agent on the fly!! All the messages that come after that one gets multiplied to the state. Also, the state is preserved between changes in behavior.\nIt might not be immediately apparent how to load a function at runtime, but it is really simple. Imagine that I get the data on the function to load from somewhere (i.e. a management console UI).\nlet assemblyNameFromSomewhere, typeNameFromSomewhere, methodNameFromSomewhere = \"mscorlib.dll\", \"System.Console\", \"WriteLine\" I can then use it to dynamically load a message handler (in this case Console.Writeline).\nlet a = Assembly.Load(assemblyNameFromSomewhere) let c = a.GetType(typeNameFromSomewhere) let m = c.GetMethod(methodNameFromSomewhere, [|\"\".GetType()|]) let newF = fun (msg:string) (state:obj) -\u0026gt; m.Invoke(null, [| (msg:\u0026gt;obj) |]) And then it is as simple as posting a SetAgentHandler.\ncounter2 \u0026lt;-- SetAgentHandler(newF) counter2 \u0026lt;-- \"blah\" Now our counter2 agent has become an echo agent on the fly, having loaded Console.WriteLine dynamically. Note how the agent moved from being a ‘+’ agent taking integers to being a ‘*’ agent taking integers to being an ‘echo’ agent taking strings. And it didn’t stop processing messages for the whole time.\nObviously, you can do the same thing with workers:\necho \u0026lt;-- SetWorkerHandler(fun msg -\u0026gt; printfn \"I'm an echo and I say: %s\" msg) echo \u0026lt;-- \"Hello\" And parallelWorkers:\nparallelEcho \u0026lt;-- SetWorkerHandler(fun msg -\u0026gt; tprint (\"I'm new and \" + msg)) messages |\u0026gt; Seq.iter (fun msg -\u0026gt; parallelEcho \u0026lt;-- msg) A silly interlude As a way to show some agents talking to each other, here is a simple program that simulates marital interactions (of the worst kind):\nlet rec husband = spawnWorker (fun (To, msg) -\u0026gt; printfn \"Husband says: %s\" msg; To \u0026lt;-- msg) let rec wife = spawnWorker (fun msg -\u0026gt; printfn \"Wife says: screw you and your '%s'\" msg) husband \u0026lt;-- (wife, \"Hello\") husband \u0026lt;-- (wife, \"But darling ...\") husband \u0026lt;-- (wife, \"ok\") Which produces:\n **Husband says: Hello\n  Husband says: But darling\n  Wife says: screw you and your ‘Hello\u0026rsquo;\n  Wife says: screw you and your ‘But darling\u0026rsquo;\n  Husband says: ok\n  Wife says: screw you and your ‘ok\u0026rsquo;**\n And yes, you cannot expect messages to be in the right sequence … Next up is an auction application.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-07-03-lagent-an-agent-framework-in-f-part-vi-hot-swapping-of-code-and-something-silly/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – Part VI – Hot swapping of code (and something silly)"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  Timeout management Timeouts are very important in message based systems. In essence, if you are not getting messages for a certain period of time, that usually means something. It might be that something crashed, that other agents think that you are not online, or any other number of things. Hence the need to set timeouts and react when they are triggered.\nYou do that by writing the following:\ncounter1 \u0026lt;--SetTimeoutHandler 1000 (fun state -\u0026gt; printfn \"I'm still waiting for a message in state %A, come on ...\" state; ContinueProcessing(state))  Which generates the following message every second:\n **I\u0026rsquo;m still waiting for a message in state 2, come on\n  I\u0026rsquo;m still waiting for a message in state 2, come on .…**\n The first parameter to SetTimeoutHandler is how long to wait before triggering the handler. The second parameter is the handler that gets called whenever no message is received for that amount of time. Notice that the handler takes the current state of the agent and returns ContinueProcessing(state). This tells the agent to continue processing messages and sets the current state to state.\nThe following code:\ncounter1 \u0026lt;-- 2 Then generates:\n **I\u0026rsquo;m still waiting for a message in state 4, come on\n  I\u0026rsquo;m still waiting for a message in state 4, come on**\n ContinueProcessing is just one of the three possible values of the (terribly named) AfterError:\ntype AfterError = | ContinueProcessing of obj | StopProcessing | RestartProcessing Let’s see what RestartProcessing does.\ncounter1 \u0026lt;-- SetTimeoutHandler 1000 (fun state -\u0026gt; printfn \"Restart from state %A\" state\n; RestartProcessing) Which, as expected, generates a nice stream of:\n **Restart from state 0\n  Restart from state 0**\n To bring things back to normal (aka no timeout) you can just pass –1 as in:\ncounter1 \u0026lt;-- SetTimeoutHandler -1 (fun state -\u0026gt; ContinueProcessing(state)) Also, you can stop the agent when a timeout occurs by returning the aptly named StopProcessing:\ncounter1 \u0026lt;-- SetTimeoutHandler 1000 (fun state -\u0026gt; printfn \"Restart from state %A\" state; StopProcessing) Another interesting thing you might want to do is hot swapping of code. More on that in the next part …\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-06-26-lagent-an-agent-framework-in-f-part-v-timeout-management/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – Part V – Timeout management"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …   Custom error management In the last part we saw what happens by default in the framework when an error occurs. But that might not be what you want. You might want to have your sophisticated error detection and recovery distributed algorithm.\nTo make such a thing possible each agent has a manager. The manager is an agent that gets called whenever an error occurs in the agent it is monitoring.\nIn code:\nlet manager = spawnWorker (fun (agent, name:string, ex:Exception, msg:obj,\nstate, initialState) -\u0026gt; printfn \"%s restarting ...\" name; agent \u0026lt;-- Restart) counter1 \u0026lt;-- SetManager(manager) Whenever an error is generated the manager receives a tuple of:\n (agent, name, exception, message, currentState, inititialState)\n This manager prints out something and then restarts the agent. Let’s trigger an error by posting the wrong message:\ncounter1 \u0026lt;-- \"afdaf\" counter1 \u0026lt;-- 2 The expectation is that the counter will restart from 0 whenever an error is triggered. This is what happens:\n **Bob restarting\n  From 0 to 2**\n Which is what we expected. Obviously this is not a very sophisticated error recovery algorithm. You might want to do something more meaningful. Hopefully you have enough information to build whatever you need.\nA particularly important class of unexpected event is timeouts. We’ll talk about them next.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-06-19-lagent-an-agent-framework-in-f-part-iv-custom-error-management/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – Part IV – Custom error management"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  Default error management What happens when an error occurs? Well, ideally you want to notify someone and continue processing messages. By default you want to print the error and as much information as you can about it.\nLet’s first see what happens if you pass the wrong message type:\ncounter1 \u0026lt;-- \"fst\" Generates:\n **\u0026gt; The exception below occurred on agent Undefined at state 3 with message \u0026ldquo;fst\u0026rdquo;. The agent was started with state 0.\n  System.InvalidCastException: Specified cast is not valid.\n   at Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric[T](Object source)\n   at FSI_0003.AgentSystem.f@158.Invoke(Object a, Object b)\n   at Microsoft.FSharp.Core.FastFunc`2.InvokeFast[V](FastFunc`2 func, T arg1, TResult arg2)\n   at Microsoft.FSharp.Core.FastFunc`2.InvokeFast[V](FastFunc`2 func, T arg1, TResult arg2)\n   at FSI_0003.AgentSystem.loop@20-3.Invoke(Unit unitVar)\n   at Microsoft.FSharp.Control.AsyncBuilderImpl.callA@245.Invoke(AsyncParams`1 args)**\n You get information about the current state of the agent, the message that generated the error, the initial state of the agent and the exception that was generated. But, in a system with several agents, you’d like to know which one agent failed. Then you need to name your agent:\ncounter1 \u0026lt;-- SetName(\"Bob\") counter1 \u0026lt;-- \"fadfad\" Now you get (important part in blue):\n **\u0026gt; The exception below occurred on agent Bob at state 3 with message \u0026ldquo;fadfad\u0026rdquo;. The agent was started with state 0.\n  System.InvalidCastException: Specified cast is not valid.\n   at Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions.UnboxGeneric[T](Object source)\n   at FSI_0003.AgentSystem.f@158.Invoke(Object a, Object b)\n   at Microsoft.FSharp.Core.FastFunc`2.InvokeFast[V](FastFunc`2 func, T arg1, TResult arg2)\n   at Microsoft.FSharp.Core.FastFunc`2.InvokeFast[V](FastFunc`2 func, T arg1, TResult arg2)\n   at FSI_0003.AgentSystem.loop@20-3.Invoke(Unit unitVar)\n   at Microsoft.FSharp.Control.AsyncBuilderImpl.callA@245.Invoke(AsyncParams`1 args)**\n The important thing is that the agent continues running. It lives to fight another day. Hence:\ncounter1 \u0026lt;-- 3 Produces:\n From 3 to 6\n Which shows that the agent is running and that it has kept its current state. Also errors can occur inside the message handler with a similar result:\n(spawnAgent (fun msg state -\u0026gt; state / msg) 100) \u0026lt;-- 0 Produces:\n **\u0026gt; The exception below occurred on agent Undefined at state 100 with message 0. The agent was started with state 100.\n  System.DivideByZeroException: Attempted to divide by zero.\n   at FSI_0013.it@48-3.Invoke(Int32 msg, Int32 state)\n   at Microsoft.FSharp.Core.FastFunc`2.InvokeFast[V](FastFunc`2 func, T arg1, TResult arg2)\n   at FSI_0003.AgentSystem.f@158.Invoke(Object a, Object b)\n   at Microsoft.FSharp.Core.FastFunc`2.InvokeFast[V](FastFunc`2 func, T arg1, TResult arg2)\n   at Microsoft.FSharp.Core.FastFunc`2.InvokeFast[V](FastFunc`2 func, T arg1, TResult arg2)\n   at FSI_0003.AgentSystem.loop@20-3.Invoke(Unit unitVar)\n   at Microsoft.FSharp.Control.AsyncBuilderImpl.callA@245.Invoke(AsyncParams`1 args)**\n But this might not be what you want. You might want to customize what happens when an error occurs. We’ll talk about that next.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-06-12-lagent-an-agent-framework-in-f-part-iii-default-error-management/","tags":["fsharp"],"title":"LAgent: an agent framework in F# – Part III – Default error management"},{"categories":["Uncategorized"],"contents":"Download framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  Agents Agents are entities that process messages and keep state between one message and the next. As such they need to be initialized with a lambda that takes a message and a state and returns a new state. In F# pseudo code: msg –\u0026gt; state –\u0026gt; newState. For example the following:\nlet counter = spawnAgent (fun msg state -\u0026gt; state + msg) 0 This is a counter that starts from 0 and gets incremented by the value of the received message. Let’s make it print something when it receives a message:\nlet counter1 = spawnAgent\n(fun msg state -\u0026gt; printfn \"From %i to %i\" state (state + msg); state + msg) 0 counter1 \u0026lt;-- 3 counter1 \u0026lt;-- 4 Which produces:\n **From 0 to 3\n  From 3 to 7**\n There is no spawnParallelAgent, because I couldn’t figure out its usage patterns. Maybe I don’t have enough creativity. Obviously msg and state could be of whatever type (in real application they end up being tuples more often than not).\nControl messages You can do things to agents. I’m always adding to them but at this stage they are:\ntype Command = | Restart | Stop | SetManager of AsyncAgent | SetName of string\nPlus some others. I’ll describe most of them later on, right now I want to talk about Restart and Stop. You use the former like this:\ncounter1 \u0026lt;-- Restart counter1 \u0026lt;-- 3 Which produces:\n From 0 to 3\n This should be somehow surprising to you. You would have thought that you could just post integers to a counter. This is not the case. You can post whatever object. This is useful because it allows to have a common model for passing all sort of messages, it allows for the agent not to be parameterized by the type of the message (and of state) so that you can store them in data structures and allows advanced scenarios (i.e. hot swapping of code).\nThis is a debatable decision. I tried to get the best of strongly typing and dynamic typing, while keeping simplicity of usage. The implementation of this is kind of a mess though. We’ll get there.\nBTW: you use Stop just by posting Stop, which stops the agent (forever).\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-06-05-lagent-an-agent-framework-in-f-part-ii-agents-and-control-messages/","tags":["fsharp"],"title":"LAgent : an agent framework in F# – Part II – Agents and control messages"},{"categories":["Uncategorized"],"contents":"\nDownload framework here.\nAll posts are here:\n Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII – Implementing MapReduce (user model) Part IX – Counting words …  Introduction I like to try out different programming paradigms. I started out as an object oriented programmer. In university, I used Prolog. I then learned functional programming. I also experimented with various shared memory parallel paradigms (i.e. async, tasks and such). I now want to learn more about message based parallel programming (Erlang style). I’m convinced that doing so makes me a better programmer. Plus, I enjoy it …\nMy usual learning style is to build a framework that replicates a particular programming model and then write code using it. In essence, I build a very constrained environment. For example, when learning functional programming, I didn’t use any OO construct for a while even if my programming language supports them.\nIn this case, I built myself a little agent framework based on F# MailboxProcessors. I could have used MailboxProcessors directly, but they are too flexible for my goal. Even to write a simple one of these guys, you need to use async and recursion in a specific pattern, which I always forget. Also, there are multiple ways to to do Post. I wanted things to be as simple as possible. I was willing to sacrifice flexibility for that.\nNotice that there are serious efforts in this space (as Axum). This is not one of them. It’s just a simple thing I enjoy working on between one meeting and the next.\nWorkers and ParallelWorkers The two major primitives are spawning an agent and posting a message.\nlet echo = spawnWorker (fun msg -\u0026gt; printfn \"%s\" msg) echo \u0026lt;-- \"Hello guys!\" There are two kinds of agents in my system. A worker is an agent that doesn’t keep any state between consecutive messages. It is a stateless guy. Notice that the lambda that you pass to create the agent is strongly typed (aka msg is of type string). Also notice that I overloaded the \u0026lt;— operator to mean Post.\nGiven that a worker is stateless, you can create a whole bunch of them and, when a message is posted, route it to one of them transparently.\nlet parallelEcho = spawnParallelWorker(fun s -\u0026gt; printfn \"%s\" s) 10 parallelEcho \u0026lt;-- \"Hello guys!” For example, in the above code, 10 workers are created and, when a message is posted, it gets routed to one of them (using a super duper innovative dispatching algorithm I’ll describe in the implementation part). This parallelWorker guy is not really needed, you could easily built it out of the other primitives, but it is kind of cute.\nTo show the difference between a worker and a parallelWorker, consider this:\nlet tprint s = printfn \"%s running on thread %i\" s Thread.CurrentThread.ManagedThreadId let echo1 = spawnWorker (fun s -\u0026gt; tprint s) let parallelEcho1 = spawnParallelWorker(fun s -\u0026gt; tprint s) 10 let messages = [\"a\";\"b\";\"c\";\"d\";\"e\";\"f\";\"g\";\"h\";\"i\";\"l\";\"m\";\"n\";\"o\";\"p\";\"q\";\"r\";\"s\";\"t\"] messages |\u0026gt; Seq.iter (fun msg -\u0026gt; echo1 \u0026lt;-- msg) messages |\u0026gt; Seq.iter (fun msg -\u0026gt; parallelEcho1 \u0026lt;-- msg)  The result of the echo1 iteration is:\n **a running on thread 11\n  b running on thread 11\n  c running on thread 11\n  d running on thread 11\n  …**\n While the result of the parallelEcho1 iteration is:\n **a running on thread 13\n  c running on thread 14\n  b running on thread 12\n  o running on thread 14\n  m running on thread 13\n  …**\n Notice how the latter executes on multiple threads (but not in order). Next time I’ll talk about agents, control messages and error management.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-05-29-lagent-an-agent-framework-in-f-part-i-workers-and-parallelworkers/","tags":["fsharp"],"title":"LAgent : an agent framework in F# – Part I – Workers and ParallelWorkers"},{"categories":["Uncategorized"],"contents":"Here you go: https://channel9.msdn.com/posts/Charles/Luke-Hoban-Latest-version-of-F-Released-Whats-the-story-Whats-next/\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-05-27-luke-talks-about-f-on-channel9/","tags":["fsharp"],"title":"Luke talks about F# on Channel9"},{"categories":["Uncategorized"],"contents":"Go here to download them. It is in ParallelExtensionsExtrasCoordinationDataStructures. It has a slightly different design in that it returns Tasks. I’m trying to get Stephen to blog about it so that you can compare them.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-05-21-a-version-of-the-asynccache-found-its-way-into-the-parallel-programming-samples/","tags":["csharp","fsharp","VB"],"title":"A version of the AsyncCache found its way into the Parallel Programming samples …"},{"categories":["Uncategorized"],"contents":"The title says it all. If you are interested, go here.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-05-14-i-talk-about-c-and-vb-co-evolution-on-channel9-and-some-f/","tags":["csharp","fsharp","VB"],"title":"I talk about C# and VB Co-Evolution on Channel9 (and some F# …)"},{"categories":["Uncategorized"],"contents":"Other posts:\n Part I – Writing the cache  Let’s try out our little cache. First I want to write a synchronous version of it as a baseline.\nPrivate Shared Sub TestSync(ByVal sites() As String, ByVal sitesToDownload As Integer, ByVal howLong As Integer) Dim syncCache As New Dictionary(Of String, String) Dim count = sites.Count() Dim url1 = \"http://moneycentral.msn.com/investor/invsub/results/statemnt.aspx?Symbol=\" For i = 0 To sitesToDownload - 1 Dim html As String = \"\" Dim url = url1 \u0026 sites(i Mod count) If Not syncCache.TryGetValue(url, html) Then html = LoadWebPage(url) syncCache(url) = html End If DoWork(html, howLong) Next End Sub This is a loop that loads webpages in the cache if they are not already there. sites is a list of tickers used to compose the urls; sitesToDownload is the total number of sites to download, so that a single url can be loaded multiple times; howLong represents the work to be done on each loaded page.\nIn this version the cache is simply a Dictionary and there is no parallelism. The two bold lines is where the cache is managed.\nDoWork is this.\nPublic Shared Sub DoWork(ByVal html As String, ByVal howLong As Integer) Thread.Sleep(howLong) End Sub Let’s take a look at the asynchronous version.\nPrivate Shared Sub TestAsync(ByVal sites() As String, ByVal sitesToDownload As Integer, ByVal howLong As Integer) Dim htmlCache As New HtmlCache Dim count = sites.Count() Dim url = \"http://moneycentral.msn.com/investor/invsub/results/statemnt.aspx?Symbol=\" Using ce = New CountdownEvent(sitesToDownload) For i = 1 To sitesToDownload htmlCache.GetHtmlAsync( url \u0026 sites(i Mod count), Sub(s) DoWork(s, howLong) ce.Signal() End Sub) Next ce.Wait() End Using There are several points worth making on this:\n The lambda used as second parameter for GetHtmlAsync is invoked on a different thread whenever the html has been retrieved (which could be immediately if the cache has downloaded the url before) CountDownEvent allows a thread to wait for a certain number of signals to be sent. The waiting happens on the main thread in the ce.Wait() instruction. The triggering of the event happens in the lambda described in the point above (the ce.Signal() instruction)  This is the driver for the overall testing.\nPrivate Shared Sub TestPerf(ByVal s As String, ByVal a As Action, ByVal iterations As Integer) Dim clock As New Stopwatch clock.Start() For i = 1 To iterations a() Next clock.Stop() Dim ts = clock.Elapsed Dim elapsedTime = String.Format(s \u0026 \": {0:00}:{1:00}:{2:00}.{3:00}\", ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds / 10) Console.WriteLine(elapsedTime, \"RunTime\") End Sub There is not much to say about it. Start the clock, perform a bunch of iterations of the passed lambda, stop the clock, print out performance.\nAnd finally the main method. Note that all the adjustable parameters are factored out before the calls to TestPerf.\nPublic Shared Sub Main() Dim tickers = New String() {\"mmm\", \"aos\", \"shlm\", \"cas\", \"abt\", \"anf\", \"abm\", \"akr\", \"acet\", \"afl\", \"agl\", \"adc\", \"apd\",\n\"ayr\", \"alsk\", \"ain\", \"axb\", \"are\", \"ale\", \"ab\", \"all\"} Dim sitesToDownload = 50 Dim workToDoOnEachUrlInMilliSec = 20 Dim perfIterations = 5 TestPerf(\"Async\", Sub() TestAsync(tickers, sitesToDownload, workToDoOnEachUrlInMilliSec), perfIterations) TestPerf(\"Sync\", Sub() TestSync(tickers, sitesToDownload, workToDoOnEachUrlInMilliSec), perfIterations) End Sub Feel free to change (tickers, sitesToDownload, workToDoOnEachUrlInMilliSec, perfIterations). Depending on the ratios between these parameters and the number of cores on your machine, you’re going to see different results. Which highlights the fact that parallelizing your algorithms can yield performance gains or not depending on both software and hardware considerations. I get ~3X improvement on my box. I attached the full source file for your amusement.\nAsyncCache.vb\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-05-08-an-async-html-cache-part-ii-testing-the-cache/","tags":["VB"],"title":"An Async Html cache – part II – Testing the cache"},{"categories":["Uncategorized"],"contents":"Other posts:\n Part II - Testing the cache  In the process of converting a financial VBA Excel Addin to .NET (more on that in later posts), I found myself in dire need of a HTML cache that can be called from multiple threads without blocking them. Visualize it as a glorified dictionary where each entry is (url, cachedHtml). The only difference is that when you get the page, you pass a callback to be invoked when the html has been loaded (which could be immediately if the html had already been retrieved by someone else).\nIn essence, I want this:\nPublic Sub GetHtmlAsync(ByVal url As String, ByVal callback As Action(Of String)) I’m not a big expert in the .Net Parallel Extensions, but I’ve got help. Stephen Toub helped so much with this that he could have blogged about it himself. And, by the way, this code runs on Visual Studio 2010, which we haven’t shipped yet. I believe with some modifications, it can be run in 2008 + .Net Parallel Extensions CTP, but you’ll have to change a bunch of names.\nIn any case, here it comes. First, let’s add some imports.\nImports System.Collections.Concurrent Imports System.Threading.Tasks Imports System.Threading Imports System.Net Then, let’s define an asynchronous cache.\nPublic Class AsyncCache(Of TKey, TValue) This thing needs to store the (url, html) pairs somewhere and, luckily enough, there is an handy ConcurrentDictionary that I can use. Also the cache needs to know how to load a TValue given a TKey. In ‘programmingese’, that means.\nPrivate _loader As Func(Of TKey, TValue) Private _map As New ConcurrentDictionary(Of TKey, Task(Of TValue)) I’ll need a way to create it.\nPublic Sub New(ByVal l As Func(Of TKey, TValue)) _loader = l End Sub Notice in the above code the use of the Task class for my dictionary instead of TValue. Task is a very good abstraction for “do some work asynchronously and call me when you are done”. It’s easy to initialize and it’s easy to attach callbacks to it. Indeed, this is what we’ll do next:\nPublic Sub GetValueAsync(ByVal key As TKey, ByVal callback As Action(Of TValue)) Dim task As Task(Of TValue) = Nothing If Not _map.TryGetValue(key, task) Then task = New Task(Of TValue)(Function() _loader(key), TaskCreationOptions.DetachedFromParent) If _map.TryAdd(key, task) Then task.Start() Else task.Cancel() _map.TryGetValue(key, task) End If End If task.ContinueWith(Sub(t) callback(t.Result)) End Sub Wow. Ok, let me explain. This method is divided in two parts. The first part is just a thread safe way to say “give me the task corresponding to this key or, if the task hasn’t been inserted in the cache yet, create it and insert it”. The second part just says “add callback to the list of functions to be called when the task has finished running”.\nThe first part needs some more explanation. What is TaskCreationOptions.DetachedFromParent? It essentially says that the created task is not going to prevent the parent task from terminating. In essence, the task that created the child task won’t wait for its conclusion. The rest is better explained in comments.\nIf Not _map.TryGetValue(key, task) Then ' Is the task in the cache? (Loc. X) task = New Task(Of TValue)(Function() _loader(key), TaskCreationOptions.DetachedFromParent) ' No, create it If _map.TryAdd(key, task) Then ' Try to add it task.Start() ' I succeeded. I’m the one who added this task. I can safely start it. Else task.Cancel() ' I failed, someone inserted the task after I checked in (Loc. X). Cancel it. _map.TryGetValue(key, task) ' And get the one that someone inserted End If End If Got it? Well, I admit I trust Stephen that this is what I should do …\nI can then create my little HTML Cache by using the above class as in:\nPublic Class HtmlCache Public Sub GetHtmlAsync(ByVal url As String, ByVal callback As Action(Of String)) _asyncCache.GetValueAsync(url, callback) End Sub Private Function LoadWebPage(ByVal url As String) As String Using client As New WebClient() 'Test.PrintThread(\"Downloading on thread {0} ...\") Return client.DownloadString(url) End Using End Function Private _asyncCache As New AsyncCache(Of String, String)(AddressOf LoadWebPage) End Class I have no idea why coloring got disabled when I copy/paste. It doesn’t matter, this is trivial. I just create an AsyncCache and initialize it with a method that knows how to load a web page. I then simply implement GetHtmlAsync by delegating to the underlying GetValueAsync on AsyncCache.\nIt is somehow bizarre to call Webclient.DownloadString, when the design could be revised to take advantage of its asynchronous version. Maybe I’ll do it in another post. Next time, I’ll write code to use this thing.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-04-27-an-async-html-cache-part-i-writing-the-cache/","tags":["VB"],"title":"An Async Html cache – Part I - Writing the cache"},{"categories":["Uncategorized"],"contents":"I’ll be speaking about the future of C# and F#. Oslo brings back so many memories …\n \n“one of the world’s most important conferences for IT developers and leaders”\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-03-24-luca-at-ndc-in-oslo-17-19-june-2009/","tags":["csharp","fsharp"],"title":"Luca at NDC in Oslo 17 – 19 June 2009"},{"categories":["Uncategorized"],"contents":"I simply fixed a bug related to the Rate function (wrong name for parameters).\nIt is here: http://code.msdn.microsoft.com/FinancialFunctions\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-02-25-excel-financial-functions-2-0-released/","tags":["fsharp","Financial"],"title":"Excel Financial functions 2.0 released"},{"categories":["Uncategorized"],"contents":"When I wrote my Excel financial library I agonized over the decision of which numeric type to use to represent money. Logic would push me toward decimal, but common usage among financial library writers would push me toward double. I ended up picking double, but I regret having to make that choice in the first place.\nConceptually, I\u0026rsquo;d like my numeric functions to work for anything that supports the basic arithmetic operators (i.e. +, -, *). Unfortunately that is not possible in .NET at this point in time. In essence you have to write your code twice as below.\nstatic double SumDouble(double a, double b) { return a + b; } static decimal SumDecimal(decimal a, decimal b) {return a + b;} Granted, this is not a good state of affairs. We often discussed how to make it work, but we couldn\u0026rsquo;t find a solution that was both fast to run and cheap for us to implement. More often than not we speculated about having the numeric types implement a specific INumeric interface and add a generic constraint to the C#/VB languages to make it work. Hence the title of this post.\nWith we implemented dynamic in C# 4.0 it occurred to me that you can fake your way into writing your code just once. For sure, this solution doesn\u0026rsquo;t have the same performance characteristics of ‘writing your code twice\u0026rsquo;, but at least it doesn\u0026rsquo;t duplicate your code.\nThis is how it looks like:\nstatic dynamic Sum1(dynamic a, dynamic b) { return a + b; } The call to the ‘+\u0026rsquo; operator is resolved at runtime, by the C# binder, hence a performance penalty is incurred. The penalty is less than you might think, given that the DLR caches things under the cover so that no v-table lookup is performed the second time around. The whole thing is explained in more detail here. But still, it is not as fast as a normal ‘+\u0026rsquo; operator over a primitive type. I\u0026rsquo;ll let you enjoy micro performance testing this one 🙂\nA slight refinement is to make the code generic so that a caller doesn\u0026rsquo;t see a signature with dynamic types as arguments.\nstatic dynamic Sum2\u0026lt;T1, T2\u0026gt;(T1 a, T2 b) { dynamic ad = a; dynamic bd = b; return ad + bd; } I could make the return type generic as well, but that would force the caller to be explicit about the types, making the calling code much less readable. The other good thing about this signature is that you get a different call site with each combination of type arguments and, since they are separate, the binding caches should stay small. With the former signature there is only one call site and the cache could pile up to the point where the DLR decides to discard it.\nHere is how the calling code looks like right now:\nConsole.WriteLine(Sum2(2m, 4m)); Console.WriteLine(Sum2(2.0, 4.0)); Console.WriteLine(Sum2(new DateTime(2000,12,1), new TimeSpan(24,0,0))); Yet another way to write this code is as follows:\npublic static T Sum3\u0026lt;T\u0026gt;(T a, T b) { dynamic ad = a; dynamic bd = b; return ad + bd; } This gets around the problem of showing a dynamic return value and give you some more compile time type checking. But it prevents summing not coercible types. The compiler doesn\u0026rsquo;t let you get there. The last line below wont\u0026rsquo; compile:\nConsole.WriteLine(Sum3(2m, 4m)); Console.WriteLine(Sum3(2.0, 4.0)); //Console.WriteLine(Sum3(new DateTime(2000,12,1), new TimeSpan(24,0,0))); Also notice that in VB you could have done this a long time ago 🙂\nFunction Sum(Of T1, T2)(ByVal a As T1, ByVal b As T2) Dim aa As Object = a Dim bb As Object = b Return aa + bb End Function In summary, by using dynamic you can write your numeric code just once, but you pay a performance price. You are the only one who can decide if the price is worth paying in your particular application. As often, the profiler is your friend.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-02-05-simulating-inumeric-with-dynamic-in-c-4-0/","tags":["csharp"],"title":"Simulating INumeric with dynamic in C# 4.0"},{"categories":["Uncategorized"],"contents":"I fixed the bug described in this thread and cleaned up the root finding algorithm. I’m still unhappy about it, but I have no time to code a better one right now (i.e. Ridder, Brent). I also added changes.txt and todo.txt to keep track of things.\nChanges.txt\nV1\n Fixed call to throw in bisection Changed findBounds algo Added TestXirrBugs function Removed the NewValue functions everywhere  ToDo.txt\n The interaction of Bisection and Newton algo in findRoot needs review. It seems like it is working now, but it could use some love. Maybe I should switch to a better root finding algo (i.e. Rudder or Brent)  ","permalink":"https://peaceiris.com/MyBlog/posts/2009-01-27-new-release-of-financial-functions-net-uploaded-on-msdn-code-gallery/","tags":["fsharp","Financial"],"title":"New release of Financial Functions .NET uploaded on MSDN Code Gallery"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part I – Background Part II – A simple example – modeling Maia  The previous post ended on this note.\nlet MaiaJointProb attitude action = match attitude with | Happy -\u0026gt; happyActions |\u0026gt; List.assoc action | UnHappy -\u0026gt; unHappyActions |\u0026gt; List.assoc action | Quiet -\u0026gt; quietActions |\u0026gt; List.assoc action This is just a two by two matrix. It simply represents which probability is associated to an (attitude, action) tuple. It is useful to think about it in these terms, because it makes easier to grasp the following function:\n/// Conditional probability of a mental state, given a particular observed action let MaiaLikelihood action = fun attitude -\u0026gt; MaiaJointProb attitude action This is simply a row in the matrix. It answers the question: given that I observe a particular action, what is the probability that Maia has a certain attitude?. This is called “likelihood function” in statistics. Its general form is: given that a I observe an outcome, what is the probability that it is generated by a process with a particular parameter?\nA related question is then: what if I observe a sequence of independent actions? What is the probability that the baby has a certain attitude then? This is answered by the following:\n/// Multiple applications of the previous conditional probabilities for a series of actions (multiplied) let MaiaLikelihoods actions = let composeLikelihoods previousLikelihood action = fun attitude -\u0026gt; previousLikelihood attitude * MaiaLikelihood action attitude actions |\u0026gt; Seq.fold composeLikelihoods (fun attitude -\u0026gt; 1.) It is a trivial extension of the previous function (really), once you know that to combine likelihoods you multiply them.\nWe now need to describe what our prior is. A prior is our preconceived notion about a particular parameter (in this case the baby’s attitude). You might be tempted to express that notion with a single value, but that would be inaccurate. You need to indicate how confident you are about it. In statistics you do that by choosing a distribution for your belief. This is one of the beauties of Bayesian statistics, everything is a probability distribution. In this case, we really don’t have any previous belief, so we pick the uniform distribution.\nlet MaiaUniformPrior attitude = 1. / 3. Think of this as: you haven’t read any baby-attitude-specific study or received any external information about the likely attitude of Maia, so you cannot prefer one attitude over another.\nWe are almost done. Now we have to apply the Bayesian theorem and get the un-normalized posterior distribution. Forget about the un-normalized word. What is a posterior distribution? This is your output, your return value. It says: given my prior belief on the value of a parameter and given the outcomes that I observed, this is what I now believe the parameter to be. In this case it goes like: I had no opinion on Maia’s attitude to start with, but after I observed her behavior for a while, I now think she is Happy with probability X, UnHappy with probability Y and Quiet with probability Z.\n/// Calculates the unNormalized posterior given prior and likelihood let unNormalizedPosterior (prior:'a -\u0026gt; float) likelihood = fun theta -\u0026gt; prior theta * likelihood theta We then need to normalize this thing (it doesn’t sum to one). The way to do it is to divide each probability by the sum of the probabilities for all the possible outcomes.\n/// All possible values for the unobservable parameter (mental state) let support = [Happy; UnHappy; Quiet] /// Normalize the posterior (it integrates to 1.) let posterior prior likelihood = let post = unNormalizedPosterior prior likelihood let sum = support |\u0026gt; List.sum_by (fun attitude -\u0026gt; post attitude) fun attitude -\u0026gt; post attitude / sum We are done. Now we can now start modeling scenarios. Let’s say that you observe [Smile;Smile;Cry;Smile;LookSilly]. What could the underlying attitude of Maia be?\nlet maiaIsANormalBaby = posterior MaiaUniformPrior (MaiaLikelihoods [Smile;Smile;Cry;Smile;LookSilly]) We can then execute our little model:\nmaiaIsANormalBaby Happy maiaIsANormalBaby UnHappy maiaIsANormalBaby Quiet And we get (0.5625, 0.0625, 0.375). So Maia is likely to be happy and unlikely to be unhappy. Let’s now model one extreme case:\n/// Extreme cases let maiaIsLikelyHappyDist = posterior MaiaUniformPrior (MaiaLikelihoods [Smile;Smile;Smile;Smile;Smile;Smile;Smile]) maiaIsLikelyHappyDist Happy maiaIsLikelyHappyDist UnHappy\nmaiaIsLikelyHappyDist Quiet And we get (0.944, 0.000431, 0.05). Now Maia is almost certainly Happy. Notice that I can confidently make this affirmation because my end result is exactly what I was looking for when I started my quest. Using classical statistics, that wouldn’t be the case.\nA related question I might want to ask is: given the posterior distribution for attitude that I just found, what is the probability of observing a particular action? In other words, given the model that I built, what does it predict?\nlet posteriorPredictive jointProb posterior = let composeProbs previousProbs attitude = fun action -\u0026gt; previousProbs action + jointProb attitude action * posterior attitude support |\u0026gt; Seq.fold composeProbs (fun action -\u0026gt; 0.) let nextLikelyUnknownActionDist = posteriorPredictive MaiaJointProb maiaIsLikelyHappyDist I don’t have the strength right now to explain the mathematical underpinning of this. In words, this says: considering that Maia can have one of the possible three Attitudes with the probability calculated above, what is the probability that I observe a particular action? Notice that the signature for it is: (Action –\u0026gt; float), which is the compiler way to say it.\nNow we can run the thing.\nnextLikelyUnknownActionDist Smile nextLikelyUnknownActionDist Cry nextLikelyUnknownActionDist LookSilly And we get (0.588, 0.2056, 0.2055). Why is that? We’ll talk about it in the next post.\n","permalink":"https://peaceiris.com/MyBlog/posts/2009-01-19-bayesian-inference-in-f-part-iib-finding-maia-underlying-attitude/","tags":["fsharp","Statistics"],"title":"Bayesian inference in F# – Part IIb – Finding Maia underlying attitude"},{"categories":["Uncategorized"],"contents":"Today I released the following library on CodeGallery. It is the result of three months of coding during my paternity leave in Italy. You can get it from here.\nWhat is it?\nThis is a .NET library that provides the full set of financial functions from Excel. The main goal for the library is compatibility with Excel, by providing the same functions, with the same behaviour. Note though that this is not a wrapper over the Excel library; the functions have been re-implemented in managed code so that you do not need to have Excel installed to use this library.  ** Where I can find documentation on these functions?\nJust open Excel and click on Formulas/Financial or go to this\n**\nI don\u0026rsquo;t think one of the function is right. Excel produces the wrong results! Why don\u0026rsquo;t you do it right?\nMy goal is to replicate Excel results (right and wrong). Feel free to contribute to the effort by coding what you think is the right solution and I\u0026rsquo;ll add an ExcelCompliant flag to the function to conditionally invoke your code.\n**\nHow do I use the library?**\nJust add Financial.dll to the references in your project. The functions are provided as static methods on a Financial class in the System.Numeric namespace\n**I see the library was implemented with F#. But I don’t want to redistribute F# along with my application. What should I do?**\nThere are two versions of the library. One of them statically links the F# libraries so that there is no dependency on F#. However, this assembly larger, so if you have F# installed, you can use the FinancialNotStandalone.dll instead.\n**\nHow do I run the tests?**\nRun FinancialTests.exe. You need Excel 12 for the tests to work because they use Excel to test that the results are correct. You don\u0026rsquo;t need Excel 12 to use the library in your own application.\n**\nHow do I compile the library?**\nYou need to have F# September CTP installed (you can get it from here). There are two batch files (CreateLibraryStandalone.bat and CreateLibraryNotStandalon.bat). Run them to compile the dll. You might have to change the path to the F# compiler inside these files\n**\nHow do I compile the tests?**\nRun CreateTests.bat\n**\nHave you tested this thing?**\nYes, I do have 201,349 testcases running against it. You can easily raise that number significantly by adding new values to test in testdef.fs. If you have a multiproc machine the testcases will run faster as I parallelize their execution.\n**\nHave you run performance tests on it?**\nNot at all. The only thing I checked is that all the recursive functions are tail recursive. Feel free to let me know if they are slow.\n**\nAre there any functions that behave different from Excel?**\nYes, there are two of them.\n_CoupDays_\nThe Excel algorithm seems wrong in that it doesn\u0026rsquo;t respect the following:\ncoupDays = coupDaysBS + coupDaysNC.\nThis equality should stand. By manually counting the days, I\u0026rsquo;m pretty confident that my algorithm is correct.My result differs from Excel by +/- one or two days when the date spans a leap year.\n_VDB_\nIn the excel version of this algorithm the depreciation in the period (0,1) is not the same as the sum of the depreciations in periods (0,0.5) (0.5,1).\nVDB(100,10,13,0,0.5,1,0) + VDB(100,10,13,0.5,1,1,0) \u0026lt;\u0026gt; VDB(100,10,13,0,1,1,0)\nNotice that in Excel by using ‘1\u0026rsquo; (no_switch) instead of ‘0\u0026rsquo; as the last parameter everything works as expected. The last parameter should have no influence in the calculation given that in the first period there is no switch to sln depreciation.\nOverall, I think my algorithm is correct, even if it disagrees with Excel when startperiod is fractional.\n**\nCan you list the functions with their testcases results?**\nSucceeded 1840/1840 for PV\nSucceeded 2024/2024 for FV\nSucceeded 2240/2240 for PMT\nSucceeded 853/853 for NPER\nSucceeded 5355/5355 for IPMT\nSucceeded 5355/5355 for PPMT\nSucceeded 208/208 for CUMIPMT\nSucceeded 208/208 for CUMPRINC\nSucceeded 624/624 for ISPMT\nSucceeded 12/12 for FVSCHEDULE\nSucceeded 9/9 for IRR\nSucceeded 21/21 for NPV\nSucceeded 147/147 for MIRR\nSucceeded 18/18 for XIRR\nSucceeded 396/396 for DB\nSucceeded 24/24 for SLN\nSucceeded 132/132 for SYD\nSucceeded 456/456 for DDB\nSucceeded 2544/2544 for VDB excluding fractional startdates\nSucceeded 11520/11520 for AMORLINC\nSucceeded 23040/23040 for AMORDEGRC\nSucceeded 15/15 for COUPDAYS excluding leap years\nSucceeded 915/915 for COUPDAYSBS\nSucceeded 915/915 for COUPDAYSNC\nSucceeded 915/915 for COUPNUM\nSucceeded 915/915 for COUPPCD\nSucceeded 915/915 for COUPNCD\nSucceeded 360/360 for ACCRINTM\nSucceeded 1920/1920 for ACCRINT\nSucceeded 10980/10980 for PRICE\nSucceeded 1940/1940 for PRICEMAT\nSucceeded 2910/2910 for YIELDMAT\nSucceeded 1395/1395 for YEARFRAC\nSucceeded 2745/2745 for INTRATE\nSucceeded 1290/1290 for RECEIVED\nSucceeded 2745/2745 for DISC\nSucceeded 3660/3660 for PRICEDISC\nSucceeded 2745/2745 for YIELDDISC\nSucceeded 48/48 for TBILLEQ\nSucceeded 69/69 for TBILLYIELD\nSucceeded 81/81 for TBILLPrice\nSucceeded 12/12 for DOLLARDE\nSucceeded 12/12 for DOLLARFR\nSucceeded 12/12 for EFFECT\nSucceeded 12/12 for NOMINAL\nSucceeded 5490/5490 for DURATION\nSucceeded 5490/5490 for MDURATION\nSucceeded 19320/19320 for ODDFPRICE\nSucceeded 30600/30600 for ODDLPRICE\nSucceeded 45900/45900 for ODDLYIELD\nTest Cases Succeeded 201349/201349\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-12-04-financial-functions-for-net-released/","tags":["csharp","fsharp","Financial"],"title":"Financial Functions for .NET released !"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part I - Background Part IIb - Finding Maia underlying attitude   Let\u0026rsquo;s start with a simple example: inferring the underlying attitude of a small baby by observing her actions. Let\u0026rsquo;s call this particular small baby Maia. People always asks her father if she is a ‘good\u0026rsquo; baby or not. Her father started to wonder how he can possibly know that. Being ‘good\u0026rsquo; is not very clear, so he chooses to answer the related question if her attitude is generally happy, unhappy or simply quiet (a kind of middle ground).\n/// Underlying unobservable, but assumed stationary, state of the process (baby). Theta. type Attitude = | Happy | UnHappy | Quiet Her poor father doesn\u0026rsquo;t have much to go with. He can just observe what she does. He decides, for the sake of simplifying things, to categorize her state at each particular moment as smiling, crying or looking silly (a kind of middle ground).\n/// Observable data. y. type Action = | Smile | Cry | LookSilly  The father now has to decide what does it mean for Maia to be of an happy attitude. Lacking an universal definition of happiness in terms of these actions, he makes one up. Maia would be considered happy if she smiles 60% of the times, she cries 20% of the times and looks silly the remaining 20% of the times. He might as well have experimented with clearly happy/unhappy babies to come up with those numbers.\n/// Data to model the underlying process (baby) let happyActions = [ Smile, 0.6; Cry, 0.2; LookSilly, 0.2] let unHappyActions = [Smile, 0.2; Cry, 0.6; LookSilly, 0.2] let quietActions = [Smile, 0.4; Cry, 0.3; LookSilly, 0.3] What does it mean exactly? Well, this father would call his wife at random times during the day and ask her if Maia is smiling, crying or looking silly. He would then keep track of the numbers and then somehow decide what her attitude is. The general idea is simple, the somehow part is not.\n/// Generates a new uniformly distributed number between 0 and 1 let random = let rnd = new System.Random() rnd.NextDouble We can now model Maia. We want our model to return a particular action depending on which attitude we assume Maia is in mostly. For example, if we assume she is an happy baby, we want our model to return Smile about 60% of the times. In essence, we want to model what happens when the (poor) father calls his (even poorer) wife. What would his wife tell him (assuming a particular attitude)? The general idea is expressed by the following:\n/// Process (baby) modeling. How she acts if she is fundamentally happy, unhappy or quiet let MaiaSampleDistribution attitude = match attitude with | Happy -\u0026gt; pickOne happyActions | UnHappy -\u0026gt; pickOne unHappyActions | Quiet -\u0026gt; pickOne quietActions The ‘pickOne\u0026rsquo; function simply picks an action depending on the probability of it being picked. The name sample distribution is statistic-lingo to mean ‘what you observe\u0026rsquo; and indeed you just can observe Maia\u0026rsquo;s actions, not her underlying attitude.\nThe implementation of pickOne gets technical. You don\u0026rsquo;t need to understand it to understand the rest of this post. This is the beauty of encapsulation. You can start reading from after the next code snippet if you want to.\n‘pickOne\u0026rsquo; works by constructing the inverse cumulative distribution function for the probability distribution described by the Happy/UnHappy/Quiet/Actions lists. There is an entry on wikipedia that describes how this works and I don\u0026rsquo;t wish to say more here except presenting the code.\n/// Find the first value more or equal to a key in a seq\u0026lt;'a * 'b\u0026gt;.\n/// The seq is assumed to be sorted let findByKey key aSeq = aSeq |\u0026gt; Seq.find (fun (k, _) -\u0026gt; k \u0026gt;= key) |\u0026gt; snd /// Simulate an inverse CDF given values and probabilities let buildInvCdf valueProbs = let cdfValues = valueProbs |\u0026gt; Seq.scan (fun cd (_, p) -\u0026gt; cd + p) 0. |\u0026gt; Seq.skip 1 let cdf = valueProbs |\u0026gt; Seq.map fst |\u0026gt; Seq.zip cdfValues |\u0026gt; Seq.cache fun x -\u0026gt; cdf |\u0026gt; findByKey x /// Picks an 'a in a seq\u0026lt;'a * float\u0026gt; using float as the probability to pick a particular 'a let pickOne probs = let rnd = random () let picker = buildInvCdf probs picker rnd Another way to describe Maia is more mathematically convenient and will be used in the rest of the post. This second model answers the question: what is the probability of observing an action assuming a particular attitude? The distribution of both actions and attitudes (observable variable and parameter) is called joint probability.\n/// Another, mathematically more convenient, way to model the process (baby) let MaiaJointProb attitude action = match attitude with | Happy -\u0026gt; happyActions |\u0026gt; List.assoc action | UnHappy -\u0026gt; unHappyActions |\u0026gt; List.assoc action | Quiet -\u0026gt; quietActions |\u0026gt; List.assoc action List.assoc returns the value associated with a key in a list containing (key, value) pairs. Notice that in general, if you are observing a process, you don\u0026rsquo;t know what its joint distribution is. But you can approximate it by running the MaiaSampleDistribution function on known babies many times and keeping track of the result. So, in theory, if you have a way to experiment with many babies with known attitudes, you can create such a joint distribution.\nWe now have modeled our problem, this is the creative part. From now on, it is just execution. We\u0026rsquo;ll get to that.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-11-26-bayesian-inference-in-f-part-iia-a-simple-example-modeling-maia/","tags":["fsharp","Statistics"],"title":"Bayesian inference in F# - Part IIa - A simple example - modeling Maia"},{"categories":["Uncategorized"],"contents":"Luke and I worked on this last year for one week doing pair programming. It is a good sample of how you can serialize LINQ expression trees to xml.\nThe sample includes these components:\n An Expression Tree serialization API: A general purpose XML serialization of Expression Trees. This should work over any expression tree - though there are inevitably bugs. The serialization format is fairly crude, but has been expressive enough to support the variety of expression trees I\u0026rsquo;ve tried throwing at it. A wrapper for serializing/deserializing LINQ to SQL queries: A wrapper around the expression serializer allows serializing LINQ to SQL queries and de-serializing into a query against a given DataContext. A WCF service which accepts serialized query expression trees and executes against a back-end LINQ to SQL: To enable querying across tiers, a WCF service exposes service methods which execute serialized queries. The service implementation deserializes the queries against its LINQ to SQL connection. An IQueryable implementation wrapping the client side of the WCF service: The client-side calling syntax is simplified by providing an IQueryable implementation. This implementation, RemoteTable, executes queries by serializing the query expression tree and calling the appropriate service. The object model that the service user is able to query against is imported by the WCF service reference per the DataContracts on the LINQ to SQL mapping on the server side  The sample is here. Enjoy!\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-11-20-expression-tree-serialization-code-posted-on-code-gallery/","tags":null,"title":"Expression tree serialization code posted on Code Gallery"},{"categories":["Uncategorized"],"contents":"Other posts:\n   Part IIa - A simple example - modeling Maia     Part IIb - Finding Maia underlying attitude    My interest in Bayesian inference comes from my dissatisfaction with ‘classical\u0026rsquo; statistics. Whenever I want to know something, for example the probability that an unknown parameter is between two values, ‘classical\u0026rsquo; statistics seems to answer a different and more convoluted question.\nTry asking someone what the 95% confidence interval for X is (x1, x2) means. Very likely he will tell you that it means that there is a 95% probability that X lies between x1 and x2. That is not the case in classical statistics. It is the case in Bayesian statistics. Also all the funny business of defining a Null hypothesis for the sake of proving its falseness always made my head spin. You don\u0026rsquo;t need any of that in Bayesian statistics. More recently, my discovery that statistical significance is an harmful concept, instead of the bedrock of knowledge I always thought it to be, shook my confidence in ‘classical\u0026rsquo; statistics even more.\nAdmittedly, I\u0026rsquo;m not that smart. If I have an hard time getting an intuitive understanding of something, it tends to go away from my mind after a couple of days I\u0026rsquo;ve learned it. This happens all the time with ‘classical\u0026rsquo; statistics. I feel like I have learned the thing ten times, because I continuously forget it. This doesn\u0026rsquo;t happen with Bayesian statistics. It just makes intuitive sense.\nAt this point you might be wandering what ‘classical\u0026rsquo; statistics is. I use the term classical, but I really shouldn\u0026rsquo;t. Classical statistics is normally just called ‘statistics\u0026rsquo; and it is all you learn if you pick up whatever book on the topic (for example the otherwise excellent Introduction to the Practice of Statistics). Bayesian statistics is just a footnote in such books. This is a shame.\nBayesian statistics provides a much clearer and elegant framework for understanding the process of inferring knowledge from data. The underlying question that it answers is: If I hold an opinion about something and I receive additional data on it, how should I rationally change my opinion?. This question of how to update your knowledge is at the very foundation of human learning and progress in general (for example the scientific method is based on it). We better be sure that the way we answer it is sound.\nYou might wander how it is possible to go against something that is so widely accepted and taught everywhere as ‘classical\u0026rsquo; statistics is. Well, very many things that most people believe are wrong. I always like to cite old Ben on this: The fact that other people agree or disagree with you makes you neither right nor wrong. You will be right if your facts and your reasoning are correct.. This little rule always served me well.\nIn this series of posts I will give examples of Bayesian statistics in F#. I am not a statistician, which makes me part of the very dangerous category of ‘people who are not statisticians but talk about statistics. To try to mitigate the problem I enlisted the help of Ralf Herbrich, who is a statistician and can catch my most blatant errors. Obviously I\u0026rsquo;ll manage to hide my errors so cleverly that not even Ralf would spot them. In which case the fault is just mine.\nIn the next post we\u0026rsquo;ll look at some F# code to model the Bayesian inference process.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-11-07-bayesian-inference-in-f-part-i-background/","tags":["fsharp","Statistics"],"title":"Bayesian inference in F#  - Part I - Background"},{"categories":["Uncategorized"],"contents":"You can watch it here. Also I attached the demo application I built on stage.\nfsharpdemoPDCPrez.zip\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-11-03-my-f-pdc-presentation-is-online-ppt-and-demo-application/","tags":["fsharp"],"title":"My F# PDC presentation is online (+ ppt and demo application)"},{"categories":["Uncategorized"],"contents":"Next Thursday at 1.45pm I will present \u0026ldquo;An introduction to Microsoft F#\u0026quot; at PDC 2008. If you are there, please stop by or drop by the lounge area to chat.\nThere are a bunch of other great sessions from my team. They are all good (I swear I tried to format John\u0026rsquo;s session correctly, but failed).\n  TL16: The Future of C#    Speaker: Anders Hejlsberg    Mon 10/27 | 1:45 PM-3:00 PM | Petree Hall CD    Repeated: Wed 10/29 | 3:00 PM-4:15 PM | 502A    TL10: Deep Dive: Dynamic Languages in .NET    Speaker: Jim Hugunin    Mon 10/27 | 3:30PM | 502A    TL11: An Introduction to Microsoft F#    Speaker: Luca Bolognese    Thu 10/30 | 1:45 PM-3:00 PM | 502A    TL12: Future Directions for Microsoft Visual Basic    Speaker: Paul Vick    Tue 10/28 | 5:15 PM-6:30 PM | 406A    TL54: Natural Interop with Silverlight and Office    Alex Turner    Tue 10/28 | 12:45 PM-1:30 PM | 404A    TL57: A Panel on the Future of Programming Languages    G. Bracha, D.Crockford, A. Hejlsberg, E. Meijer, W.Schulte, J. Siek    Wed 10/29 | 10:30 AM-11:45 AM | 403AB    TL44 IronRuby: The Right Language for the Right Job\n  l Speaker: John Lam\n  l Mon 10/27, 5:15PM, 515B\n  ","permalink":"https://peaceiris.com/MyBlog/posts/2008-10-24-luca-presenting-f-at-pdc-2008/","tags":["fsharp","Miscellanea"],"title":"Luca presenting F# at PDC 2008"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part I - Data modeling Part II - Html scraping Part III - Async loader for prices and divs Part IV - Async loader for splits Part V - Adjusting historical data  An unnamed friend told me that I should stop posting small snippets of code and instead post entire solutions on CodeGallery. I did it for this one and here is the link.\nHere is what\u0026rsquo;s in the zip file:\n  BackTestF - main library to download stock prices\n  Common.fs - common things used in the rest of the project (i.e. data modeling and common funcs)\n  html.fs - functions to scrap html tables, rows and cells\n  loader.fs - this is where the main async downloading algorithms are implemented\n  persistence.fs - async saving and loading of stock prices to files\n  algorithms.fs - async calculations of compound yearly returns given tickers and dates\n  dotNetWrapper.fs - gives a .NET friendly interface to the whole library so that you can use it from C#/VB.NET\n  Tests - too few testcases running on xUnit (you need to download xUnit separately to run them\n  ReturnCalculator - simple console application to show usage of the library\n  Bob - rough winforms UI application that uses the library. An unnamed friend (Jonathan) promised me that he was going to create a UI for my little library. My requirements were very simple: I want the best UI app of this century, one that fully takes advantage of the async nature of my code. Bob doesn\u0026rsquo;t fully satisfy my requirements yet 🙂\n  The code in persistence.fs, algorithms.fs and especially dotnetwrapper.fs is pretty rough and uninteresting. This is why I don\u0026rsquo;t blog about it. I reserve the right to do it if I get around to clean it up.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-10-20-downloading-stock-prices-in-f-part-vi-code-posted/","tags":["fsharp","Financial"],"title":"Downloading stock prices in F# - Part VI - Code posted"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part I - Data modeling Part II - Html scraping Part III - Async loader for prices and divs Part IV - Async loader for splits Part VI - Code posted   Here is the problem. When you download prices/divs/splits from Yahoo you get a strange mix of historical numbers and adjusted numbers. To be more precise, the dividends are historically adjusted. The prices are not adjusted, but there is one last column in the data for Adjusted close. If you don\u0026rsquo;t know what ‘adjusted\u0026rsquo; means in this context read here.\nThe problem with using the ‘adjusted close\u0026rsquo; column is that, for a particular date in the past, ‘adjusted close\u0026rsquo; changes whenever the company pays a dividend or splits its stock. So if I retrieve the value on two different days I might get different numbers because, in the meantime, the company paid a dividend. This prevents me from storing a subset of the data locally and then retrieving other subsets later on. It also has the limitation that just the closing price is present while I might need adjusted opening price, adjusted high price or even adjusted volume depending on the operations I want to perform on the data (i.e. calculating oscillators or volume-adjusted moving averages).\nThe solution I came up with is to download the data and transform it to an ‘asHappened\u0026rsquo; state. This state is simply an unadjusted version of what happened in the past. Data in this state is not going to change in the future, which means that I can safely store it locally. I can then on demand produce ‘historically adjusted\u0026rsquo; data whenever I need to.\nOk, to the code. As it often happens, I need some auxiliary functions before I get to the core of the algorithms. The first one is a way to compare two observations, I will use it later on to sort a list of observations.\nlet compareObservations obs1 obs2 = if obs1.Date \u0026lt;\u0026gt; obs2.Date then obs2.Date.CompareTo(obs1.Date) else match obs1.Event, obs2.Event with | Price _, Price _ | Div _, Div _ | Split _, Split _\n-\u0026gt; failwith \"Two same date/ same kind observations\" | Price _, _ -\u0026gt; -1 | _, Price _ -\u0026gt; 1 | _ -\u0026gt;  This is rather simple. If the dates of these observations are different, just compare them. If they are the same then the two observations cannot be of the same type (i.e. I cannot have two prices for a particular date). Given that they are not of the same, then \u0026amp;(\u0026amp;^%!#$!4. Crap, that teaches me to put comments in my code! I think I\u0026rsquo;m putting the price information first, but I\u0026rsquo;m not sure. Anyhow my universal excuse not to figuring it out is that the testcases succeed so I must be doing it right (how lame, testcase-addiction I guess).\nThe next auxiliary function is just a wrapper over fold. I always tend to wrap fold calls in a method with a better name because I remember the old times when I didn\u0026rsquo;t know what fold was. I want a reader of my code to be able to understand it even if they are not familiar with fold (the ‘universal functional Swiss-Army-Knife). This function is a map that needs to know the value of an accumulator to correctly perform its mapping over each element.\nlet mapAcc acc newAccF newItemF inl = let foldF (acc, l) x = newAccF acc x, (newItemF acc x)::l let _, out = inl |\u0026gt; List.fold_left foldF (acc, []) out Apart from the implementation details, this function takes an accumulator, an accumulator function, an item function and an input list. For each element in the list it calculates two things:\n a new value for the accumulator: newAccumulatorValue = newAccF oldAccValue itemValue a new value for the item: new ItemValue = newItemF accValue oldItemValue  Maybe there is a standard functional way to do such a thing with a specific name that I\u0026rsquo;m not aware of. Luke might know. He is my resident fold expert.\nAll right, now to he main algorithm.\nlet asHappened splitFactor observations = let newSplitFactor splitFactor obs = match obs.Event with | Split(factor) -\u0026gt; splitFactor * factor | _ -\u0026gt; splitFactor let newObs splitFactor obs = let date = obs.Date let event = match obs.Event with | Price(p) -\u0026gt; Price(p) | Div(amount) -\u0026gt; Div(amount * splitFactor) | Split(factor) -\u0026gt; Split(factor) {Date = date; Event = event} observations |\u0026gt; List.sort compareObservations |\u0026gt; mapAcc splitFactor newSplitFactor newObs To understand what\u0026rsquo;s going on start from the bottom. I\u0026rsquo;m taking the observation list downloaded from Yahoo and sorting it using my compareObservations function. I then take the resulting list and apply the previously described mapAcc to it. For this function splitFactor is the accumulator, newSplitFactor is the accumulator function and newObs is the function that generate a new value for each item in the list.\nNewSplitFactor is trivial: every time it sees a Split observation it updates the value of the split factor. That\u0026rsquo;s it. NewObs is rather simple as well. Every time it sees a dividend, it ‘unadjust\u0026rsquo; it by multiplying its amount by the split factor. The end result is to transform the dividends downloaded from Yahoo (which are adjusted) to an unadjusted state. I could have filtered out the price observations before doing all of this and add them back afterward, but didn\u0026rsquo;t. It\u0026rsquo;d probably be slower\nNow that I can recreate the state of the world as it was at a particular point in time, what if I want to adjust the data? I can call adjusted\nlet adjusted (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact)\nasHappenedObs = let newFactor (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact) obs = match obs.Event with | Split(split) -\u0026gt;\nsplitFactor * split, lastDiv, oFact, hFact, lFact, cFact, vFact | Div(div) -\u0026gt; splitFactor, div, oFact, hFact, lFact, cFact, vFact | Price(p) -\u0026gt;\nsplitFactor, 0.\u0026lt;money\u0026gt;, oFact / (1. - lastDiv / p.Open),\nhFact / (1. - lastDiv / p.High), lFact / (1. - lastDiv / p.Low),\ncFact / (1. - lastDiv / p.Close), vFact / (1. - lastDiv / p.Close) let newObs (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact) obs = let date = obs.Date let event = match obs.Event with | Price(p) -\u0026gt;\nPrice({Open = p.Open / splitFactor / oFact;\nHigh = p.High / splitFactor / hFact;\nLow = p.Low / splitFactor / lFact;\nClose = p.Close / splitFactor / cFact;\nVolume = p.Volume / splitFactor / vFact }) | Div(amount) -\u0026gt; Div (amount / splitFactor) | Split(split) -\u0026gt; Split(split) {Date = date; Event = event} asHappenedObs |\u0026gt; List.sort compareObservations |\u0026gt; mapAcc (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact)\nnewFactor newObs |\u0026gt; List.filter (fun x -\u0026gt; match x.Event with Split(_) -\u0026gt; false | _ -\u0026gt; true)  Wow, ok, this looks messy. Let\u0026rsquo;s go through it. Starting from the bottom: sort the observations, perform the right algorithm and filter away all the splits. It doesn\u0026rsquo;t make sense to have splits in adjusted data.\nThe interesting piece is the mappAcc function. It take a tuple of factors as accumulator and the usual two functions to update such tuple and create new observations. The newObs function creates a new Observation using the factors in the accumulator tuple. Notice how the dividends are divided by the splitFactor (which is the opposite of our asHappened algorithm where we were multiplying them). Also notice how the prices are divided by both the splitFactor and the pertinent price factor. This is needed because the prices need to be adjusted by the dividends paid out and the adjustment factor is different for each kind of price (i.e. open, close, etc). The newFactor function simply updates all the factors depending on the current observation.\nNotice how asHappened and adjusted are structurally similar. This is an artifact of having a functional approach to writing code: it kind of forces you to identify these commonality in the way an algorithm behave and abstract them out (in this case in the mapAcc function). You often discover that such abstracted-out pieces are more generally useful than the case at hand.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-09-26-downloading-stock-prices-in-f-part-v-adjusting-historical-data/","tags":["fsharp"],"title":"Downloading stock prices in F# - Part V - Adjusting historical data"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part I - Data modeling Part II - Html scraping Part III - Async loader for prices and divs Part V - Adjusting historical data Part VI - Code posted  Downloading splits is a messy affair. The problem is that Yahoo doesn\u0026rsquo;t give you a nice comma-delimitated stream to work with. You have to parse the Html yourself (and it can be on multiple pages). At the end of the post, the overall result is kind of neat, but to get there we need a lot of busywork.\nFirst, let\u0026rsquo;s define a function that constructs the correct URL to download splits from. Notice that you need to pass a page number to it.\nlet splitUrl ticker span page = \"http://finance.yahoo.com/q/hp?s=\" + ticker + \"\u0026a=\"\n+ (span.Start.Month - 1).ToString() + \"\u0026b=\" + span.Start.Day.ToString() + \"\u0026c=\" + span.Start.Year.ToString() + \"\u0026d=\" + (span.End.Month - 1).ToString() + \"\u0026e=\"\n+ span.End.Day.ToString() + \"\u0026f=\" + span.End.Year.ToString() + \"\u0026g=v\u0026z=66\u0026y=\"\n+ (66 * page).ToString(); The reason for this particular url format (i.e. 66 * page) is completely unknown to me. I also have the feeling that it might change in the future. Or maybe not given how many people rely on it.\nI then describe the driver function for loading splits:\nlet rec loadWebSplitAsync ticker span page splits = let parseSplit text splits = List.append splits (parseSplits (scrapHtmlRows text)),\nnot(containsDivsOrSplits (scrapHtmlCells text)) async { let url = splitUrl ticker span page let! text = loadWebStringAsync url let splits, beyondLastPage = parseSplit text splits if beyondLastPage then return splits else\nreturn! loadWebSplitAsync ticker span (page + 1) splits } This is a bit convoluted (it is an Async recursive function). Let\u0026rsquo;s go through it in some detail. First there is a nested function parseSplit. It takes an html string and a list of observations and returns a tuple of two elements. The first element is the same list of observations augmented with the splits found in the text. The second element is a boolean that is true if we have navigated beyond the last page for the splits.\nThe function to test that we are beyond the last page is the following:\nlet containsDivsOrSplits cells = cells |\u0026gt; Seq.exists\n(fun (x:string) -\u0026gt; Regex.IsMatch(x, @\"$.+Dividend\", RegexOptions.Multiline)\n|| Regex.IsMatch(x, \"Stock Split\"))  This function just checks if the words Stock Split or Dividend are anywhere in the table. If they aren\u0026rsquo;t, then we have finished processing the pages for this particular ticker and date span.\nThe function to extract the splits observations from the web page takes some cells (a seq\u0026lt;seq\u0026gt;) as input and returns an observation list. It is reproduced below:\nlet parseSplits rows = let parseRow row = if row |\u0026gt; Seq.exists (fun (x:string) -\u0026gt; x.Contains(\"Stock Split\")) then let dateS = Seq.hd row let splitS = Seq.nth 1 row let date = DateTime.Parse(dateS) let regex = Regex.Match(splitS,@\"(d+)s+:s+(d+)s+Stock Split\",\nRegexOptions.Multiline) let newShares = shares (float (regex.Groups.Item(1).Value)) let oldShares = shares (float (regex.Groups.Item(2).Value)) Some({Date = date; Event = Split(newShares / oldShares)}) else None rows |\u0026gt; Seq.choose parseRow |\u0026gt; Seq.to_list It just take a bunch of rows and choose the ones that contain stock split information. For these, it parses the information out of the text and creates a Split Observation out of it. I think it is intuitive what the various Seq functions do in this case. Also note my overall addiction to the pipe operator ( |\u0026gt; ). In my opinion this is the third most important keyword in F# (after ‘let\u0026rsquo; and ‘match\u0026rsquo;).\nLet\u0026rsquo;s now go back to the loadWebSplitAsync function and discuss the rest of it. In particular this part:\nasync { let url = splitUrl ticker span page let! text = loadWebStringAsync url let splits, beyondLastPage = parseSplit text splits if beyondLastPage then return splits else\nreturn! loadWebSplitAsync ticker span (page + 1) splits } First of all it is an Async function. You should expect some Async stuff to go on inside it. And indeed, after forming the URL in the first line, the very next line is a call to loadWebStringAsync. We discussed this one in the previous installment. It just asynchronously loads a string from an URL. Notice the bang after ‘let\u0026rsquo;. This is your giveaway that async stuff is being performed.\nThe result of the async request is parsed to extract splits. Also, the beyondLastPage flag is set if we have finished our work. If we have, we return the split observation list; if we haven\u0026rsquo;t, we do it again incrementing the page number to load the html text from.\nNow that we have all the pieces in places, we can wrap up the split loading stuff inside this facade function:\nlet loadSplitsAsync ticker span = loadWebSplitAsync ticker span 0 []\n And finally put together the results of this post and the previous one with the overall function-to-rule-them-all:\nlet loadTickerAsync ticker span = async { let prices = loadPricesAsync ticker span let divs = loadDivsAsync ticker span let splits = loadSplitsAsync ticker span let! prices, divs, splits = Async.Parallel3 (prices, divs, splits) return prices |\u0026gt; List.append divs |\u0026gt; List.append splits } All right, that was a lot of work to get to this simple thing. This is a good entry point to our price/divs/split loading framework. It has the right inputs and outputs: it takes a ticker and a date span and returns an Async of a list of observations. Our caller can decide when he wants to execute the returned Async object.\nNotice that in the body of the function I call Async.Parallel. This is debatable. A more flexible solution is to return a tuple containing three Asyncs (prices, divs, splits) and let the caller decide how to put them together. I decided against this for simplicity reasons. This kind of trade-off is very common in Async programming: giving maximum flexibility to your caller against exposing something more understandable.\nI have to admit I didn\u0026rsquo;t enjoy much writing (and describing) all this boilerplate code. I\u0026rsquo;m sure it can be written in a better way. I might rewrite plenty of it if I discover bugs. I kind of like the end result though. loadTickerAsync has an overall structure I\u0026rsquo;m pretty happy with.\nNext post, some algorithms with our observations\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-09-19-downloading-stock-prices-in-f-part-iv-async-loader-for-splits/","tags":["fsharp","Financial"],"title":"Downloading stock prices in F# - Part IV - Async loader for splits"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part I - Data modeling Part II - Html scraping Part IV - Async loader for splits Part V - Adjusting historical data Part VI - Code posted  It is now time to load our data. There is a bit of uninteresting code to start with, but things get interesting afterward. Let\u0026rsquo;s start with functions that create the right URLs to download prices and dividends. We\u0026rsquo;ll talk about splits in the next installment.\nlet commonUrl ticker span = @\"http://ichart.finance.yahoo.com/table.csv?s=\" + ticker + \"\u0026a=\"\n+ (span.Start.Month - 1).ToString() + \"\u0026b=\" + span.Start.Day.ToString() + \"\u0026c=\"\n+ span.Start.Year.ToString() + \"\u0026d=\" + (span.End.Month - 1).ToString() + \"\u0026e=\" + span.End.Day.ToString() + \"\u0026f=\" + span.End.Year.ToString() let priceUrl ticker span = commonUrl ticker span + \"\u0026g=d\u0026ignore=.csv\" let divUrl ticker span = commonUrl ticker span + \"\u0026g=v\u0026ignore=.csv\" We will also need to construct an observation given a comma delimitated line of text. Again, for spits things will be harder.\nlet parsePrice (line: string) = let tokens = line.Split([|','|]) { Date = DateTime.Parse(tokens.[0]); Event = Price ({Open = money (Double.Parse(tokens.[1])) ;\nHigh = money (Double.Parse(tokens.[2])); Low = money (Double.Parse(tokens.[3])); Close = money (Double.Parse(tokens.[4]));\nVolume = volume (Double.Parse(tokens.[5]))})} let parseDiv (line: string) = let tokens = line.Split([|','|]) let date = DateTime.Parse(tokens.[0]) let amount = money (Double.Parse(tokens.[1])) {Date = date; Event = Div amount}  Nothing noteworthy about this code. We have a couple of other ‘infrastructure pieces before we get to the Async pieces. The next function is recursive. It takes a StringReader and reads lines out of it. For each line it calls a parsing function that takes the line as input and returns an object as output. The function gathers all such objects in the listOfThings list. If you are new to F# the following construct (parseLineFunc line:: listOfThings) means: execute the parseLineFunc with argument line, take the result and create a list that has the result as head and listOfThings as tail).\nlet rec loadFromLineReader (reader:StringReader) listOfThings parseLineFunc = match reader.ReadLine () with | null -\u0026gt; listOfThings | line -\u0026gt; loadFromLineReader reader (parseLineFunc line::listOfThings) parseLineFunc  The next function is rather uninteresting. It just converts a string to a StringReader, cut out the first line (header) and calls loadFromLineReader.\nlet loadFromLineString text listOfThings parseLineFunc = let reader = new StringReader(text) reader.ReadLine ()|\u0026gt; ignore // skip header loadFromLineReader reader listOfThings parseLineFunc We now come to the first Async function. But what is an Async function? There are several possible technically correct definition as: it is an instance of the monad pattern or it is a function that returns an Async object or it is a way to release your thread to the thread pool. These definition don\u0026rsquo;t help me much. I need something intuitive to latch one.\nThe way that I personally visualize it is: there are things in the world that are very good at executing certain tasks and like to be hit by multiple parallel requests for these tasks. They\u0026rsquo;d like me to give them their workload and get out of their way. They\u0026rsquo;ll call me when they are done with it. These ‘things\u0026rsquo; are disk drives, web servers, processors, etc Async is a way to say: hey, go and do this, call me when you are done.\nNow, you can call the asynchronous APIs directly, or you can use the nice F# language structures to do it. Let\u0026rsquo;s do the latter.\nlet loadWebStringAsync url = async { let req = WebRequest.Create(url: string) use! response = req.AsyncGetResponse() use reader = new StreamReader(response.GetResponseStream()) return! reader.AsyncReadToEnd()} This function retrieves a web page as a string asynchronously. Notice that even if the code looks rather normal, this function will likely be executed on three different thread. The first thread is the one the caller of the function lives on. The function AsyncGetResponse causes the thread to be returned to the thread pool waiting for a response back from the web server. Once such a response arrives, the execution resumes on a different thread until AsyncReadToEnd. That instruction returns the execution thread to the thread pool. A new thread is then instantiated when the string has been completely read. The good thing is that all of this is not explicitly managed by the programmer. The compiler ‘writes the code\u0026rsquo; to make it all happen. You just have to follow a set of simple conventions (i.e. putting exclamation marks in the right place).\nThe return result of this function is an Async, which is something that, when executed, returns a string. I cannot emphasize this enough: always look at the signature of your F# functions. Type inference can be tricky\nAsync is somehow contagious. If you are calling an Async function you have to decide if propagate the Asyncness to your callers or remove it by executing the function. Often propagating it is the right thing to do as your callers might want to batch your function with other aync ones to be executed together in parallel. Your callers have more information than you do and you don\u0026rsquo;t want to short-circuit them. The following function propagates ayncness.\nlet loadFromUrlAsync url parseFunc = async { let! text = loadWebStringAsync url return loadFromLineString text [] parseFunc} Let\u0026rsquo;s see how the functions presented to this point compose to provide a way to load prices and dividends (splits will be shown afterward).\nlet loadPricesAsync ticker span = loadFromUrlAsync (priceUrl ticker span) parsePrice let loadDivsAsync ticker span = loadFromUrlAsync (divUrl ticker span) parseDiv This composition of functions is very common in functional code. You construct your building blocks and assemble them to achieve your final goal. Functional programming is good at almost forcing you to identify the primitive blocks in your code. All right, next in line is how to load splits.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-09-12-downloading-stock-prices-in-f-part-iii-async-loader-for-prices-and-divs/","tags":["fsharp"],"title":"Downloading stock prices in F# - Part III - Async loader for prices and divs"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part I - Data modeling Part III - Async loader for prices and divs Part IV - Async loader for splits Part V - Adjusting historical data Part VI - Code posted  Getting stock prices and dividends is relatively easy given that, on Yahoo, you can get the info as a CVS file. Getting the splits info is harder. You would think that Yahoo would put that info in the dividends CVS as it does when it displays it on screen, but it doesn\u0026rsquo;t. So I had to write code to scrap it from the multiple web pages where it might reside. In essence, I\u0026rsquo;m scraping this.\nhtml.fs\nIn this file there are utility functions that I will use later on to retrieve split info.\n#light open System open System.IO open System.Text.RegularExpressions // It assumes no table inside table ... let tableExpr = \"\u0026lt;table[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;/table\u0026gt;\" let headerExpr = \"\u0026lt;th[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;/th\u0026gt;\" let rowExpr = \"\u0026lt;tr[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;/tr\u0026gt;\" let colExpr = \"\u0026lt;td[^\u0026gt;]*\u0026gt;(.*?)\u0026lt;/td\u0026gt;\" let regexOptions = RegexOptions.Multiline ||| RegexOptions.Singleline ||| RegexOptions.IgnoreCase This code is straightforward enough (if you know what Regex does). I\u0026rsquo;m sure that there are better expression to scrap tables and rows on the web, but these work in my case. I really don\u0026rsquo;t need to scrape tables. I put the table expression there in case you need it.\nI then write code to scrape all the cells in a piece of html:\nlet scrapHtmlCells html = seq { for x in Regex.Matches(html, colExpr, regexOptions) -\u0026gt; x.Groups.Item(1).ToString()}  This is a sequence expression. Sequence expressions are used to generate sequences starting from some expression (as the name hints to). In this case Regex.Matches returns a MatchClollection, which is a non-generic IEnumerable. For each element in it, we return the value of the first match. We could as easily have constructed a list or an array, given that there is not much deferred computation going on. But oh well\nAlways check the type of your functions in F#! With type inference it is easy to get it wrong. Hovering your mouse on top of it in VS shows it. This one is typed: string -\u0026gt; seq. It takes a string (html) and return a sequence of strings (the cells in html).\nWe\u0026rsquo;ll need rows as well.\nlet scrapHtmlRows html = seq { for x in Regex.Matches(html, rowExpr, regexOptions) -\u0026gt; scrapHtmlCells x.Value } This works about the same. I\u0026rsquo;m matching all the rows and retrieving the cells for each one of them. I\u0026rsquo;m getting back a matrix-like structure, that is to say that this function as type: string -\u0026gt; seq\u0026lt;seq\u0026gt;.\nThat\u0026rsquo;s all for today. In the next installment we\u0026rsquo;ll make it happen.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-09-05-downloading-stock-prices-in-f-part-ii-html-scraping/","tags":["fsharp"],"title":"Downloading stock prices in F# - Part II - Html scraping"},{"categories":["Uncategorized"],"contents":"Other parts:\n Part II - Html scraping Part III - Async loader for prices and divs Part IV - Async loader for splits Part V - Adjusting historical data Part VI - Code posted  Today we shipped the September CTP of F# !!!! Evviva !! Read this blog post about it. To celebrate I decided to share one of my several F# project. It might make for a good sample; sort of a crash course on F#.\nThis application downloads stock prices, dividends and splits from Yahoo Historical Prices and performs computations on them. I will describe it file by file.\ncommon.fs\nI always have such a file in my projects. It is a repository for the types that I\u0026rsquo;m going to use in my program and the functions that are common across multiple modules. If I have a large program I also have a types.fs just for the types.\nThis one starts like this:\n#light open System [\u0026lt;Measure\u0026gt;] type money let money (f:float) = f * 1.\u0026lt;money\u0026gt; [\u0026lt;Measure\u0026gt;] type shares let shares (f:float) = f * 1.\u0026lt;shares\u0026gt; [\u0026lt;Measure\u0026gt;] type volume let volume (f:float) = f * 1.\u0026lt;volume\u0026gt; [\u0026lt;Measure\u0026gt;] type rateOfReturn let rateOfReturn (f:float) = f * 1.\u0026lt;rateOfReturn\u0026gt; The first line instructs the compiler to use the lightweight syntax. You don't want to know what the heavyweight syntax is. Just always put such a line at the start of your files. The next line opens up the System namespace. Then the good stuff starts. I\u0026rsquo;m defining some units of measures. The simplest way to think about units of measures is: they are a type system for floats. You can do much more than that, but it is a good first approximation. For example, you cannot now sum a money type and a volume type. Also for each one I define a function that converts from a normal float type to it (if you come from a C# background, floats are doubles).\nThen I define the data model for my application:\ntype Span = { Start: DateTime; End: DateTime } type Price = { Open: float\u0026lt;money\u0026gt;; High: float\u0026lt;money\u0026gt;; Low:float\u0026lt;money\u0026gt;; Close:float\u0026lt;money\u0026gt;; Volume: float\u0026lt;volume\u0026gt;} type Event = | Price of Price | Split of float | Div of float\u0026lt;money\u0026gt; type Observation = { Date: DateTime; Event: Event} The first record that I define, Span, represents the difference between two dates. It is just a little useful thing. A more fundamental record is Observation. An Observation is defined as something that happens on a particular Date. That something, an Event, can be one of three things: a Price, a Split or a Div. A Price is another record with a bunch of float fields and on float field. If you go to the Yahoo site, you\u0026rsquo;ll see what it represents.\nA Split is simply a float. Why not a float\u0026lt;\u0026gt;? Because it is just a number, a factor to be precise. It represents the number of new shares divided by the number of old shares. float / float = float. A Div is a float.\nThis is one way to model the problem. Infinite other ways are possible (and I tried many of them in a C# version of this code that ended up using polymorphism). Note that all of the types are records except Event that is a discriminated union.\nRecords are read only containers of data. Discriminated unions are what the name says: things that can be one of multiple things (even recursively). They are rather handy to represent the structure of the data. We will see how you use them using the match operator in upcoming posts.\nAlso notice the following common pattern in F# (and functional programming in general). You define your data and then you define transformations over it. F# has a third optional step, that is to expose these transformations as methods of a .NET objects.\nWe are almost done here. A handful of other functions are in my file :\nlet span sy sm sd ey em ed =\n{Start = new DateTime(sy, sm, sd); End = new DateTime(ey, em, ed)} let date y m d = new DateTime(y, m, d) let now () = DateTime.Now let idem x = x let someIdem x = Some(x) Span is a function that creates a span given the relevant info. date creates a date given year, month and day. now is a value that corresponds to the current date. idem is a function that returns its parameter (you\u0026rsquo;ll see how that can possibly be useful). someIdem is a function that unpack an Option type and gives his value. I could write all my code without these things, but it looks better (to me) with them.\nNotice that in the F# code you have access to all the functions and type in the .NET framework. It is just another .NET language: it can create or consume .NET types.\nAll right, we are done for part one. In part II there will be some real code.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-08-29-downloading-stock-prices-in-f-part-i-data-modeling/","tags":["fsharp"],"title":"Downloading stock prices in F# - Part I - Data modeling"},{"categories":["Uncategorized"],"contents":"Other posts in the series:\n  Part I - Background\n  Part II - Tuples\n Part III - Records Part IV - Type Unions{.} Part V - The Match operator{.} This is my last post of this series. It is about the match operator. To the untrained eyes this operator might look like a case statement. But they are different.  The match operator combines control flow and decomposition in a single construct. As it often happens, even if these two things are well known concepts, putting them together gives you a different perspective on your code.\nI have to admit that the similarity with a case statement triggered all sorts of bad reactions in my OO trained mind. Phrases from wise gurus on the tone of never use an ‘if\u0026rsquo; statement was echoing in my mind. After a while I got over it and enjoyed the power that this operator gives.\nIn this library we won\u0026rsquo;t get close to the beauty of the match operator in functional languages (i.e. F#), especially the decomposition piece. There might be a way to do better than this in C#, but this was enough for my purpose of learning about functional programming, so I didn\u0026rsquo;t investigate further. Learning was my real goal.\nHow to use it\nThere are two versions of this operator. Let\u0026rsquo;s start from the more eye pleasing one.\nLet\u0026rsquo;s assume a discriminated union like the following:\npublic class Node : TypeUnion\u0026lt;int, string\u0026gt; {   public Node(int i) : base(i) { } public Node(string s) : base(s) { } public int IntNode { get { return Type1; } } public string StringNode { get { return Type2; } } }\nI can then match against this union with the following code: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;var \u0026lt;/span\u0026gt;no = \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Node\u0026lt;/span\u0026gt;(35);    r = F.Match(no, (int i) =\u0026gt; (i + 3).ToString(), (string s) =\u0026gt; s\n); Assert.AreEqual(\u0026quot;38\u0026quot;, r);\n Note that the _match_ operator behaves a bit like a case statement, but it also gives you the \u0026amp;#8216;right' type on the right of the \u0026amp;#8216;=\u0026gt;' for you to write code against. I have to admit I'm rather happy of this syntax, but it has one severe limitation. You need to specify all the types of the type union and they have to be in the same order. For example, in the previous code I cannot match against _string_ first and _int_ second. I consider this to be a big deal. A different implementation of match that doesn't have that limitation is as follows: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;no = \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Node\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:#a31515;\u0026quot;\u0026gt;\u0026quot;35\u0026quot;\u0026lt;/span\u0026gt;);  r = F.Match(no, n =\u0026gt; n.Is\u0026lt;int\u0026gt;(), n =\u0026gt; (n.As\u0026lt;int\u0026gt;() + 3).ToString(), n =\u0026gt; n.Is\u0026lt;string\u0026gt;(),n =\u0026gt; n.As\u0026lt;string\u0026gt;()); Assert.AreEqual(\u0026quot;35\u0026quot;, r);\n Rather less pleasing to the eyes, but more robust to use. By using this more generic version, you can obviously match against all the constructs we described in this series. I.E. against _Tuples_: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;var \u0026lt;/span\u0026gt;t = \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.Tuple(\u0026lt;span style=\u0026quot;color:#a31515;\u0026quot;\u0026gt;\u0026quot;msft\u0026quot;\u0026lt;/span\u0026gt;, 10, \u0026lt;span style=\u0026quot;color:#a31515;\u0026quot;\u0026gt;\u0026quot;Nasdaq\u0026quot;\u0026lt;/span\u0026gt;);  var r = F.Match(t, i =\u0026gt; i.Item2 \u0026lt; 5 \u0026amp;\u0026amp; i.Item3 == \u0026quot;OTC\u0026quot;, i =\u0026gt; i.Item1 + \u0026rdquo; is low price OTC stock\u0026quot;, i =\u0026gt; i.Item3 == \u0026quot;OTC\u0026quot;,\ni =\u0026gt; i.Item1 + \u0026quot;is a normal OTC stock\u0026quot;, i =\u0026gt; i.Item3 == \u0026quot;Nasdaq\u0026quot;, i =\u0026gt; i.Item1 + \u0026rdquo; is a Nasdaq stock\u0026quot;); Assert.AreEqual(\u0026quot;msft is a Nasdaq stock\u0026quot;, r);\n \u0026amp;nbsp; Or against sequences: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;var \u0026lt;/span\u0026gt;i1 = \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;new int\u0026lt;/span\u0026gt;[] { 1, 2, 3, 4, 5, 6, 7 };  var r1 = F.Match(i1, s =\u0026gt; s.SequenceEqual(new int[] { 1, 2}), s =\u0026gt; s.Where(i =\u0026gt; i \u0026lt; 4), s =\u0026gt; s.First() == 2, s =\u0026gt; s.Where(i =\u0026gt; i == 1), s =\u0026gt; s.Last() == 6, s =\u0026gt; s.Select(i =\u0026gt; i * i), s =\u0026gt; true, s =\u0026gt; s.Where(i =\u0026gt; i \u0026lt; 7)); Assert.IsTrue(i1.Take(6).SequenceEqual(r1));\n The match operator, as I defined it, is very flexible (probably too flexible as it doesn't use the type system to enforce much). **How it is implemented** Let's start from the special _match_ against union types: the one that is beautiful but flawed. Its implementation looks just like this (I just show the two parameters version): \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;public static \u0026lt;/span\u0026gt;R Match\u0026amp;lt;T1, T2, R\u0026amp;gt;(\u0026lt;br /\u0026gt; \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;this \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;TypeUnion\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt; u,\u0026lt;br /\u0026gt; \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Func\u0026lt;/span\u0026gt;\u0026amp;lt;T1, R\u0026amp;gt; f1, \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Func\u0026lt;/span\u0026gt;\u0026amp;lt;T2, R\u0026amp;gt; f2) { \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;if \u0026lt;/span\u0026gt;(u.Is\u0026amp;lt;T1\u0026amp;gt;()) \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return \u0026lt;/span\u0026gt;f1(u.As\u0026amp;lt;T1\u0026amp;gt;()); \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;if \u0026lt;/span\u0026gt;(u.Is\u0026amp;lt;T2\u0026amp;gt;()) \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return \u0026lt;/span\u0026gt;f2(u.As\u0026amp;lt;T2\u0026amp;gt;()); \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;throw new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Exception\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:#a31515;\u0026quot;\u0026gt;\u0026quot;No Match for this Union Type\u0026quot;\u0026lt;/span\u0026gt;);  }\n It is easy to see the reason for the limitations of this function. The same thing that gives you type inference (nice to look at) also gives you the problem with the ordering of lambdas. Also note the I originally intended to have these as extension methods. In practice I ended up liking more the F.Match syntax. De gustibus I assume The more general version looks like this: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;public static \u0026lt;/span\u0026gt;R Match\u0026amp;lt;T, R\u0026amp;gt;(\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;this \u0026lt;/span\u0026gt;T t, \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Func\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\u0026amp;gt; match1, \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Func\u0026lt;/span\u0026gt;\u0026amp;lt;T, R\u0026amp;gt; func1, \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Func\u0026lt;/span\u0026gt;\u0026amp;lt;T, \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt;\u0026amp;gt; match2, \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Func\u0026lt;/span\u0026gt;\u0026amp;lt;T, R\u0026amp;gt; func2) { \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;if \u0026lt;/span\u0026gt;(match1(t)) \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return \u0026lt;/span\u0026gt;func1(t); \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;if \u0026lt;/span\u0026gt;(match2(t)) \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return \u0026lt;/span\u0026gt;func2(t); \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;throw new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Exception\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:#a31515;\u0026quot;\u0026gt;\u0026quot;Nothing matches\u0026quot;\u0026lt;/span\u0026gt;);  }\n Again, it is easy to see in the implementation that this is an extremely general thing: a glorified case statement really. This is the beauty of it (you can match against anything) and the ugliness of it (you can write anything as _match1_ of _func1_, even code that doesn't reference _t_ at all). **How to use this series to learn functional programming** Here is how I did it (it worked for me). Take this library and force yourself to write a medium size program using \u0026lt;u\u0026gt;just\u0026lt;/u\u0026gt; these constructs. I mean it. No objects, just records. No inheritance, just discriminated unions. Tuples to return values. Match operators everywhere. No iteration statements (for, while, etc), just recursion. Extensive use of sequence operators. After a while I noticed that all my functions had the same pattern: they just match against the input and produce an output, usually by calling other functions or recursively calling themselves. Obviously, this is overcompensating. After a while you will realize the different trade offs that come with a functional vs OO style of programming. At that point you'll be able to get the best of the two. Or maybe you'll be royally confused At that point I picked up F# and I'm now enjoying the fact that all these constructs are directly embedded in the language (and yes, you can use while statements too). ","permalink":"https://peaceiris.com/MyBlog/posts/2008-07-15-a-c-library-to-write-functional-code-part-v-the-match-operator/","tags":["csharp"],"title":"A C# library to write functional code - Part V - The Match operator"},{"categories":["Uncategorized"],"contents":"Other posts in the series:\n Part I - Background   Part II - Tuples\n Part III - Records Part IV - Type Unions{.} Part V - The Match operator{.} I\u0026rsquo;m sorry for my prolonged absence in the middle of this series of posts. I\u0026rsquo;m on a long paternity leave in Italy (playing beach volley every day). It\u0026rsquo;s hard to have the discipline  A bunch of you wrote telling me to finish this. So here I go: let\u0026rsquo;s talk about type unions. First of all: they are not called like that. The correct name is discriminated unions. I have no idea why I call them differently, but I want to be consistent with my previous mistake.\nFor those of you with a C++ background (like myself) they are like unions, just better (or worse depending on your convictions). They let you define a type that can represent one of several different types. You can then use the ‘match\u0026rsquo; operator (discussed in the next post) to pattern match against it.\nI won\u0026rsquo;t elaborate on the pros and cons of this style of programming versus using polymorphism. I just want to show you how I implemented this construct in C#. As always, my usual caveat: this is just ‘educational code\u0026rsquo;, use it at your own risk, no extensive or perf related test has been done on it. You can download the zip file and check my unit tests for yourself.\nHow type unions are used\nIn my world, you declare a type union like this:\npublic class Person { }     public class Dog { } public class Friend : TypeUnion\u0026lt;Person, Dog\u0026gt; { public Friend(Person p) : base(p) { } public Friend(Dog d) : base(d) { } }\n You inherit a type union from the TypeUnion class and use generic parameters that correspond to the types that the union can represent. You can then create a type union as: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;var \u0026lt;/span\u0026gt;fr = \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Friend\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;());\u0026lt;/pre\u0026gt; Test its type by: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Assert\u0026lt;/span\u0026gt;.IsTrue(fr.Is\u0026amp;lt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;\u0026amp;gt;());  Assert.IsFalse(fr.Is\u0026lt;Person\u0026gt;());\n Cast it to one of the types they represent: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;var \u0026lt;/span\u0026gt;d = fr.As\u0026amp;lt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;\u0026amp;gt;();\u0026lt;/pre\u0026gt; Or use it with the \u0026amp;#8216;match' operator (fully explained in an upcoming post): \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;var \u0026lt;/span\u0026gt;r = \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.Match(fr, f =\u0026amp;gt; f.Is\u0026amp;lt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;\u0026amp;gt;(), f =\u0026amp;gt; f.As\u0026amp;lt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Dog\u0026lt;/span\u0026gt;\u0026amp;gt;().ToString(), f =\u0026amp;gt; f.Is\u0026amp;lt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;\u0026amp;gt;(), f =\u0026amp;gt; f.As\u0026amp;lt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Person\u0026lt;/span\u0026gt;\u0026amp;gt;().ToString());  Assert.AreEqual(r, new Dog().ToString());\n Or the slightly more pleasing: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;r = \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.Match(fr, (\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Person \u0026lt;/span\u0026gt;p) =\u0026amp;gt; p.ToString(), (\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Dog \u0026lt;/span\u0026gt;d) =\u0026amp;gt; d.ToString());  Assert.AreEqual(r, new Dog().ToString());\n You get the idea. **How they are implemented** Nothing really sophisticated going on here. Let's take as an example a type union that can represent two types. I have versions that go to 5 types in the zip file. First of all a TypeUnion is a Record: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;public class \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;TypeUnion\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt; : \u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Record\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt; {\u0026lt;/pre\u0026gt; It has overloaded constructors to create a type union of a particular type: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;public \u0026lt;/span\u0026gt;TypeUnion(T1 t1) : \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;base\u0026lt;/span\u0026gt;(t1, \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;default\u0026lt;/span\u0026gt;(T2)) { UnionType = t1.GetType();  } public TypeUnion(T2 t2) : base(default(T1), t2) { UnionType = t2.GetType(); }\n UnionType is used to \u0026amp;#8216;remember' which type it is: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;protected \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Type \u0026lt;/span\u0026gt;UnionType;\u0026lt;/pre\u0026gt; It also has properties to return the objects of all the types that can be stored: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;protected \u0026lt;/span\u0026gt;T1 Type1 { \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;get \u0026lt;/span\u0026gt;{ \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return \u0026lt;/span\u0026gt;state.Item1; } }  protected T2 Type2 { get { return state.Item2; } }\n The \u0026amp;#8216;Is' operator is simply implemented as: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;public bool \u0026lt;/span\u0026gt;Is\u0026amp;lt;K\u0026amp;gt;() { \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return typeof\u0026lt;/span\u0026gt;(K).IsAssignableFrom(UnionType);  }\n And the \u0026amp;#8216;As' operator looks like so: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;public \u0026lt;/span\u0026gt;K As\u0026amp;lt;K\u0026amp;gt;() { \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;if \u0026lt;/span\u0026gt;(!Is\u0026amp;lt;K\u0026amp;gt;()) \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;throw new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Exception\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;.Format(\u0026lt;br /\u0026gt; \u0026lt;span style=\u0026quot;color:#a31515;\u0026quot;\u0026gt;\u0026quot;In a TypeUnion cannot cast from {0} to {1}\u0026quot;\u0026lt;/span\u0026gt;,\u0026lt;br /\u0026gt; UnionType.Name, \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(K).Name)); \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;if \u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T1) == UnionType) \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return \u0026lt;/span\u0026gt;(K)(\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;) Type1; \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;if \u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;typeof\u0026lt;/span\u0026gt;(T2) == UnionType) \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;return \u0026lt;/span\u0026gt;(K)(\u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;) Type2; \u0026lt;span style=\u0026quot;color:blue;\u0026quot;\u0026gt;throw new \u0026lt;/span\u0026gt;\u0026lt;span style=\u0026quot;color:#2b91af;\u0026quot;\u0026gt;Exception\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:#a31515;\u0026quot;\u0026gt;\u0026quot;Shouldn't get here\u0026quot;\u0026lt;/span\u0026gt;);  }\n I leave as an exercise to the reader to understand what happens if T1 and T2 are the same type or inherit from the same type. I could have written code to handle this case in a more explicit manner, but didn't. Also, by reviewing my code I found an obvious bug in my Is\u0026lt;K\u0026gt;/As\u0026lt;K\u0026gt; code. I fixed it and re-posted the zip file in the second post of this series. Now back to the beach. Next post is on the \u0026amp;#8216;match' operator. ","permalink":"https://peaceiris.com/MyBlog/posts/2008-06-06-a-c-library-to-write-functional-code-part-iv-type-unions/","tags":["csharp"],"title":"A C# library to write functional code - Part IV - Type Unions"},{"categories":["Uncategorized"],"contents":"Other posts in the series:\n  Part I - Background\n  Part II - Tuples\n Part III - Records Part IV - Type Unions{.} Part V - The Match operator{.} Now that we know what Tuples are, we can start talking about Record, as they use a derivative of Tuples under the cover. But first, what is a record?  Well, in C# parlance a Record is a sort of immutable value object. I talked at length about these fellows in this series of blog posts. In functional parlance, a Record is a Tuple that lets you access its items by name.\nYou code Records like this:\npublic class Order: Record\u0026lt;string, int\u0026gt; { public Order(string item, int qty): base(item,qty) {} public string Item { get { return state.Item1;}} public int Quantity { get { return state.Item2; } }   } public class Customer: Record\u0026lt;string, IEnumerable\u0026lt;Order\u0026gt;\u0026gt; { public Customer(string name, IEnumerable\u0026lt;Order\u0026gt; orders) : base(name, orders) { } public string Name { get { return state.Item1; } } public IEnumerable\u0026lt;Order\u0026gt; Orders { get { return state.Item2; } } }\nYou need to do three things: 1. Inherit from a generic Record class specifying the types\u0026amp;nbsp;of the properties as parameters 2. Add a constructor that calls back to the\u0026amp;nbsp;Record constructor 3. Add getters to retrieve the values of the properties (no setters as it is immutable) This may seem like plenty of work, but in return you get structural equality. Coding that by hand every time you use a record would be a royal pain. You lose control of the base class, but that is often not a problem as in functional-land you more often use type unions than inheritance. How is it implemented? First of all it is an abstract class with as many generic parameters as properties that you need in your Record. Let's use two as an example. \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;abstract\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Record\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt; {    \n This abstract class has a field of type STuple: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;protected\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;readonly\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;STuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt; state;  \n What is a STuple? Well it is exactly the same as the Tuple described in Part II, but coded as a struct instead of a class. The reason to use a struct is to not allocate an additional object on the stack. This allows this solution to be as \u0026amp;#8216;performant' as simply having coded the fields on the class itself. Or at least I think so The Record class also has a constructor that simply initialize the STuple: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Record(T1 t1, T2 t2) { state = \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.STuple(t1, t2); }\u0026lt;/pre\u0026gt; \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;font face=\u0026quot;Verdana\u0026quot;\u0026gt;where\u0026lt;/font\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;internal\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;STuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt; STuple\u0026amp;lt;T1, T2\u0026amp;gt;(T1 t1, T2 t2) { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;STuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt;(t1, t2); }\u0026lt;/pre\u0026gt; The Equals method is very much the same as the Tuple's one, just delegating to the same DSEqual function that checks equality for Tuples. \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; Equals(\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; right) { \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Utils\u0026lt;/span\u0026gt;.CheckNull(right); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;.ReferenceEquals(\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, right)) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.GetType() != right.GetType()) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; rightT = right \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Record\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2\u0026amp;gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.DSEquals(\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.state, rightT.state); }\u0026lt;/pre\u0026gt; That's it. Not too difficult as most of the implementation is based on the Tuple's code. Next post will hopefully be more interesting. It is about Type Unions. ","permalink":"https://peaceiris.com/MyBlog/posts/2008-04-21-a-c-library-to-write-functional-code-part-iii-records/","tags":["csharp"],"title":"A C# library to write functional code - Part III - Records"},{"categories":["Uncategorized"],"contents":"Other posts in the series:\n Part I - Background   Part II - Tuples\n Part III - Records Part IV - Type Unions{.} Part V - The Match operator{.} Tuples are a way for you not to name things. In Object Oriented languages you got to name everything. If you need to represent a bunch of data, you create a class for it.  There is a strange asymmetry in mainstream OO languages in that you can pass multiple parameters to a function, but you can return just one value. Granted, there are ways around it: you can use ‘ref\u0026rsquo; in C# or return some sort of collection where things are stored. But by and large the model is: you pass many, you get one; if you need to return more than one, create a class to represent this ‘bunch of data\u0026rsquo;. Tuples are a way for you not to create such a class.\nTuples are also much more than that. Once you have the language concept of ‘a bunch of data without a name\u0026rsquo;, you can create arrays of them, you can pass them as parameters, use them as local variables. Wherever you\u0026rsquo;d use a type, you can use a Tuple instead.\nThis is particularly appealing to me as I like to use classes almost exclusively to represent things that have a counterpart in the domain I\u0026rsquo;m modeling (i.e. Customer, Account). I don\u0026rsquo;t like to create classes/structs just for the sake of temporarily put some data together.\nYou can create your own Tuple class in C#, but the syntax gets ugly. Syntax matter. Syntax helps you to think differently about your program. We have syntax for anonymous types, but given that they cannot escape the scope of a method, they cannot be used as full replacement for Tuples.\nIn any case, to my implementation. Here is how you create a Tuple:\nvar t1 = F.Tuple(34, \"bo\", 2.3); not too bad. In F# it is better: (34, bo, 2.3). And you often don\u0026rsquo;t need the parenthesis. But still, my C# version is ok.\nYou then need to access its elements:\nvar n = t1.Item1; var s = t1.Item2;     \n In F# you usually access them by doing pattern matching, which gives a more intuitive syntax. But again, my C# syntax is not terrible.\u0026amp;nbsp; Tuples need to have structural equality, which means that the following has to work: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt; mad1 = \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt; }, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt; } },\u0026lt;br /\u0026gt; 32, \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] { 4, 5, 6 } }; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt; mad2 = \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt; }, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt; } },\u0026lt;br /\u0026gt; 32, \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] { 4, 5, 6 } }; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt; mad3 = \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ArrayList\u0026lt;/span\u0026gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;List\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt; }, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt; } },\u0026lt;br /\u0026gt; 32, \u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;bo\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;[] { 4, 5, 5 } };\u0026lt;/pre\u0026gt; \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Assert\u0026lt;/span\u0026gt;.AreEqual(\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.Tuple(mad1, mad2, mad1), \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.Tuple(mad2, mad1, mad2)); \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Assert\u0026lt;/span\u0026gt;.AreNotEqual(\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.Tuple(mad1, mad2, mad1), \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.Tuple(mad1, mad3, mad1));\u0026lt;/pre\u0026gt; You can use Tuples as return values, parameters, locals etc. Unfortunately, the syntax is ugly when Tuples are part of the signature of a function: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ObservationHistory\u0026lt;/span\u0026gt;\u0026amp;gt;\u0026amp;gt;\u0026amp;gt; Execute() { }\u0026lt;/pre\u0026gt; With the above information, you can be a user of Tuples. From this point on, I'll talk about some details of the implementation (I also attach the full code to this post as a zip file). \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1\u0026amp;gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Tuple(T1 t1) { Item1 = t1; } \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;readonly\u0026lt;/span\u0026gt; T1 Item1;  #regionEquals, GetHashCode, ==, != } public class Tuple\u0026lt;T1, T2\u0026gt; : Tuple\u0026lt;T1\u0026gt; { public Tuple(T1 t1, T2 t2) : base(t1) { Item2 = t2; } public readonly T2 Item2; #regionEquals, GetHashCode, ==, !=  }\n \u0026amp;nbsp; So, Tuples are classes, not structs. The reason for it is fully described in \u0026lt;a href=\u0026quot;http://blogs.msdn.com/lucabol/archive/2008/01/11/creating-an-immutable-value-object-in-c-part-v-using-a-library.aspx\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;font color=\u0026quot;#006bad\u0026quot;\u0026gt;this series of posts\u0026lt;/font\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;. They also inherit from one another. There are pros and cons to that. The main pros are that I had to write less code and that you can pass a Tuple\u0026lt;int, string\u0026gt; when a function expects a Tuple\u0026lt;int, string, int\u0026gt;. The main drawback is that you can pass a Tuple\u0026lt;int, string\u0026gt; when a function expects a Tuple\u0026lt;int, string, int\u0026gt;.\u0026amp;nbsp; Also notice the use of public fields. These\u0026amp;nbsp;is a problem with frameworks that insist on properties (i.e. Data Binding). Also, I just got to 5 as arity goes. The day I need 6 items, I'll add another one. It is boilerplate code (that I'd still like not to write). The Equals method is a bit convoluted: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;internal\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Utils\u0026lt;/span\u0026gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; CheckNull\u0026amp;lt;T\u0026amp;gt;(T t) { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (t == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;throw\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;ArgumentNullException\u0026lt;/span\u0026gt;(); }\u0026lt;br /\u0026gt; }\u0026lt;/pre\u0026gt; \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; Equals(\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt; right) { \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Utils\u0026lt;/span\u0026gt;.CheckNull(right); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;object\u0026lt;/span\u0026gt;.ReferenceEquals(\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;, right)) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.GetType() != right.GetType()) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; rightT = right \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2, T3\u0026amp;gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;base\u0026lt;/span\u0026gt;.Equals(rightT) \u0026amp;\u0026amp; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;F\u0026lt;/span\u0026gt;.DSEquals(\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;this\u0026lt;/span\u0026gt;.Item3, rightT.Item3); }\u0026lt;/pre\u0026gt; I always get complaints when I show Equals methods that throw if null is passed in, but I stand by my logic, that\u0026amp;nbsp;the presence of null for these categories of\u0026amp;nbsp;\u0026amp;#8216;structurally equal' classes is symptom of an error and I want to be notified.\u0026amp;nbsp;Returning false doesn't do that. \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;internal\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; DSEquals\u0026amp;lt;T\u0026amp;gt;(T left, T right) { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (left == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026amp;\u0026amp; right == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;true\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (left == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026amp;\u0026amp; right != \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; len = left \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; ren = right \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;as\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (len == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026amp;\u0026amp; ren == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; left.Equals(right); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (len == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026amp;\u0026amp; ren != \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (len != \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt; \u0026amp;\u0026amp; ren == \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;null\u0026lt;/span\u0026gt;) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; SequenceEqual(len, ren); }\u0026lt;/pre\u0026gt; DSEquals check the content of the Tuple and forward to SequenceEqual in case one slot of the Tuple contains an IEnumerable. \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;internal\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; SequenceEqual(\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt; en1, \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;IEnumerable\u0026lt;/span\u0026gt; en2) { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; enumerator = en2.GetEnumerator(); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;foreach\u0026lt;/span\u0026gt; (\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; o \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;in\u0026lt;/span\u0026gt; en1) { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!enumerator.MoveNext()) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (!DSEquals(o, enumerator.Current)) \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;false\u0026lt;/span\u0026gt;; }  \n SequenceEqual checks that the number of items in the enumerator is the same and recursively calls DSEqual to check structural equality for items at the same index in the two enumerators. GetHashCode is trivial (and maybe trivially wrong, one of these days I'll learn everything about GetHashCode() ). \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; GetHashCode() { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;base\u0026lt;/span\u0026gt;.GetHashCode() | Item3.GetHashCode(); }\u0026lt;/pre\u0026gt; The equality operators are equally simple. \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; ==(\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2, T3\u0026amp;gt; t1, \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2, T3\u0026amp;gt; t2) { \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Utils\u0026lt;/span\u0026gt;.CheckNull(t1); \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Utils\u0026lt;/span\u0026gt;.CheckNull(t2); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; t1.Equals(t2); } \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;bool\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; !=(\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2, T3\u0026amp;gt; t1, \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Tuple\u0026lt;/span\u0026gt;\u0026amp;lt;T1, T2, T3\u0026amp;gt; t2) { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; !(t1 == t2); }\u0026lt;/pre\u0026gt; And ToString() prints my favorite Tuple format. \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;override\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; ToString() { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;.Format(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;{0},{1}\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;base\u0026lt;/span\u0026gt;.ToString(), Item3.ToString()); }\u0026lt;/pre\u0026gt; I'm sure you can find plenty of issues in this code. As always, it is not \u0026amp;#8216;production ready', it is more \u0026amp;#8216;Luca having fun doing it'. In any case, there are some testcases in the solution to check the extent of my testing. In the next post we'll look at Records. [Functional.zip](https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Components.PostAttachments/00/08/36/99/78/Functional.zip) ","permalink":"https://peaceiris.com/MyBlog/posts/2008-04-08-a-c-library-to-write-functional-code-part-ii-tuples/","tags":["csharp"],"title":"A C# library to write functional code - Part II - Tuples"},{"categories":["Uncategorized"],"contents":"Other posts in the series:\n Part I - Background   Part II - Tuples\n Part III - Records Part IV - Type Unions{.} Part V - The Match operator{.} In December (slow time in msft) I decided to understand what functional programming is all about. When I say ‘understanding\u0026rsquo; I don\u0026rsquo;t mean just paying lip service to the main concepts by knowingly mentioning them in casual conversations (i.e. look at this memoization, man! or this lambda function is so hot!. I can already do that. I intellectually know what the thing is.  I wanted to *really* understand it. For me that means writing plenty of code. I had a medium size application in my mind that I\u0026rsquo;ve been wanting to write for quite some time (stock price, dividends, splits downloading and various return calculations), so I went ahead and wrote it. I also wanted to use C#. It would have been easier in F#, but I work on the C# team and love using our own product.\nMy early attempts were unpleasing. I would fall back to my OO background and my functional code slowly reverted to OO code. My way of thinking about it, even if starting with the best intentions, would go back to: what are the objects, what are their responsibilities and such.\nI needed to force myself somehow; kind of overcompensate on the other side. I hit on the idea of pragmatically defining functional programming and try to limit myself to the subset of language constructs inside my definition. As a way to define it, I used Chapter 3 of Expert F#. I know, I know, I could have read 1,000s of academic papers and come up with a meta-analysis of all of them that formally defines what ‘functional programming\u0026rsquo; really is. But life is too short. I trusted Don.\nThe problem is, several of the language constructs in my small definition of functional programming don\u0026rsquo;t exist in C#. So I went ahead and created them. I built a little library to represent them and forced myself to write code using just this library. It worked.\nIn this series of posts I will describe what\u0026rsquo;s inside this library. I want to emphasize that I built it for educational purpose only, not for performance or production code. Caveat emptor.\nMy plan is to cover the following:\n Tuples  Records  Type Unions  Match Let\u0026rsquo;s see if I can find the time to actually write these posts 🙂            ","permalink":"https://peaceiris.com/MyBlog/posts/2008-04-01-a-c-library-to-write-functional-code-part-i-background/","tags":["csharp"],"title":"A C# library to write functional code - Part I - Background"},{"categories":["Uncategorized"],"contents":"This is my presentation from TechEd Barcelona: The link has been fixed. It should work now. Let me know if it doesn\u0026rsquo;t. http://www.microsoft.com/emea/msdn/spotlight/sessionh.aspx?videoid=716. The European locale brings out my Italian accent\n On this page there are a bunch of interesting presentations (i.e. Anders on LINQ): http://www.microsoft.com/emea/msdn/spotlight/default.aspx\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-03-03-linq-to-sql-overview-video/","tags":["csharp"],"title":"LINQ to SQL Overview - video"},{"categories":["Uncategorized"],"contents":"Other posts:\n  Part I - Using a class\n  Part II - Making the class better\n Part III - Using a struct Part IV - A class with a special value In the last post we presented a variation of implementing a value object using a class. Everything works (obviously), but the amount of code to write is unpleasing. In this post we examine a library based solution. I just describe how to use the Record class, not how it is implemented. You can read the attached implementation code (it is in functional.cs). There is much more in there than Record\u0026lt;\u0026gt;. I\u0026rsquo;ll talk about the rest in a (hopefully) upcoming series.  To use the record class you need to inherit from it, as in:\npublic class DateSpan: Record\u0026lt;DateTime, DateTime, bool\u0026gt; {...} The generic argument types represent the types that comprise the (immutable) state of the object. You then need a friendly way for folks to access this state:\npublic DateTime Start { get { return state.Item1; } }   public DateTime End { get { return state.Item2; } } public bool HasValue { get { return state.Item3; } } \nThis is all you have to do. You don't need to implement Equals, ==, != and GetHashCode. Structural equivalence is given to you by the Record class. Such a property is recursive, in the sense that you can embed value objects inside other value objects and the implementation would walk your object graph as necessary. For example, given the following class hierarchy: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;class\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;: \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Record\u0026lt;/span\u0026gt;\u0026amp;lt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt;\u0026amp;gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; Order(\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; item, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; qty): \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;base\u0026lt;/span\u0026gt;(item,qty) {} \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;string\u0026lt;/span\u0026gt; Item { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; state.Item1;}} \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; Quantity { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;get\u0026lt;/span\u0026gt; { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; state.Item2; } }  } public class Customer: Record\u0026lt;string, IEnumerable\u0026lt;Order\u0026gt;\u0026gt; { public Customer(string name, IEnumerable\u0026lt;Order\u0026gt; orders) : base(name, orders) { } public string Name { get { return state.Item1; } } public IEnumerable\u0026lt;Order\u0026gt; Orders { get { return state.Item2; } } }\nThe following test case succeed: \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;[\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;TestMethod\u0026lt;/span\u0026gt;] \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;void\u0026lt;/span\u0026gt; Record2Test() { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c1 = \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;Luca\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;car\u0026quot;\u0026lt;/span\u0026gt;,1), \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;stereo\u0026quot;\u0026lt;/span\u0026gt;, 3)}); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c11 = \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;Luca\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;car\u0026quot;\u0026lt;/span\u0026gt;, 1), \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;stereo\u0026quot;\u0026lt;/span\u0026gt;, 3) }); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c2 = \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;Bob\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;car\u0026quot;\u0026lt;/span\u0026gt;, 1), \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;stereo\u0026quot;\u0026lt;/span\u0026gt;, 3) }); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;var\u0026lt;/span\u0026gt; c3 = \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Customer\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;Bob\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;[] { \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;car\u0026quot;\u0026lt;/span\u0026gt;, 1), \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;new\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Order\u0026lt;/span\u0026gt;(\u0026lt;span style=\u0026quot;color:rgb(163,21,21);\u0026quot;\u0026gt;\u0026quot;stereo\u0026quot;\u0026lt;/span\u0026gt;, 2) }); \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Assert\u0026lt;/span\u0026gt;.AreEqual(c1, c11); \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Assert\u0026lt;/span\u0026gt;.AreNotEqual(c1, c2); \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Assert\u0026lt;/span\u0026gt;.AreNotEqual(c1, c3); \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Assert\u0026lt;/span\u0026gt;.AreNotEqual(c2, c3); }\u0026lt;/pre\u0026gt; Please don't take my library as production ready code. The amount of test I put into it is limited. You can probably find obvious bugs with it. Let's look at other drawbacks. The biggest one is that I'm stealing your base class. If you want your value object to inherit from something else, you cannot. You cannot even have value objects inherit from each other. In that case you are back to implementing your own Equals, == and so on. The only tools at your disposal are interfaces and composition. Another drawback is that writing classes in this way is slightly unnatural. You have to think about the \u0026amp;#8216;type' of your state in the declaration of the class itself instead of more naturally writing it closer to where you assign names to it (property/field declaration). Having considered these drawbacks, I'm using this library in all my code wherever I need value objects (which is almost everywhere these days). Writing all the Equals explicitly is too error prone for my taste. I will also be creating IDE snippets for myself that make writing these classes easier. I don't think I have anything else to say on this topic, so this will be my last post on it. If something else comes up, I'll let you know. [TimeLineUsingRecord.zip](https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Components.PostAttachments/00/07/07/77/13/TimeLineUsingRecord.zip)   ","permalink":"https://peaceiris.com/MyBlog/posts/2008-01-11-creating-an-immutable-value-object-in-c-part-v-using-a-library/","tags":["csharp"],"title":"Creating an immutable value object in C# - Part V - Using a library"},{"categories":["Uncategorized"],"contents":"When I read Built to Last, In search of excellent and Good to great I immediately thought: What a bunch of BS!!. But again, I think that about most business books.\nThe content of these books seemed particularly ludicrous to me. I found both logical inconsistencies and methodological flaws in their process. For example, picking successful companies after the fact is analogous to picking the winners of a lottery and claim that they have exceptional skills. Betting the farm on a single concept (i.e. Big Hairy Goal) is clearly the right thing when you are right, but most often than not you are wrong. What about all the companies that did that and failed? Also, Keeping to the Core worked really well for Coca Cola, but really badly for Kodak.\nThese are just examples. These books are packed full of such reasonably sounding absurdities. I thought that everybody would immediately spot this. I thought that the mediocre subsequent performance of the companies originally selected as excellent would obviously demonstrate the unsoundness of such conclusion. I was very wrong. These tomes are hugely successful. People seemed to disagree with me. They really like this stuff. Given that my work and my life were not overly impacted one way or the other, I left the matter to rest.\nAnd then came The Halo Effect. It was a pleasure for me to read, as it confirmed my own ideas (confirmation bias anyone?) and added many more.\nThe title is slightly misleading. A better title would have been: Why the idea of finding common traits among successful companies is baloney. I know, not as catchy. The catchy halo effect, mentioned in the title, is just the biggest delusion that people have about the topic.\nI found an experiment recounted in the book to be very illuminating. They divided a set of people in multiple groups and gave each group a problem to solve. They then told half of the groups that they did a very good job and the other half that they did a very poor job. The thing is, they did so at random. They then asked people to rate the dynamics of their group on several factors. People that were told that they did a good job reported to have had wonderful dynamics: open discussions, inspired leaders, high caliber people and such. The opposite was true for the other groups.\nIt didn\u0026rsquo;t matter what the actual dynamics had really been: some groups were very confrontational, others were very amicable; some were very vocal, others were very quiet. In the end, people who were told that they did good recalled the experience in positive terms. People who were told that they did poorly, recalled the experience in negative terms. Remember, good and bad outcomes were assigned randomly. Also, the results have been confirmed in several similar studies.\nIt is not a good strategy that drives performance. It is perceived performance that makes people think that they had a good strategy. This is: The halo effect. This simple concept has dramatic repercussions.\nFirst of all, it invalidates the main process used in these studies: if you use newspapers articles and managers recollection to draw conclusions, you are just piling halos over halos. People would certainly give all sort of positive attributes to companies that succeeded. They do it exactly because they succeeded. And when these companies fail, they suddenly give all sort of negative attributes to them. The book is full of examples of companies that were rated as excellent when their stock price went up and terrible when their stock price went down. Nothing changed in these companies, they were still doing the same exact thing.\nThe book contains many other insights of why these ‘studies\u0026rsquo; are deeply flawed. It calls them delusions. You are probably familiar with some of them if you have a scientific background: for example, Delusion of Correlation and Causality, Delusion of Single Explanation (factors are not independent), Delusion of Connecting the Winning Dots (ad hoc after the fact selection). Other delusions are specific to the analyzed domain: Delusion of Lasting Success, Delusion of Absolute Performance, Delusion of Organizational Physics.\nIn the end what should managers do? Instead of following these books\u0026rsquo;s precepts, they should focus on two things: strategy and execution. Both of these things are probabilistic endeavors where the absolutely wrong measuring stick is the result that you obtain. I always found this to be a very common error people fall into at whatever level in an organization. The error is judging the soundness of a decision by its result. A decision should be judged by the soundness of the process to get to the decision and the information available at the time the decision was taken. This is the only thing that is consistent with the probabilistic nature of the world we live in. The book profiles three leaders who embody this probabilistic view.\nIn summary, please go and read this book. There are many more things in it than I described in this (albeit long and boring) post.\n","permalink":"https://peaceiris.com/MyBlog/posts/2008-01-07-book-review-the-halo-effect/","tags":["Books","Financial"],"title":"Book review: The Halo Effect"},{"categories":["Uncategorized"],"contents":"Other posts:\n  Part I - Using a class\n Part II - Making the class better Part III - Using a struct In the last post we looked at structs as ways to implement immutable value objects and we discovered that they have several issues.  A good thing about the struct implementation was the introduction of an explicit ‘special value\u0026rsquo; instead of ‘null\u0026rsquo;. I personally like doing that because it forces me to think about what are the special values in my domain instead of blindly rely on null and its semantics. Plus, it also works where null breaks down, when there are multiple special values.\nHaving explicit special values is obviously not related to structs in any way. You can use the same pattern with classes as well, but you have to manage ‘null\u0026rsquo; values that can enter your API. Here is how I did it for the DateSpan class.\nFirst I defined an utility function to manage null values:\npublic static void CheckNull\u0026lt;T\u0026gt;(T t) { if (t == null) throw new ArgumentNullException(); } Then I had to check my null precondition for each parameter of my API. I.E.\npublic DateSpan Intersect(DateSpan other) { Utils.CheckNull(other); ... } Most importantly I now have to check for null in ‘Equals\u0026rsquo; and ‘==\u0026rsquo;:\npublic override bool Equals(object obj) { // Interesting choice, null is not valid in this domain    Utils.CheckNull(obj); if (this.GetType() != obj.GetType()) return false; DateSpan other = obj as DateSpan; return other.End == End \u0026amp;\u0026amp; other.Start == Start; }\n\u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;public\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;static\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Boolean\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;operator\u0026lt;/span\u0026gt; ==(\u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;DateSpan\u0026lt;/span\u0026gt; v1, \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;DateSpan\u0026lt;/span\u0026gt; v2) { \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Utils\u0026lt;/span\u0026gt;.CheckNull(v1); \u0026lt;span style=\u0026quot;color:rgb(43,145,175);\u0026quot;\u0026gt;Utils\u0026lt;/span\u0026gt;.CheckNull(v2); \u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; (v1.Equals(v2)); }\u0026lt;/pre\u0026gt; So now we have an immutable value object, represented as a class, with checks for nulls and a special value (not shown above because it is essentially the same as for structs). So, does this work? It does, but it is cumbersome to write. And if it is too cumbersome, I already know that I'm not going to use it. I might start doing it, but I would soon give up. Are there ways to ease the pain? One way would be to use snippets to help in writing the code. Snippets in this case have a couple of problems: * It is not easy to \u0026amp;#8216;snippify' the logic inside \u0026amp;#8216;Equals', \u0026amp;#8216;GetHashcode' and such * It makes easy to write the code, but still it is hard to read it and maintain it In the next post we'll look at a better solution. ","permalink":"https://peaceiris.com/MyBlog/posts/2007-12-28-creating-an-immutable-value-object-in-c-part-iv-a-class-with-a-special-value/","tags":["csharp"],"title":"Creating an immutable value object in C# - Part IV - A class with a special value"},{"categories":["Uncategorized"],"contents":"Other posts:\n  Part I - Using a class\n Part II - Making the class better Part IV - A class with a special value{.} In Part II I talked about the asymmetry created by using ‘null\u0026rsquo; as the special value for our little DateSpan domain. We also noticed the boredom of having to implement Equals, GetHashCode, ‘==\u0026rsquo; and ‘!=\u0026rsquo; for our value objects. Let\u0026rsquo;s see if structs solve our problem.  Well, to the untrained eye they do. Structs cannot be null and they implement Equals and GetHashCode by checking the state of the object, not its pointer in memory.\nSo, have we found the perfect tool to implement our value object?\nUnfortunately, no. Here is why a struct is a less than optimal way to implement a value object:\n Convenience issues - it is not as convenient as it looks  You still have to implement ‘==\u0026rsquo; and ‘!=\u0026rsquo;.  You still want to implement Equals() and GetHashCode(), if you want to avoid boxing/unboxing. Performance issues - it is not as fast as it looks  Structs are allocated on the stack. Every time you pass them as arguments, the state is copied. If your struct has more than a few fields, performance might suffer    Usability issues - it is not as useful as it looks.\n Structs always have a public default constructor that ‘zeros\u0026rsquo; all the fields  Structs cannot be abstract  Structs cannot extend another structs  Don\u0026rsquo;t get me wrong, structs are extremely useful as a way to represent small bundles of data. But if you use value objects extensively, their limitations start to show.      A case could be made that you should use struct to implement value objects if the issues exposed above don't apply to your case. When they do apply, you should use classes. I'm a forgetful and lazy programmer, I don't want to remember all these cases. I just want a pattern that I can use whenever I need a value object. It seems to me that structs don't fit the bill. For the sake of completeness, here is the code for DateSpan using a struct. Note that I explicitly introduced a \u0026amp;#8216;special value' instead of using null (which is not available for structs). \u0026lt;pre class=\u0026quot;code\u0026quot;\u0026gt;\u0026lt;span style=\u0026quot;color:rgb(0,0,255);\u0026quot;\u0026gt;using\u0026lt;/span\u0026gt; System;            using System.Collections.Generic; using System.Linq; using System.Text; public struct DateSpan { public static DateSpan NoValueDateSpan { get { return noValueDateSpan; } } public DateSpan(DateTime pstart, DateTime pend) { if (pend \u0026lt; pstart) throw new ArgumentException(pstart.ToString() + \u0026rdquo; doesn\u0026rsquo;t come before \u0026ldquo; + pend.ToString()); start = pstart; end = pend; hasValue = true; } public DateSpan Union(DateSpan other) { if (!HasValue) return other; if (!other.HasValue) return this; if (IsOutside(other)) return DateSpan.NoValueDateSpan; DateTime newStart = other.Start \u0026lt; Start ? other.Start : Start; DateTime newEnd = other.End \u0026gt; End ? other.End : End; return new DateSpan(newStart, newEnd); } public DateSpan Intersect(DateSpan other) { if (!HasValue) return DateSpan.NoValueDateSpan; if (!other.HasValue) return DateSpan.NoValueDateSpan; if (IsOutside(other)) return DateSpan.NoValueDateSpan; DateTime newStart = other.Start \u0026gt; Start ? other.Start : Start; DateTime newEnd = other.End \u0026lt; End ? other.End : End; return new DateSpan(newStart, newEnd); } public DateTime Start { get { return start; } } public DateTime End { get { return end; } } public bool HasValue { get { return hasValue; } } // Making field explicitely readonly (but cannot use autoproperties)  // BTW: If you want to use autoproperties, given that it is a struct,  // you need to add :this() to the constructor  private readonly DateTime start; private readonly DateTime end; private readonly bool hasValue; private bool IsOutside(DateSpan other) { return other.start \u0026gt; end || other.end \u0026lt; start; } // Changing the internal machinery so that hasValue default is false  // This way the automatically generated empty constructor returns the right thing  private static DateSpan noValueDateSpan = new DateSpan(); #region Boilerplate Equals, ToString Implementation public override string ToString() { return string.Format(\u0026quot;Start:{0} End:{1}\u0026ldquo;, start, end); } public static Boolean operator ==(DateSpan v1, DateSpan v2) { return (v1.Equals(v2)); } public static Boolean operator !=(DateSpan v1, DateSpan v2) { return !(v1 == v2); } //public override bool Equals(object obj) {  // if (this.GetType() != obj.GetType()) return false;  // DateSpan other = (DateSpan) obj;  // return other.end == end \u0026amp;\u0026amp; other.start == start;  //}  //public override int GetHashCode() {  // return start.GetHashCode() | end.GetHashCode();  //} #endregion } \n [TimeLineAsStruct.zip](https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Components.PostAttachments/00/06/85/58/26/TimeLineAsStruct.zip) ","permalink":"https://peaceiris.com/MyBlog/posts/2007-12-24-creating-an-immutable-value-object-in-c-part-iii-using-a-struct/","tags":["csharp"],"title":"Creating an immutable value object in C#  - Part III  - Using a struct"},{"categories":["Uncategorized"],"contents":"Here is a quick implementation of XIRR (using Excel nomenclature) written in C#.\nDisclaimer: this is a super simple Bisection-based implementation. People tend to prefer the Newton method, but this is simpler and works for the app I\u0026rsquo;m writing. I decided to post it because I couldn\u0026rsquo;t find one on the net when I looked for it. I attached testcases to show the extent of my testing.\nIt is called CalculateXIRR and it is invoked by passing a list of cash flows, a tolerance and a max number of iterations.\nusing System; using System.Linq; using Money = System.Decimal; using Rate = System.Double; using System.Collections.Generic; public struct Pair\u0026lt;T, Z\u0026gt; { public Pair(T first, Z second) { First = first; Second = second; } public readonly T First; public readonly Z Second; } public class CashFlow { public CashFlow(Money amount, DateTime date) { Amount = amount; Date = date; } public readonly Money Amount; public readonly DateTime Date; } public struct AlgorithmResult\u0026lt;TKindOfResult, TValue\u0026gt; { public AlgorithmResult(TKindOfResult kind, TValue value) { Kind = kind; Value = value; } public readonly TKindOfResult Kind; public readonly TValue Value; } public enum ApproximateResultKind { ApproximateSolution, ExactSolution, NoSolutionWithinTolerance } public static class Algorithms { internal static Money CalculateXNPV(IEnumerable\u0026lt;CashFlow\u0026gt; cfs, Rate r) { if (r \u0026lt;= -1) r= -0.99999999; // Very funky ... Better check what an IRR \u0026lt;= -100% means  return (from cf in cfs let startDate = cfs.OrderBy(cf1 =\u0026gt; cf1.Date).First().Date select cf.Amount / (decimal) Math.Pow(1 + r, (cf.Date - startDate).Days / 365.0)).Sum(); } internal static Pair\u0026lt;Rate, Rate\u0026gt; FindBrackets(Func\u0026lt;IEnumerable\u0026lt;CashFlow\u0026gt;, Rate, Money\u0026gt; func, IEnumerable\u0026lt;CashFlow\u0026gt; cfs) { // Abracadabra magic numbers ... const int maxIter = 100; const Rate bracketStep = 0.5; const Rate guess = 0.1; Rate leftBracket = guess - bracketStep; Rate rightBracket = guess + bracketStep; var iter = 0; while (func(cfs, leftBracket) * func(cfs, rightBracket) \u0026gt; 0 \u0026amp;\u0026amp; iter++ \u0026lt; maxIter) { leftBracket -= bracketStep; rightBracket += bracketStep; } if (iter \u0026gt;= maxIter) return new Pair\u0026lt;double, double\u0026gt;(0, 0); return new Pair\u0026lt;Rate, Rate\u0026gt;(leftBracket, rightBracket); } // From \u0026#34;Applied Numerical Analyis\u0026#34; by Gerald internal static AlgorithmResult\u0026lt;ApproximateResultKind, Rate\u0026gt; Bisection(Func\u0026lt;Rate, Money\u0026gt; func, Pair\u0026lt;Rate, Rate\u0026gt; brackets, Rate tol, int maxIters) { int iter = 1; Money f3 = 0; Rate x3 = 0; Rate x1 = brackets.First; Rate x2 = brackets.Second; do { var f1 = func(x1); var f2 = func(x2); if (f1 == 0 \u0026amp;\u0026amp; f2 == 0) return new AlgorithmResult\u0026lt;ApproximateResultKind, Rate\u0026gt;(ApproximateResultKind.NoSolutionWithinTolerance, x1); if (f1 * f2 \u0026gt; 0) throw new ArgumentException(\u0026#34;x1 x2 values don\u0026#39;t bracket a root\u0026#34;); x3 = (x1 + x2) / 2; f3 = func(x3); if (f3 * f1 \u0026lt; 0) x2 = x3; else x1 = x3; iter++; } while (Math.Abs(x1 - x2)/2 \u0026gt; tol \u0026amp;\u0026amp; f3 != 0 \u0026amp;\u0026amp; iter \u0026lt; maxIters); if (f3 == 0) return new AlgorithmResult\u0026lt;ApproximateResultKind, Rate\u0026gt;(ApproximateResultKind.ExactSolution, x3); if (Math.Abs(x1 - x2) / 2 \u0026lt; tol) return new AlgorithmResult\u0026lt;ApproximateResultKind, Rate\u0026gt;(ApproximateResultKind.ApproximateSolution, x3); if (iter \u0026gt; maxIters) return new AlgorithmResult\u0026lt;ApproximateResultKind, Rate\u0026gt;(ApproximateResultKind.NoSolutionWithinTolerance, x3); throw new Exception(\u0026#34;It should never get here\u0026#34;); } public static AlgorithmResult\u0026lt;ApproximateResultKind, Rate\u0026gt; CalculateXIRR(IEnumerable\u0026lt;CashFlow\u0026gt; cfs, Rate tolerance, int maxIters) { var brackets = FindBrackets(CalculateXNPV, cfs); if (brackets.First == brackets.Second) return new AlgorithmResult\u0026lt;ApproximateResultKind, double\u0026gt;(ApproximateResultKind.NoSolutionWithinTolerance, brackets.First); return Bisection(r =\u0026gt; CalculateXNPV(cfs,r), brackets, tolerance, maxIters); } } // TESTS using Microsoft.VisualStudio.TestTools.UnitTesting; using System.Collections.Generic; using System; using Rate = System.Double; namespace TimeLineTest { [TestClass()] public class AlgorithmsTest { IEnumerable\u0026lt;CashFlow\u0026gt; cfs = new CashFlow[] { new CashFlow(-10000, new DateTime(2008,1,1)), new CashFlow(2750, new DateTime(2008,3,1)), new CashFlow(4250, new DateTime(2008,10,30)), new CashFlow(3250, new DateTime(2009,2,15)), new CashFlow(2750, new DateTime(2009,4,1)) }; IEnumerable\u0026lt;CashFlow\u0026gt; bigcfs = new CashFlow[] { new CashFlow(-10, new DateTime(2000,1,1)), new CashFlow(10, new DateTime(2002,1,2)), new CashFlow(20, new DateTime(2003,1,3)) }; IEnumerable\u0026lt;CashFlow\u0026gt; negcfs = new CashFlow[] { new CashFlow(-10, new DateTime(2000,1,1)), new CashFlow(-1, new DateTime(2002,1,2)), new CashFlow(1, new DateTime(2003,1,3)) }; IEnumerable\u0026lt;CashFlow\u0026gt; samedaysamecfs = new CashFlow[] { new CashFlow(-10, new DateTime(2000,1,1)), new CashFlow(10, new DateTime(2000,1,1)), }; IEnumerable\u0026lt;CashFlow\u0026gt; samedaydifferentcfs = new CashFlow[] { new CashFlow(-10, new DateTime(2000,1,1)), new CashFlow(100, new DateTime(2000,1,1)), }; IEnumerable\u0026lt;CashFlow\u0026gt; bigratecfs = new CashFlow[] { new CashFlow(-10, new DateTime(2000,1,1)), new CashFlow(20, new DateTime(2000,5,30)), }; IEnumerable\u0026lt;CashFlow\u0026gt; zeroRate = new CashFlow[] { new CashFlow(-10, new DateTime(2000,1,1)), new CashFlow(10, new DateTime(2003,1,1)), }; IEnumerable\u0026lt;CashFlow\u0026gt; doubleNegative = new CashFlow[] { new CashFlow(-10000, new DateTime(2008,1,1)), new CashFlow(2750, new DateTime(2008,3,1)), new CashFlow(-4250, new DateTime(2008,10,30)), new CashFlow(3250, new DateTime(2009,2,15)), new CashFlow(2750, new DateTime(2009,4,1)) }; IEnumerable\u0026lt;CashFlow\u0026gt; badDoubleNegative = new CashFlow[] { new CashFlow(-10000, new DateTime(2008,1,1)), new CashFlow(2750, new DateTime(2008,3,1)), new CashFlow(-4250, new DateTime(2008,10,30)), new CashFlow(3250, new DateTime(2009,2,15)), new CashFlow(-2750, new DateTime(2009,4,1)) }; double r = 0.09; double tolerance = 0.0001; int maxIters = 100; private TestContext testContextInstance; public TestContext TestContext { get { return testContextInstance; } set { testContextInstance = value; } } [TestMethod()] public void CalculateXNPV() { Assert.AreEqual(2086.6476020315416570634272814M, Algorithms.CalculateXNPV(cfs, r)); Assert.AreEqual(-10.148147600710372651326920258M, Algorithms.CalculateXNPV(negcfs, 0.5)); Assert.AreEqual(4.9923725815954514810351876895M, Algorithms.CalculateXNPV(bigcfs, 0.3)); } [TestMethod] public void FindBrackets() { var brackets = Algorithms.FindBrackets(Algorithms.CalculateXNPV, cfs); Assert.IsTrue(brackets.First \u0026lt; 0.3733 \u0026amp;\u0026amp; brackets.Second \u0026gt; 0.3733); brackets = Algorithms.FindBrackets(Algorithms.CalculateXNPV, bigcfs); Assert.IsTrue(brackets.First \u0026lt; 0.5196 \u0026amp;\u0026amp; brackets.Second \u0026gt; 0.5196); brackets = Algorithms.FindBrackets(Algorithms.CalculateXNPV, negcfs); Assert.IsTrue(brackets.First \u0026lt; -0.6059 \u0026amp;\u0026amp; brackets.Second \u0026gt; -0.6059); } [TestMethod] public void XIRRTest() { var irr = Algorithms.CalculateXIRR(cfs, tolerance, maxIters); Assert.AreEqual(0.3733, irr.Value, 0.001); Assert.AreEqual(ApproximateResultKind.ApproximateSolution, irr.Kind); irr = Algorithms.CalculateXIRR(bigcfs, tolerance, maxIters); Assert.AreEqual(0.5196, irr.Value, 0.001); Assert.AreEqual(ApproximateResultKind.ApproximateSolution, irr.Kind); irr = Algorithms.CalculateXIRR(negcfs, tolerance, maxIters); Assert.AreEqual(-0.6059, irr.Value, 0.001); Assert.AreEqual(ApproximateResultKind.ApproximateSolution, irr.Kind); irr = Algorithms.CalculateXIRR(samedaysamecfs, tolerance, maxIters); Assert.AreEqual(ApproximateResultKind.NoSolutionWithinTolerance, irr.Kind); irr = Algorithms.CalculateXIRR(samedaydifferentcfs, tolerance, maxIters); Assert.AreEqual(ApproximateResultKind.NoSolutionWithinTolerance, irr.Kind); irr = Algorithms.CalculateXIRR(bigratecfs, tolerance, maxIters); Assert.AreEqual(4.40140, irr.Value, 0.001); Assert.AreEqual(ApproximateResultKind.ApproximateSolution, irr.Kind); irr = Algorithms.CalculateXIRR(zeroRate, tolerance, maxIters); Assert.AreEqual(0, irr.Value, 0.001); Assert.AreEqual(ApproximateResultKind.ApproximateSolution, irr.Kind); irr = Algorithms.CalculateXIRR(doubleNegative, tolerance, maxIters); Assert.AreEqual(-0.537055, irr.Value, 0.001); Assert.AreEqual(ApproximateResultKind.ApproximateSolution, irr.Kind); irr = Algorithms.CalculateXIRR(badDoubleNegative, tolerance, maxIters); Assert.AreEqual(ApproximateResultKind.NoSolutionWithinTolerance, irr.Kind); } } } ","permalink":"https://peaceiris.com/MyBlog/posts/2007-12-17-bisection-based-xirr-implementation-in-c/","tags":["csharp","Financial"],"title":"Bisection-based XIRR implementation in C#"},{"categories":["Uncategorized"],"contents":"Other posts:\n Part I - Using a class Part III - Using a struct{.} Part IV - A class with a special value{.}  In the previous post I showed how to trivially implement a value object. The code works but it has several issues. Some are very simple, others are more interesting.\nLet\u0026rsquo;s take a look at them:\n State not explicitly read-only Asymmetry in the usage of Union and Intersection Small perf issue in the Union method  The first problem is that my use of automatic properties doesn\u0026rsquo;t assure that the status of the object is immutable; I can still modify it from inside the class. The simple solution is to make the fields readonly and write the getters as in:\nprivate readonly DateTime start; private readonly DateTime end; public DateTime Start { get { return start; } } public DateTime End { get { return end; } }  The second issue is more subtle. Consider this code\nDateSpan d1 = new DateSpan(new DateTime(1, 1, 2000), new DateTime(1, 1, 2002)); DateSpan d2 = null; DateSpan r1 = d1.Intersect(d2); DateSpan r2 = d2.Intersect(d1);  I would like things in my little ‘algebra\u0026rsquo; to be symmetric. In this case I\u0026rsquo;d like: r1 == r2 == null. But this code throws in the last line as I\u0026rsquo;m trying to invoke a method on a null object.\nThe traditional solution to this problem is to make Union and Intersect to be static methods, but then you loose the magic of calling them as instance methods (i.e. it becomes hard to chain them together as in d1.Intersect(d2).Union(d3).Intersect(d4)).\nExtension methods come to the rescue here as they allow you to create static methods, but to call them as if the were instance methods. The new code for Intersect looks like the following:\npublic static DateSpan Intersect(this DateSpan one, DateSpan other) { if (one == null) return null; if (other == null) return null; if (one.IsOutside(other)) return null; DateTime start = other.Start \u0026gt; one.Start ? other.Start : one.Start; DateTime end = other.End \u0026lt; one.End ? other.End : one.End; return new DateSpan(start, end); } This workaround would not work if the extension method needs to access private state of the class. In that case you would need to create a static method on the DataSpan class and invoke it from the extension method. Slightly more convoluted, but still doable.\nAt a more philosophical level, the asymmetry issue happens here because I\u0026rsquo;m using something outside my domain of interest (the null value) to represent a special value inside my domain of interest. More on this as we talk about structs in upcoming posts.\nThe last point is a very small one. In the Union method I am creating a new object unnecessarily in the following line:\nif (other == null) return new DateSpan(Start, End);  I can obviously avoid it by just returning this.\nThis post hints to several possible issues. Is it a good idea to use null to represent special values in my domain? What if I have more than one of them (i.e. positive/negative infinite)? Would using structs solve these problems?\nWe\u0026rsquo;ll take a look at these options in upcoming posts. Attached is the modified code.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-12-06-creating-an-immutable-value-object-in-c-part-ii-making-the-class-better/","tags":["csharp"],"title":"Creating an immutable value object in C#  - Part II  - Making the class better"},{"categories":["Uncategorized"],"contents":"Other posts:\n Part II - Making the class better{.} Part III - Using a struct{.} Part IV - A class with a special value{.}  Value objects are objects for which the identity is based on their state instead of their pointer in memory. For example, a numeric Complex class is, most of the time, a value object because you can treat two instances as the same if their state (real and img fields in this case) is the same. An immutable value object is a value object that cannot be changed. You cannot modify its state, you have to create new ones.\nI\u0026rsquo;m using these guys more and more in my code for a number of reasons, both practical and philosophical. The practical ones revolve around the greater robustness of programming without side effects and the greater simplicity of parallelizing your code. The philosophical ones are more interesting (and subjective). When in my design process I spend the time to aggressively looking for these kinds of objects, the resulting design ends up cleaner. I especially like when I can define some sort of close algebra for these guys (i.e. a set of functions that operate over them and produces new ones, not unlike ‘+\u0026rsquo; and ‘-‘ for numbers).\nThis series describes how to create immutable value objects in C# and the design decisions involved. This is a summary of an email thread I had with Mads and Luke.\nThe concept I will use for this series is a DateSpan. As I define it, a DateSpan has a Start and an End date. You can ask for the DataSpan that represents the Union and Intersection of two DateSpans. The tests in the attached code better define the behavior of these operations.\nGiven that I never use structs in my code (I\u0026rsquo;m a minimalist language user), I\u0026rsquo;ll start by using a class to represent it. We\u0026rsquo;ll make this class better in part II and use a struct in part III. A first stab at it is as follows:\nusing System; using System.Collections.Generic; using System.Linq; using System.Text; public class DateSpan { public DateSpan(DateTime start, DateTime end) { if (end \u0026lt; start) throw new ArgumentException(start.ToString() + \" doesn't come before \" + end.ToString()); Start = start; End = end; } public DateSpan Union(DateSpan other) { if (other == null) return new DateSpan(Start, End); if (IsOutside(other)) return null; DateTime start = other.Start \u0026lt; Start ? other.Start : Start; DateTime end = other.End \u0026gt; End ? other.End : End; return new DateSpan(start, end); } public DateSpan Intersect(DateSpan other) { if (other == null) return null; if (IsOutside(other)) return null; DateTime start = other.Start \u0026gt; Start ? other.Start : Start; DateTime end = other.End \u0026lt; End ? other.End : End; return new DateSpan(start, end); } private bool IsOutside(DateSpan other) { return other.Start \u0026gt; End || other.End \u0026lt; Start; } public DateTime Start { get; private set; } public DateTime End { get; private set; } #region Boilerplate Equals, ToString Implementation public override string ToString() { return string.Format(\"Start:{0} End:{1}\", Start, End); } public override bool Equals(object obj) { if (obj == null) return false; if (this.GetType() != obj.GetType()) return false; DateSpan other = obj as DateSpan; return other.End == End \u0026\u0026 other.Start == Start; } public override int GetHashCode() { return Start.GetHashCode() | End.GetHashCode(); } public static Boolean operator ==(DateSpan v1, DateSpan v2) { if ((object)v1 == null) if ((object)v2 == null) return true; else  return false; return (v1.Equals(v2)); } public static Boolean operator !=(DateSpan v1, DateSpan v2) { return !(v1 == v2); } #endregion } public static class TimeLineExtensions { public static bool IsSuperSet(this DateSpan span, DateSpan other) { if (span.Intersect(other) == other) return true; return false; } }  Some things to notice in this code:\n Defining a value object with a C# class involves overriding Equals, Hashcode, == and !=. It is tricky, but usually boilerplate stuff, well described in Wagner (2004). I don\u0026rsquo;t have Bill\u0026rsquo;s book in my office, so I kind of made it up on the fly. It could be very wrong (the ‘==\u0026rsquo; one looks very suspicious). Don\u0026rsquo;t copy it, read Bill\u0026rsquo;s book instead   Defining an immutable object with a C# class involves discipline in not changing the private state (we\u0026rsquo;ll see in Part II that we can do better than ‘discipline\u0026rsquo;)\n Notice the extension method IsSuperSet. This is something I picked up from an old Coplien book, probably this one. The concept is to keep methods that don\u0026rsquo;t use internal state of an object external to the object itself for the sake of future maintainability. The syntax for doing that was awkward before, but extension methods make it easier This works (it passes all the tests), but it has a number of problems. We\u0026rsquo;ll talk about these in Part II.  TimeLineAsClass - 1.zip\n    ","permalink":"https://peaceiris.com/MyBlog/posts/2007-12-03-creating-an-immutable-value-object-in-c-part-i-using-a-class/","tags":["csharp"],"title":"Creating an immutable value object in C#  - Part I  - Using a class"},{"categories":["Uncategorized"],"contents":"We get plenty of emails in Microsoft. Without a system to manage them you are dead. Or better, your mind plays strange tricks on you making you think that you still have work to do. You need to convince your mind that you are done for the day and to stop bugging you, please.\nAlmost everyone has a system. Some are better than others. My current system is Getting things done and it does achieve its goal of freeing my mind (mostly) without imposing too much overhead. But I\u0026rsquo;m always looking for something better. That\u0026rsquo;s why I checked out Total Workday Control.\nThe title conjures in my mind all sort of scary images of control freaks going through their days trying to achieve optimization of every single action. In reality the book is just a light update of David Allen methodology. The most interesting thing I picked out is the differentiation between a Master Task List and a Daily List. The former contains projects or delayed tasks while the latter contains tasks (typically taken from the Master List) that you want to perform today. It also has a system of prioritizing such tasks and give good rules of thumbs on how many you should have on each list and so on.\nMy rule of thumb is that if I learn one useful thing by reading a book, then it is a fantastic book. This book qualifies. If you are currently using Getting things done, this book constitutes a nice upgrade. If you aren\u0026rsquo;t, I suggest you read David Allen first, as it gives you the reasons for the system, before you move to the more technical Total Workday Control.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-11-20-brief-review-of-quottotal-workday-controlquot/","tags":["Books","Miscellanea"],"title":"Brief review of Total Workday Control"},{"categories":["Uncategorized"],"contents":"This is Luke‘s kind of code. I might be catching the virus\nabstract class QIFParserBase { public enum LoadOptions { All, Prices, Securities, Transactions } static readonly Dictionary\u0026lt;LoadOptions, Action\u0026lt;QIFParserBase, string[]\u0026gt;\u0026gt; parseFuncs = new Dictionary\u0026lt;LoadOptions, Action\u0026lt;QIFParserBase, string[]\u0026gt;\u0026gt; { {LoadOptions.All, (q,c) =\u0026gt; q.ParseAll(c)}, {LoadOptions.Prices, (q,c) =\u0026gt; q.ParsePricesBlocks(c)}, {LoadOptions.Securities, (q,c) =\u0026gt; q.ParseSecurityBlocks(c)}, {LoadOptions.Transactions, (q,c) =\u0026gt; q.ParseTransactionBlocks(c)} }; public QIFParserBase(string fileName, LoadOptions opt) { string content = File.ReadAllText(fileName); string[] blocks = content.Split(new string[] { \"!Type:\", \"!Option:\" }, StringSplitOptions.RemoveEmptyEntries); parseFuncs[opt](this,blocks); } ","permalink":"https://peaceiris.com/MyBlog/posts/2007-08-31-instead-of-a-simple-switch-statement/","tags":["csharp"],"title":"Instead of a simple switch statement"},{"categories":["Uncategorized"],"contents":"I\u0026rsquo;m slightly prouder of the structure of this code than the one in the previous blog post. You can simply inherit from QIFParserBase and override a couple of abstract methods to customize the behavior. Still, I just tested it on a couple of test QIF files. It is not production quality at all.\nNotice that I don\u0026rsquo;t even have Quicken. I\u0026rsquo;m producing these test file with FundManager, which I use for my investments. If your software generates QIF files differently, than you have to modify the code. It shouldn\u0026rsquo;t be too hard.\nIt works with VS 2008 beta 2.\nParseQIF.zip\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-08-31-parsing-qif-quicken-files-in-c/","tags":["csharp","Financial"],"title":"Parsing QIF Quicken files in C#"},{"categories":["Uncategorized"],"contents":"I wrote this code very quickly and I\u0026rsquo;m kind of ashamed of it, but it gets the job done (I think). You need the HTML Agility Pack for the stock splits retrieving code. You can download it from here{.} or you can simply comment out the code. I wrote it against Visual Studio 2008 beta 2{.}, but it should be trivial to port it to previous versions.\nYou run it from a command window like this: priceretriever msft 1/1/1990 2/3/2003. The last two parameters are optional and default to 1/1/1980 and today.\nEnjoy.\nPriceRetriever.zip\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-08-30-retrieve-prices-dividends-and-splits-for-a-stock-in-c/","tags":["csharp","Financial"],"title":"Retrieve prices, dividends and splits for a stock in C#"},{"categories":["Uncategorized"],"contents":"My wife took this in Manhattan Beach this week end. Karch is the one on the right.\nBeachVolley 123.JPG\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-08-13-lucabol-and-kiraly/","tags":["Sport"],"title":"Lucabol and Kiraly"},{"categories":["Uncategorized"],"contents":"And a bit of history of O/R in Microsoft at the end: http://blogs.msdn.com/charlie/archive/2007/08/06/linq-to-sql-pipeline-video-with-luca-bolognese-and-matt-warren.aspx\n ","permalink":"https://peaceiris.com/MyBlog/posts/2007-08-13-here-is-a-seminot-funny-video-of-matt-and-i-talking-about-the-linq-to-sql-queryupdate-pipeline/","tags":["csharp"],"title":"Video of Matt and I talking about the LINQ to SQL query/update pipeline"},{"categories":["Uncategorized"],"contents":" Interesting read on what open source has been good for, on the difference between Linux and Wikipedia and on how to best harness the power of crowds.\nAlso a highly positively reviewed new book that formalizes in almost mathematical fashion what diversity is good for (I haven’t read it yet). The classical work on the matter is “The Wisdom of crowds”.\nExcerpt from the initial article: “Raymond was clear on that point when, toward the end of his paper, he examined some of the “necessary preconditions” for the bazaar model of production. “It’s fairly clear,” he wrote, “that one cannot code from the ground up in bazaar style. One can test, debug and improve in bazaar style, but it would be very hard to originate a project in bazaar mode.” In a recent e-mail to me, he was even blunter. “The individual wizard,” he wrote, “is where successful bazaar projects generally start.” “\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-07-05-interesting-10-years-retrospective-on-the-cathedral-and-the-bazaar/","tags":["Books","Miscellanea"],"title":"Interesting 10 years retrospective on The cathedral and the Bazaar"},{"categories":["Uncategorized"],"contents":"In case you want to know more about LINQ: http://www.virtualteched.com/Pages/OnlineSessions/OnlineWebcastsDevTools.aspx\nCTRL+F for ‘(LINQ)\u0026rsquo;\nAn introduction to the talk is here: http://www.virtualteched.com/videos/luca%20bolognese%20sml.asx\n ","permalink":"https://peaceiris.com/MyBlog/posts/2007-06-19-my-teched-webcast-is-here/","tags":["csharp"],"title":"My TechEd webcast is here"},{"categories":["Uncategorized"],"contents":"Matt has a very good poston the history of object relational framework inside Microsoft. He and I started the whole ObjectSpaces thing together very many years ago (about six and a half). I thought I should add my two cents.  \u0026nbsp; You might be wondering how a project starts inside Microsoft (or you might not). In this case, I was hired in the ADO.NET team to build an object relational framework. That was my assignment. The problem was that I had no dev or tester to work with. I also had just arrived in the US from Italy and my English was terrible (that hasn’t changed much). My only qualifications for the job were that I was incredibly passionate about the topic; I had built a couple of small ones in my spare time and have used many more in various projects. But still I had no idea on how to make things happen in this big company. Hell, I could barely understand what people were talking about at lunch. \u0026nbsp; Anyhow, my boss told me that there was a guy who was relatively free, but I had to come up with an idea, convince him that the idea was a good one and that he should go ahead and prototype it. That guy was Matt Warren, already one of the best developers in the SQL team and the dev lead of plenty of our .NET stack. \u0026nbsp; The first time I entered his office and started talking, he immediately told me: “Not now, I’m debugging”. A good start … But after that, we hit it off immediately. We talked about what an OR framework is, what it should be, how we could innovate in the space and so on. After a while, Matt started working on the very first ObjectSpaces prototype. Our modus operandi was peculiar. I would go to Matt’s office and we would discuss a particular feature or scenario. He would tell me: “Ok, we are on the same page, I’ll see you tomorrow”. The next day the feature would be implemented. If he told me: “It is going to take me 5 days to code it” I knew he didn’t like the feature and I had some more convincing to do. Sometime we would agree, sometime we wouldn’t. Sometime I came up with staff to implement, sometimes Matt did. We figured out a lot of stuff in those days. \u0026nbsp; Also I learned how to work with different categories of programmers. If you work with a bad programmer you have to tell him how to implement something. If you work with a good programmer you have to tell him what you want the feature to look like. If you work with an excellent programmer, you just have to tell him what your final goal is. I quickly realized that the latter was the most productive strategy with Matt. I had just to convince him of the business need for something. Implementing it ended up to be a detail. \u0026nbsp; That initial prototype grew to become ObjectSpaces (it was called Cheops initially). The team grew to be about 25 people, growing and stretching me personally. We went through two painful rounds of unifications with bigger products. In the end ObjectSpaces was cut. Matt moved to the C# team to work on LINQ. Dinesh and I followed after a short while. The whole ObjectSpaces team scattered in various places around the company. The object relational thing started again in the C# team as part of the LINQ project. This time around we also had a compiler to play with. Plus Anders was on board to sprinkle his design magic over the whole thing. \u0026nbsp; As Rolandwould say, the world has moved on. Matt is now a big shot architect and I lead a team of amazingly smart individuals (they are forced to act as if my words make sense, imagine that …). We are shipping a game changing product in LINQ and a wonderful object relational framework in LINQ to SQL. Things turned out for the best (even if five years too late). \u0026nbsp; Still it is a pleasure to think back at those early days (and nights) of ‘figuring out stuff’ six years ago. A lot of that ‘stuff’ is inside our products today, and that is something to be proud of. ","permalink":"https://peaceiris.com/MyBlog/posts/2007-06-07-objectspaces-early-days/","tags":["csharp"],"title":"ObjectSpaces early days"},{"categories":["Uncategorized"],"contents":"at least they told me so. It is at 8.30am Eastern time. I don\u0026rsquo;t know the exact link, but it will be somewhere here: http://www.microsoft.com/events/teched2007/default.mspx.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-06-04-my-linq-overview-session-at-teched-will-be-live-on-the-internet/","tags":["csharp"],"title":"My LINQ Overview session at TechEd will be live on the Internet"},{"categories":["Uncategorized"],"contents":"From Mads, our proud C# language PM: http://blogs.msdn.com/madst/archive/2007/05/11/recursive-lambda-expressions.aspx.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-05-11-y-combinators-anyone/","tags":["csharp"],"title":"Y combinators anyone?"},{"categories":["Uncategorized"],"contents":"Today I\u0026rsquo;m watching the AVP tour, especially (as always) Karch{.}. This year is his last and I\u0026rsquo;m trying to go and see him as much as I can. Karch is an idol for my generation of beach volley players. Well, it is an idol for all generations really\nHe loses one, he wins one. The day is about to end but he still has to play against Lambo. The sun is going down, it is the last match of the day. The crowd gathers around the court. As always it is not easy to put him down. He plays with Wong, another veteran of the AVP tour. The other team serves him short to force him to move forward and then backward again to prepare his attack. It is a smart strategy, Karch\u0026rsquo;s legs and not what they used to be 20 years ago\nBut he goes on, finds new and interesting ways to overcome a block that is way higher than his maximum one hand reach. Sometimes it feels as if the block is his friend and Lambo starts to lower his hands not to give him that tool to play with. But the short serves are wearing him down and the match is going in the wrong direction.\nSuddenly, out of nowhere, he produces an amazing strong hit. Something Rosy could have done. The crowd goes ballistic. Everybody laughs and cheers. Even the other team is laughing. Karch raises his hands smiling as to say: I have no idea where that one came from. But maybe he does, because it happens again the very next side out. It looks like something good might still happen. But then he misses the last shot. He tries to hit the line, but the ball is far from the net and his jump is what it is.\nWe give him a two minutes standing ovation. This is the last time Huntington beach has seen him play. He waives his proverbial pink hat to salute the crowd. He sits down\nand he takes the head in his hands. After three Olympic medals, uncounted championships, thousand of beach volley wins and a two minutes standing ovation he is not happy. He missed the last ball.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-05-05-huntington-beach-and-kiraly/","tags":["Sport"],"title":"Huntington Beach and Kiraly"},{"categories":["Uncategorized"],"contents":"After a long hiatus, Luke goes at it again. Luke is our compiler PM and one of the most original coders I\u0026rsquo;ve seen.\nIt always makes for a great read: http://blogs.msdn.com/lukeh/default.aspx\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-04-27-luke-started-to-blog-again/","tags":["csharp"],"title":"Luke started to blog again"},{"categories":["Uncategorized"],"contents":"\nWhen I came to US, I wanted to get an introduction on personal finance. I needed to know what to insure, when, how to buy an house and all this sort of basic things. At the time I read Personal Finance for Dummies. I then discovered that very many US folks don’t know about these things either and I found myself recommending this simple book to plenty of people. You can find it for a few bucks in used book-stores. It might be too basic for you, but again, it might not.\nInvestment is a subset of personal finance and by far not the most important one (the most important probably being how to save the most – which means paying you first). Nevertheless, understanding how to invest the money that you do save is important. The following represents a very condensed summary of my views on the topic. There are dozens of others very good books that I could have suggested instead.\nThe first thing I would do is to get a decent understanding of the relationship between risk and reward that is so pervasive in financial markets. Good books on the topic are The Four Pillars of Investing or A Random Walk Down Wall Street. A new book that I haven’t read, but suspect quite good (and short) is The Little Book of Common Sense Investing. This books try to convince you that it is not possible to ‘beat the market’ and the best you can do is to decide on an asset allocation that represents your risk/reward profile. If you believe that, then it is worth getting to the next step by understanding the concept of mean variance optimization. Good medium level books on that are All About Asset Allocation and the Intelligent Asset Allocator. There are advanced books on the topic as well, but I won’t mention them here. An advanced service in this area is IndexInvestor.\nWith time, analyzing the amount of evidence, I came to believe that it is indeed possible to beat the market. But it is not easy and 99% of the methods out there are bunk. Moreover it does require a lot of work and a certain passion for the investment field. So, if you don’t have time or passion you are probably better off sticking to the strategies described in the aforementioned books. If you have a small amount of time, but you still want to try and beat the market, an avenue open to you is the selection of mutual funds. Even then, you need to have some strong held view of which kind of investment strategy and character traits are more likely to bring about superior investment results so that you can pick the right manager (or most likely set of managers) for your money. I describe below what are my personal views on the matter. They are all very debatable. A good service that gives sane information about mutual funds, how to select them and assemble them in your portfolio is Morningstar. I certainly suggest you subscribe to it, if you invest in mutual funds.\nA time honored and generally successful stock picking method is value investing. The father of value investing is Benjamin Graham and two books written by him are everlasting classics of investment. They are The Intelligent Investor and Security Analysis. Aficionados disagree on which releases are the best, the links provided represent my opinion. Please start with the former, as the latter is long and complex. They are both quite dated, but plenty of folks believe that not much has been discovered after their publication. I disagree. Another, maybe better, introductory book is The Little Book of Value Investing. There are wonderful mutual funds out there that invest in the spirit of value investing. Among others, I like Third Avenue, Pinnacle and Royce.\nWarren Buffett expanded on Graham by putting more emphasis on the quality of the companies he invests in instead of mostly the price. A good book describing his approach is The Warren Buffett Way. You can obviously go and read Buffett’s letters directly here, but that is better suited as a second step after reading Graham or the aforementioned book. There are plenty of disciples of this method of investing. If you want to have some of them managing your money, my preferred are Longleaf, Fairholme, Weitz and Clipper among others. A good service that suggest stocks based on this style of investing is the stock section of Morningstar. You also can invest in brk.b directly to buy the services of Buffett himself. I personally believe it is quite undervalued at the current juncture.\nIn the past 15 years or so, there has been a lot of interesting work done on purely quantitative investing systems. They have several advantages over judgment based ones (essentially the human brain is not wired correctly to fight a complex adaptive system as the stock market). There are two categories of systems I feel I can recommend in this area: fundamental based and momentum based. This is a very complex mathematical topic at the high end, but it is possible to get a profitable understanding of it by reading WWOWS and The Little Book That Beats The Market. These books describe fundamental based systems, for a purely momentum based one the best bet is FundX. The web site is not too informative, but if you go to the library and ask the librarian they have a little book written by the FundX guys that describe their system in a great level of detail. The best quantitative mutual funds I can think of are from Bridgeway (there are also others). Like all the other funds I suggested, they are managed by wonderful people that takes the shareholders interests very seriously.\nYou can also try to tactically switch between different asset classes (i.e. stocks and cash) based\non some indicators. I have mixed feelings about this. It might work, but it is debatable how much do you really gain by doing it, after considering taxes and commissions. It is something I could investigate more. Two good books on the matter are The Only Three Questions That Count and The Research Driven Investor. Good mutual funds that do this (with very different risk profiles) are Hussman and CGM.\nA couple of notes to close. Reading these books is an exercise in critical thinking. There are huge amount of contradictory statements on very basic and important concepts. The only way around it is to do your own research and make up your own mind. Even then, you won’t be in a situation of perfect information/clear decision. This cannot be so because the market changes constantly. As soon as something is discovered it gets priced in. This is why it is such an exciting field of study (for some people at least). Also I have my own key rule about investing: I never invest in anything that I don’t understand completely. Every time I’ve done that, I\u0026rsquo;ve regretted it. If this is the only thing that you remember after reading this, I’ll be very happy.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-04-20-a-financial-education-my-ideas/","tags":["Books","Financial"],"title":"A financial education (my ideas)"},{"categories":["Uncategorized"],"contents":"Yesterday I found an old email in my mail box that I thought might be generally interesting.\nI was asking the technical lead on the C# compiler which algorithm/shortcut people should use to choose their ‘number types\u0026rsquo; among the many available in the language. I was asking for something that works the majority of times, even if not always. I\u0026rsquo;m sure there are other scenarios we haven\u0026rsquo;t consider. Anyhow, here is his algorithm.\nIf you need fractions:\n Use decimal when intermediate results need to be rounded to fixed precision - this is almost always limited to calculations involving money. Otherwise use double - you will get the rounding of your calculations wrong, but the extra precision of double will ensure that your results will be good enough. Only use float if you know you have a space issue, and you know the precision implications. If you don\u0026rsquo;t have a PhD in numeric computation you don\u0026rsquo;t qualify.  Otherwise:\n Use int whenever your values can fit in an int, even for values which can never be negative. This is so that subtraction operations don\u0026rsquo;t get you confused. Use long when your values can\u0026rsquo;t fit in an int.  Byte, sbyte, short, ushort, uint, and ulong should only ever be used for interop with C code. Otherwise they\u0026rsquo;re not worth the hassle.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-02-27-which-type-should-i-use-in-c-to-represent-numbers/","tags":["csharp"],"title":"Which type should I use in C# to represent numbers?"},{"categories":["Uncategorized"],"contents":"If you are looking for a good fund for this corner of your portfolio, you might want to consider Eaton Vance Structured Emerging Mkt (EAEMX). There is also a much cheaper version (EITEX), but it is open just to folks with a financial advisor.\nIt is a mechanical fund. Here is how their strategy works (as far as I understand it):\n They divide EM market countries in 4 categories, they assign a weight to each category (I.E. 20% to tier1, 30% to tier2 etc) For each category they equal weight each country in the category (I.E. in tier1 equal weight Russia, Mexico, etc) For each country they equal weight each sector They actively harvest tax losses  The end result is as follows:\n  Smaller country have more weight than in a normal Em.Mkt. fund. This is good because:\n  Smaller markets have had higher returns in the past\n  Smaller markets are less correlated than large markets both among themselves and against the SP500\n  Equal weighting the sectors has the following positive effects:\n  You get more exposure to sectors, like Services, that are going to benefit from economic growth\n  You avoid the ‘commodity effect\u0026rsquo;: the tendency of Em.Markets to fall when commodities prices fall because such a large slice of their economy is based on it\n  It is extremely tax efficient because:\n  The mechanical strategy lends itself to low turnover\n  They actively harvest tax losses\n  In essence they maximize the positive effects of diversification and tax efficiency, which are very stable effects. They are mathematically provable 🙂 The real time results confirm the theory as this has been one of the best performing Em. Markets funds with the lowest standard deviation and best tax efficiency. No-one knows what the future holds, but there is a good chance that this will continue to be the case.\nI don\u0026rsquo;t own it currently because I don\u0026rsquo;t like the high fees, but the strategy makes so much sense that I might end up buying into it.\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-02-02-a-good-emerging-market-fund/","tags":["Financial"],"title":"A good Emerging Market fund"},{"categories":["Uncategorized"],"contents":"Sometimes what looks simple is complex and what looks complex is simple. See if you can understand how this one calculates all the possible ways to give change for a certain amount of money given some kinds of coins. You MIT guys out there don\u0026rsquo;t count, you probably have read the solution in the same book I have.\nBTW: the code works with the LINQ May CTP \u0026hellip;\nusing System; using System.Collections.Generic; using System.Text; using System.Query; using System.Xml.XLinq; class Program { static void Main(string[] args) { var coins = new int[] { 1, 5, 10, 25, 50 }; var i = ChangeComb(100, coins); Console.WriteLine(i); } static int ChangeComb(int amount, IEnumerable\u0026lt;int\u0026gt; coins) { if (amount == 0) return 1; if (amount \u0026lt; 0) return 0; if (coins.Count() == 0) return 0; return ChangeComb(amount, coins.Skip(1)) + ChangeComb(amount - coins.First(), coins); } } ","permalink":"https://peaceiris.com/MyBlog/posts/2007-02-01-apparently-simple-code/","tags":["csharp"],"title":"Apparently simple code"},{"categories":["Uncategorized"],"contents":"This would be a functional approach:\nCountWithPrevious : [‘a] =\u0026gt; (a =\u0026gt; a =\u0026gt; bool) =\u0026gt; int // type of the function CountWithPrevious [] _ = 0 CountWithPrevious [_] _ = 0 CountWithPrevious [prev, val | tail] pred = CountWithPrevious [val | tail] + (pred val prev ? 1 : 0) Some observations:\n_” is used as wildcard argument – matches any value that you don’t need a name for. [ x,y,z | t ] are pattern matching over lists – here x,y and z get bound to the first elements and t is the rest of the list. Both CountWithPrevious and the passed-in pred are curried – they take two arguments but one at a time. The CountWithPrevious function is defined with pattern matching – at runtime it searches through the definitions until one matches. The type declaration is optional – the compiler can figure out the type from the last case of the function. In C# we don’t have pattern matching and currying, and so would probably need a helper function.\npublic static int CountWithPrevious\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; en, PredWithPrevious pred) { IEnumerator\u0026lt;T\u0026gt; rest = en.GetEnumerator(); if (rest.MoveNext()) return Helper(rest.Current,rest,pred); else return 0; } private static int Helper\u0026lt;T\u0026gt;(T prev, IEnumerator\u0026lt;T\u0026gt; rest, PredWithPrevious pred) { if (rest.MoveNext()) { T val = rest.Current; return Helper(val,rest,pred) + (pred(val,prev) ? 1 : 0); } else return 0; } We could simulate local functions with lambdas so that we don’t need to pass pred, prev and T along: public static int CountWithPrevious\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; en, PredWithPrevious pred) { IEnumerator\u0026lt;T\u0026gt; rest = en.GetEnumerator(); Func\u0026lt;T,int\u0026gt; helper = prev =\u0026gt; { if (rest.MoveNext()) { T val = rest.Current; return Helper(val) + (pred(val,prev) ? 1 : 0); } else return 0; }; if (rest.MoveNext()) return Helper(rest.Current); else return 0; } ","permalink":"https://peaceiris.com/MyBlog/posts/2007-01-31-is-this-functional-code-dr-t-reply/","tags":["csharp"],"title":"Is this functional code? Dr.T. Reply."},{"categories":["Uncategorized"],"contents":"I\u0026rsquo;m an Object Oriented (OO) kind of guy, maybe a bigot. I have read a very large number of OO books and I\u0026rsquo;ve written a fair amount of OO code in my 10+ years in this industry. I\u0026rsquo;m afraid my mind is wired for OO at this point, for good or bad.\nRecently, I\u0026rsquo;ve been getting interested in functional languages. The most functional guys around here are Wes and Luke, while Dr. T has somehow transcended the whole thing.\nHere is the text of one of my newbie emails to Dr.T. I\u0026rsquo;ll let you think about it for a bit before posting his reply. The phrase: \u0026ldquo;Is this it?\u0026rdquo; has to be read as \u0026ldquo;Is this what functional programming is all about?\u0026quot;.\n/// EMAIL TEXT BELOW\nIs this it? I have about four of these ‘delegate taking’ functions in my excel addin ….\ndelegate bool PredWithPrevious\u0026lt;T\u0026gt;(T value, T previous); static int CountWithPrevious\u0026lt;T\u0026gt;(IEnumerable\u0026lt;T\u0026gt; en, PredWithPrevious\u0026lt;T\u0026gt; pred) { int count = 0; T previous = default(T); bool isPrevious = false; foreach (T val in en) { if (isPrevious) if (pred(val, previous)) count++; previous = val; isPrevious = true; } return count; } ","permalink":"https://peaceiris.com/MyBlog/posts/2007-01-26-is-this-functional-code/","tags":["csharp"],"title":"Is this functional code?"},{"categories":["Uncategorized"],"contents":"I like to write code and I still manage to do it even now that it is not my primary job. I never post the things that I write because I don\u0026rsquo;t want to maintain them. Lately Charlie convinced me that I don\u0026rsquo;t have to do that. I can just throw the code out, without much preparation or implicit contract of perpetual maintenance.\nThis one is an Excel add-in that adds functions to Excel to analyze your trading and manage your portfolio. Notice that I\u0026rsquo;m not a professional trader or statistician, so the whole thing could be wrong, buggy or conceptually absurd. Probably it is all of the above.\nI used the extremely good ExcelDna to write the add-in. You need to download it and follow the instructions in HowToInstall.txt on the attached zip file to use it. I based the formulas mainly on the work of Ralph Vince. Please buy and read his books on money management as they are wonderful.\nOn the statistics side: I made up the Downside correlation coefficient, I have no idea if it is statistically sound.\nOn the technical side:\n I haven\u0026rsquo;t optimized the algos at all. I.E. I\u0026rsquo;m sure there is a way to calculate the standard deviation without navigating the array twice, but I didn\u0026rsquo;t bother to look. They end up being fast enough anyhow (apart from the Monte Carlo related functions that I should investigate). I haven\u0026rsquo;t organized the code correctly. It needs to be rewritten now that I partially know what I\u0026rsquo;m doing. I haven\u0026rsquo;t used LINQ. It will be a lot of fun for me to rewrite the code to be more OO and to use LINQ in the process.  I plan to implement OptimalF for a normal distribution and Efficient Frontier calculations in the future. I have no idea when.\nI also have some other projects that might be interesting to share (I.E. a blackjack simulator that you can use to try the result of different strategies inspired by Blackjack Attack).\nThis is the list of Excel functions that you get with this add-in. They ends up in a Trading category in the list of functions on the Insert Function Excel dialog:\nAnnualizeRet(double, double)\nAnnualizeStdevp(double, double)\nAnnualStdevpParam(double, double)\nArithMean(object[,], double, double, object, double, double)\nAutoCorrel(object[,])\nAvgLoss(object[,], double, double, object, double, double)\nAvgWin(object[,], double, double, object, double, double)\nChebyshev(double)\nCorrelat(object[,], object[,])\nDescribe(object)\nDownCorrelat(object[,], object[,], double)\nDownStdevp(object[,], double)\nEGM(double, double)\nEGM2(double, double)\nGM(object[,], double, double, object, double, double)\nKelly(double, double) TradingLibrary.Losses(object[,])\nMaxDD(object[,])\nMaxDDFromEq(object[,])\nMaxLoss(object[,])\nMaxNegRun(object[,])\nMaxWin(object[,])\nMCMaxDD(object[,], double)\nMCOptimalF(object[,], double, double, double)\nOptimalF(object[,], double, double)\nOptimalFArray(object[,], double, double, double)\nOptimalPos(double, double)\nPortAnnualGM(double, double, double, double, double, double, double, double)\nPortAnnualTaxGM(double, double, double, double, double, double, double)\nPortAnnualTaxGMGivenTrades(object[,], double, double, double, double, double, object, double, double)\nPortStdevp(double, double, double)\nPRR(object[,], double, double, object, double, double)\nPRRParam(double, double, double, double)\nRealReturn(double, double, double, double)\nRunTest(object[,])\nSharpeRatio(double, double, double)\nSortinoRatio(double, double, double)\nStdevp2(object[,], double, double, object, double, double)\nTWR(object[,], double, double, object, double, double)\nWins(object[,]) \u0026nbsp; \nTradingLibrary.zip\n","permalink":"https://peaceiris.com/MyBlog/posts/2007-01-04-a-tradingportfolio-management-excel-add-in-based-on-the-books-by-ralph-vince/","tags":["csharp","Financial"],"title":"A trading/portfolio management Excel Add-in based on the books by Ralph Vince"},{"categories":["Uncategorized"],"contents":"Now we can finally blog about our PDC sessions. We have been working for more then a year on this data language integration stuff and it is quite exciting to be able to talk about it publicly. Here are the sessions involved. They are all tied together by a common theme. They are all part of the same big project.\n**The .NET Language Integrated Query Framework: An Overview\u0026rsquo;\n** This is an overview of the overall project. Anders is an excellent speaker and this is a prerequisite for the other sessions. Don\u0026rsquo;t miss it\n**\nC#: Future Directions in Language Innovation from Anders Hejlsberg\n** Mr. Anders again. If you are a C# programmer, this is one you really want to see\n**Using the .NET Language Integrated Query Framework with Relational Data\n** Despite the speaker (probably yours truly) this is a great talk, databases and objects, hmmm sounds interesting\n**Using the .NET Language Integrated Query Framework with XML Data\n** Do you want to see how to query XML in a rather innovative way? Here you have it\nVisual Basic**: Future Directions in Language Innovation\n** This is the equivalent of Anders\u0026rsquo; C# talk. Come and see where VB is going\n","permalink":"https://peaceiris.com/MyBlog/posts/2005-07-14-our-sessions-at-the-pdc/","tags":["csharp"],"title":"Our sessions at the PDC"},{"categories":["Uncategorized"],"contents":"Here it is: http://blogs.msdn.com/scottno/archive/2005/04/14/408212.aspx\n","permalink":"https://peaceiris.com/MyBlog/posts/2005-04-14-there-is-a-c-language-chat-coming/","tags":["csharp"],"title":"There is a C# Language chat coming"},{"categories":["Uncategorized"],"contents":"Here is the link: http://www.gotdotnet.com/Community/MessageBoard/MessageBoard.aspx?ID=5627. Check it out.\n","permalink":"https://peaceiris.com/MyBlog/posts/2005-03-28-here-is-a-message-board-about-the-c-language/","tags":["csharp"],"title":"Here is a message board about the C# language"},{"categories":["Uncategorized"],"contents":"I discussed this topic in a previous post http://blogs.msdn.com/lucabol/archive/2004/07/30/202394.aspx and I received a number of emails telling me how crazy I was even speculating that, at the current juncture, it may be more convinient to rent than to buy a house.\nThis week The Economist runs a piece where they make the same exact claim. House prices are so high and rents are so low all over the world that renting might, indeed, be better. Even considering the low interest rate environment, it would seem that the house prices are out of step with reality, very much as equities where in the 90\u0026rsquo;s.\nIt is all a game of expectations. The harder things to estimate are the future house price gain and the interest rate/gain you can get by investing the difference between rent and mortgage payments. By using difference estimates, you get difference answers. My own opinion is that the probabilities weight against buying an house at this time. Here is a spreadsheet to help you out: http://blogs.msdn.com/lucabol/archive/2004/08/18/216662.aspx .\nThere are other considerations: I bought a house not to get killed by my wife 🙂 But I\u0026rsquo;ve been able to limit the expense and I avoided investing more money in real estate.\n","permalink":"https://peaceiris.com/MyBlog/posts/2005-03-09-to-rent-or-to-buy-a-house-some-more-evidence-of-my-unpopular-thesis/","tags":["Financial"],"title":"To rent or to buy a house, some more evidence of my unpopular thesis"},{"categories":["Uncategorized"],"contents":"This is a question that came up on our internal alias. I thought it might be generally interesting to illustrate how the compiler picks operators.\nHere is the original issue. This code compiles fine:\nUInt64 vUInt641 = UInt64.MaxValue;\nconst int vInt2 = 1432765098;\nint res = (int)(vUInt641 - vInt2);\nBut this code generates a compile error:\nUInt64 vUInt641 = UInt64.MaxValue;\nint vInt2 = 1432765098;\nint res = (int)(vUInt641 - vInt2);\n(line 3): error CS0019: Operator ‘-‘ cannot be applied to operands of type ‘ulong\u0026rsquo; and ‘int\u0026rsquo;\n The only difference between the two pieces of code is the presence of the const keyword in the first one. Let\u0026rsquo;s first analyze the second case. The reason an error is generated is that there is no ‘-‘ operator defined between an ulong and an int. There is also no implicit conversion between int and and ulong or the other way around. The compiler has to give up and to produce an error.\nIn the first case the variable is marked as const, which means that the compiler knows its value at compile time. It realizes that the value is positive and can safely been converted to an ulong. The compiler converts it and then invokes the -(ulong, ulong) operator.\nA bizarre way to think of it is this. As you have been nice to the compiler by telling him that you are not going to modify this value, the compiler then is nice to you by making use of the info to help you out in this case\nRemember, always be nice to the compiler, the more you tell him, the more he tells you\n","permalink":"https://peaceiris.com/MyBlog/posts/2005-02-10-compiler-trivia-const-operators-and-being-nice-to-the-compiler/","tags":["csharp"],"title":"Compiler trivia: const, operators and being nice to the compiler"},{"categories":["Uncategorized"],"contents":"Another commonly asked question relates to the behavior of Nullable when used as type parameter to instantiate a generic class. It might be surprising that comparing such a parameter to null gives always false as a result. As it turns out, this is not related to Nullable, but it is a result of how generics are implemented. There is a tendency to think about generics in a manner very similar to C++ templates, this view is unfortunately not correct.\nGenerics have a runtime representation and, as such, the compiler needs to generate IL that works whatever type is used at runtime to instantiate the generic class. This means that the compiler cannot call user defined operators, because at compile time it has no knowledge about them. The compiler doesn’t know at that point which type will be used to instantiate the generic class in the future. It cannot know that it has to generate code to call these user-defined operators.\nIn the same vein the compiler doesn’t know that a generic class will be instantiated with a Nullable parameter and so it cannot produce IL to lift operators (i.e. the equality operator ‘==’ ). The result is that when the programmer writes code like ‘t==null’, the compiler generates IL to call the ‘standard’ ‘==’ operator, which in the case of Nullable returns false because t has the runtime type of struct.\nA similar behavior is observable with the following code using strings:\n  string s1 = Bob John;  string s2 = Bob;  Console.WriteLine(Equals(s1, s2 + John));  static bool Equals(T a, T b) where T:class {  return a == b;  }    This code would return false, because the ‘==’ operator for reference types gets invoked.    A case could be made that the compiler should generate IL to check the runtime type of the generic parameter and call the correct operator for at least some well-known types. This solution wouldn’t work for user defined operators as the compiler doesn’t know at compile time the set of types that could be used to instantiate a generic class. In general we don’t like to keep this sort of ‘lists of special things’ in the codebase, More importantly the solution would impose a somehow significant performance penalty at each use of the operator. This feeling of ‘hacking’ things and the significant performance problem convinced us not to implement this solution.   \u0026nbsp;   ","permalink":"https://peaceiris.com/MyBlog/posts/2005-02-03-nullable-trilogy-part-iii-nullablet-as-type-parameter-in-a-generic-class/","tags":["csharp"],"title":"Nullable trilogy part III: Nullable as type parameter in a generic class"},{"categories":["Uncategorized"],"contents":"A question that often comes up when we discuss Nullable is about the anti-symmetric property. This property states that if a==b then a\u0026gt;=b and a\u0026lt;=b. If a and b are null then this property is not satisfied in the current design as the result of \u0026gt;= and \u0026lt;= is always false when one of the parameters is null. This may seems surprising, but it can be easily understood when considering if null can be ordered.\nWe decided that null being less of (or more of) all the other elements in the domain would be an arbitrary decision and as such null cannot be ordered. If it cannot be ordered then the result of the relational operators for null is false as these operators can be defined as:\n  aordered(a,b) \u0026\u0026 aaordered(a,b) \u0026\u0026 (a  It might be argued that for practical reasons it is convenient to have the = operators return true in case null is on both sides, but this choice has some practical drawbacks. Consider the following code:   void ProcessTransactions(int?[] transactions, int? maxValue) {  foreach(int? t in transactions)  if(t }    This code does what the programmer expects, even when maxValue is null (in which case it won’t process any element). Now let’s suppose that the programmer changes his mind and wants to include maxValue in the processing. He will then change the ‘Under the current design he will obtain what he expects, even in the case maxValue is null. By considering null = null as true, this function would suddenly start processing all the null transactions, which is not what the programmer intended. The problem here is that people tend to think about the ‘=’ and ‘= has to return false to be conceptually consistent and to prevent these quite subtle bugs to occur. ","permalink":"https://peaceiris.com/MyBlog/posts/2005-01-27-nullable-trilogy-part-ii-a-b-ab-a/","tags":["csharp"],"title":"Nullable trilogy part II: a == b -\u0026gt; a\u0026gt;=b \u0026amp;\u0026amp; a"},{"categories":["Uncategorized"],"contents":"Express yourself about this DCR: http://blogs.msdn.com/scottno/archive/2005/01/19/356347.aspx Partecipate to the C# language chat: http://blogs.msdn.com/scottno/archive/2005/01/19/356358.aspx That's it. ","permalink":"https://peaceiris.com/MyBlog/posts/2005-01-24-new-c-things-happening/","tags":["csharp"],"title":"New C# things happening"},{"categories":["Uncategorized"],"contents":"This is the first of a weekly three part serie of posts about Nullable. In these posts I want to describe the reasons behind three design choices:\n Why not just use SQL semantics for null? Why null == null doesn\u0026rsquo;t imply null \u0026gt;= null and null \u0026lt;= null? Why inside a generic class with a type parameter t the expression t == null will return false, when t is a nullable type and the value of it is null.  Let\u0026rsquo;s start from the first question as the answer is shorter. We\u0026rsquo;ll get to the other two in the coming weeks.\nThe first question relates to the reason not to have the same semantics as SQL for relational operators. The SQL semantics have been commonly referred to as three-value logic where null == null returns null. Introducing such logic in the C# language would be problematic. The main reason is that the language already contains the concept of null for reference types and it does have the programming languages traditional two-value logic where null == null returns true.\nGranted that we cannot change this definition, then the addition of three-value logic just for some types would be confusing. We would need, for example, to create a new NullableString class to be able to apply three-value logic operators to it. More generally, the presence in the same code of two value logic and three value logic operators would make the code quite difficult to write, read and maintain.\n ","permalink":"https://peaceiris.com/MyBlog/posts/2005-01-20-nullable-trilogy-part-i-why-not-just-sql/","tags":["csharp"],"title":"Nullable trilogy Part I: why not just SQL?"},{"categories":["Uncategorized"],"contents":" Today I was looking through an internal C# user group list. One of the messages was about x+=x++; and what should be the right behavior. I thought this is more generally interesting, so I decided to blog it. But first, DO NOT WRITE THAT CODE!!!  Ok, with that out of the way, we can start…  Let’s take this code as an example:  int x = 3;  x += x++;  The first thing the compiler does whenever it sees something like z += y is to convert it to z = z + y. This is obviously true for +=, -=, *=, and /=. Ok, this was easy. Now we have just to consider:  x= x + x++;  This, by the way, gives the same result as:  x = x + x;  This, by the way, gives a different result from:  x = x++ + x;  This, by the way gives the same result as:  x = x + ++x;  As maddening as this may seem, it actually makes sense (once you understand how it works). But first, what is the difference between x++ and ++x? x++ returns the value of x to the current expression and then increments x. ++x increments x and then return its value to the current expression. Given this factoid (and knowing that c# evaluates expressions left to right), we can then consider what happens in the following case:  int x = 3;  x = x + x++;  Here is how the compiler conceptually evaluates it:   x = (x) + x++ - the first x gets evaluated and returns 3, x = 3   x = 3 + (x)++ - x gets evaluated and returns 3, x = 3   x = 3 + (x++) - x++ gets evaluated and x is incremented (to 4), x = 4   x = (3 + 3) - 3 + 3 gets evaluated and returns 6, x = 4   (x = 6) - x is assigned to 6 (overriding the previous value of 4)    Now let’s see how this one works:  int x = 3;  x = x++ + x;   x = (x)++ + x - x gets evaluated and returns 3, x =3   x = (x++) + x - x++ gets evaluated and x is incremented, x=4   x = 3 + (x) - x gets evaluated and returns 4, x = 4   x = 3 + 4 - 3+4 gets evaluated and returns 7, x = 4   (x=7) - x is assigned to 7 (overriding the previous value of 4)    Now let’s get to this one:  int x = 3;  x = x + ++x;   x = (x) + ++x - x gets evaluated and returns 3, x=3   x = 3 + (++x) - ++x gets evaluated and x is incremented, x=4   x = 3 + (x) - x gets evaluated and returns 4, x=4   x = 3 + 4 - 3+4 gets evaluated and returns 7, x = 4   (x=7) - x is assigned to 7 (overriding the previous value of 4)    I hope this is clear. By the way, in c++ the behavior for this expression is undefined…  But now… why did we make this legal? Why not err or warn at compilation time? Well…   We were wrong, we should have erred or warned, but now it is too late because if we change this we break code OR   It is quite complex to form a set of guidelines that the compiler can evaluate to be able to err just in the bizarre cases OR   We prefer to spend our time working on things people really care about instead of these corner-corner-corner cases    Does it matter which of the previous options is the correct one? Not really because…  YOU ARE NOT GOING TO WRITE THAT CODE J\n  ","permalink":"https://peaceiris.com/MyBlog/posts/2004-08-31-xx/","tags":["csharp"],"title":"x+=x++;"},{"categories":["Uncategorized"],"contents":"Does anyone know if the homeowner association president for a condominium complex is legally forced to give the transcripts of their meetings to prospective buyers?\nIt is quite funny, the lady in charge just doesn\u0026rsquo;t want to talk to me. I know, I know, I shouldn\u0026rsquo;t buy that condo then love over reason\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-08-18-homeowner-association-transcripts/","tags":["Miscellanea"],"title":"Homeowner association transcripts"},{"categories":["Uncategorized"],"contents":"Someone asked me for the spreadsheet I used for the calculations in my previous posts. Here you have it. The data doesn\u0026rsquo;t reflect my current situation.\nFeel free to use it with your own numbers (and tell me of any bug).\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-08-18-rent-or-buy-spreadsheet/","tags":["Financial"],"title":"Rent or buy spreadsheet"},{"categories":["Uncategorized"],"contents":"It is always interesting for me to look at debates about object relational layers. I propose we define different levels of object relational support:\n  No support: all the objects are persisted and queried by writing ADO.NET code by hand\n  Code generation: you run a tool on your database (or on an abstract description of your schema) and the tool generates a bunch of objects for your tables and some ADO.NET code to retrieve/persist their state\n  Total code gen: the tool generates all the ADO.NET code\n  Partial code gen: the tool generates just code to intercept property accessors and provide delay loading, but all the data access code is in a separate compiled component\n  Metadata based: no code generation phase. The access to fields and property goes through reflection and the data access code is not exposed in the user code\n  Semi transparent: the persistent classes or properties need to be marked in some special way to be persisted (attributes, inherit from a special class or such)\n  Transparent: the classes don\u0026rsquo;t need to be modified at all to be persisted\n  Things get fuzzy, though. It is sometime unclear the difference between 2.2 and 3.1 and various creative solutions can be hard to classify. But in a general sense, this classification is probably about right. In a generic sense EJB1.1-2.0 is a 2.2, EJB3.0 is a 3.1, JDO is 3.2 (if you don\u0026rsquo;t consider post-compilation) and ObjectSpaces is a 3.2. Hibernate and Toplink are squarely 3.2.\nBut do you really need to go all the way to 3.2? All the times? I\u0026rsquo;ll try to post more about trade-offs in all these solutions, but if you have an idea of a better categorization, please let me know. The one I propose is right out of my head and I\u0026rsquo;m not to happy about it either.\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-08-06-how-much-object-relational-framework-do-you-really-need/","tags":["csharp","Object Orientation"],"title":"How much object relational framework do you really need?"},{"categories":["Uncategorized"],"contents":"I used to play a lot, back in Italy. We would come out from work, go to the beach, play two or three hours, swim a bit and then go out for the night. This would happen about every day. We took it awfully seriously. We would go to the Italian national championships and all. It was quite a big deal.\nSeattle, on the other hand, is not too conductive to beach volley. Not too many real beaches and all of them quite far (commute wise) from where I live. So I don\u0026rsquo;t play anymore, but I still like the game. One weekend or two each year, my wife and I go down to Los Angeles to watch AVP tournaments. And man, it is a lot of fun!!\nAnd, by the way, beach volley has a lot going for it. For the players it is a low impact sport (the sand is soft). Plus you play the ball a lot, much more than in normal volleyball (or even soccer). Your are always in to the game, no place for hiding. It happens under the sun, so you don\u0026rsquo;t get all the nasty problem of not warming up correctly. And the environment oh man!! You are on the beach, not in some crazy smelling gym somewhere. All in all, you got to love it.\nAnyway, down memory lane\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-08-05-im-really-an-old-almost-fat-beach-volley-player/","tags":["Sport"],"title":"I am really an old, almost fat, beach volley player"},{"categories":["Uncategorized"],"contents":"This is a book about Catalysis, an OO methodology. I read this book some time ago (like years). It is a quite complex book. If you don\u0026rsquo;t like methodologists, it will easily put you to sleep. But if you stay awake, it is worth it.\nIt is strange how this book crystallized one concept for me: the definition of an interface. An interface is not just the sum of the signatures of the methods. It is a conceptual framework. The only way to fully describe it is to describe in a formal way this conceptual framework. For example without further specification it is impossible to know how to use this interface:\ninterface IBook() {\n void AddPage(IPage p);\n}\nWhat happens when you add a page? Will it add it at the end of the book? At the start? What happens if you call the method twice? Will the pages be in order? Will they be in the same section? Is there a concept of a section?\nThere are ways to make explicit the implicit model beyond an interface: the one that I\u0026rsquo;ve commonly seen being used is documentation. The book argues for formal contracts (preconditions, postconditions, invariants). The latter is certainly more formal, but to use it you need to describe formally what is the state beyond the interface and how the different methods affect this state. It is a lot of work.\nIs it worth the effort? I guess it depends on a zillion things like: the type of project, the people involved, I don\u0026rsquo;t think anybody is actually doing it, but it is still a good conceptual framework to keep in mind when you define your interfaces: it is not enough to write down the signature methods, you have somehow to expose the conceptual framework (where somehow means more or less formally).\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-08-03-book-objects-components-and-frameworks-with-uml-fedmond-f-dsouza/","tags":["Books","Object Orientation"],"title":"Book: Objects, Components, and Frameworks with UML, Fedmond F. D`Souza"},{"categories":["Uncategorized"],"contents":"I think I\u0026rsquo;ve been misinterpreted in my previous posts. I\u0026rsquo;m not suggesting that renting is better than owning. You have to run your numbers and make your own choice. There are many assumptions to consider (financial and not). The not financial ones often are more important. You have to run your numbers, but in general renting looks better if:\n You cannot buy ( 🙂 ) and/or You plan to stay in a place for a short time and/or You believe houses are vastly overpriced in your area and they\u0026rsquo;ll return will be negative for a while and/or You don\u0026rsquo;t want the psychological part of having a house (maintenance, tax payments,)  In my case the most worrisome scenario is 3.\nBack to our situation, we are buying a house for the pleasure of living in a particular location. Financially it is an OK transaction (fair price, I think).\nI\u0026rsquo;ll probably post a little rent-buy spreadsheet as soon as I have time to refine it.\nThanks for all the good comments.\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-08-02-im-buying-a-house/","tags":["Financial"],"title":"I am buying a house"},{"categories":["Uncategorized"],"contents":"Spurred by some comments to a previous post I quickly run these numbers. They analyze the case of house price not rising in the next five years. I'll take more time to check them if I really get to a point of deciding, but they should be correct. \u0026nbsp; This data (fairly typical in my area): \u0026nbsp; Home price: $200,000 Down payment: $0 Interest rate: 6% Monthly mortgage: 1210 Rent: 750 Annual gains on investments: 6% \u0026nbsp; If I run this for 5 years and house appreciation 0% I get: $33,043 on investing the rent-mortgage difference $30,609 on paying the mortgage (equity accumulation + tax savings at 28%) \u0026nbsp; If we assume to put down 20% to buy the house then the numbers are even worse: $83,542 on investing the down payment and the rent-mortgage difference $67,548 on paying the mortgage (equity accumulation + tax savings at 28%) \u0026nbsp; There are other things to consider: house repairs for houses, annual raises in rent, etc etc \u0026nbsp; Are those assumptions reasonable? So it is better to rent than to buy? Well, over the long term houses do tend to appreciate and the more leverage you have, the more you reap the benefits. Over the short term, run your numbers. There are so many assumptions you can make, that it become almost a personal opinion what is best. \u0026nbsp; Running the numbers help you in making sure than it is at least an informed opinion. It makes your assumptions explicit\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-07-30-to-rent-or-to-buy-a-house/","tags":["Financial"],"title":"To rent or to buy a house??"},{"categories":["Uncategorized"],"contents":"I'm refining my understanding of how to value residential properties. There is this rule of thumb: buy when you can get a rent for the property which is at least 1.2% of the property price (or in another form, when the home price is 7x the annual rent). This is an approx for a more formal spreadsheet (which I have). \u0026nbsp; This is fine and dandy, but in the area I'm interested in a typical one bedroom condo sells for around 200,000-300,000 and you can get a monthly rent of $1,000-1,300. This doesn't work by a very large factor. Hmmm \u0026nbsp; Let's change the target to a cheaper area. Now I can probably get around 800 monthly. To make things work I need to find a condo for $67,200. Not an easy task, almost impossible. \u0026nbsp; It looks like for me it is hard to find a house in an area I like and at the same time make a good investment (unless the market bails me out by raising home prices at a high rate). There is quite a large disconnect between house prices and rents now. Maybe the residential market is really on the brink of a fall Time to rent again? ","permalink":"https://peaceiris.com/MyBlog/posts/2004-07-29-my-quest-for-a-new-home/","tags":["Financial"],"title":"My quest for a new home"},{"categories":["Uncategorized"],"contents":"My wife and I are planning to move somewhere where you can walk to shops and restaurants. We were thinking about selling or renting our current suburbia home. So, as usual, I picked up a bunch of books from the local library. This is one of them. Amazon reviews are\u0026nbsp;here. \u0026nbsp; My opinion on the book The author did a good job of providing numeric evidence of the possibility of a real estate bubble. What I didn't like is that he didn't provide a logical framework to evaluate residential real estate. I was expecting some sort of DCF model that uses rent as the free cash flow. Instead he cites Median house/Median Income and some other contingent evidence to prove his point. It is like a book on stock evaluation that just uses historical P/E as a measure. He also fail to present similar situations that resulted\u0026nbsp;in a crisis. Quite disappointing in that regard \u0026nbsp; How it relates to my choice of sell or rent I created my own excel spreadsheet to look at the two different scenarios (if you are interested I can share). It looks like renting is the loosing one. We gain more by selling and investing the equity in a conservative way. The book made me take a hard look at our local real estate market: the ratio Median House/Median Income is about 4.3 (above 3 is bad). Rents are low and house prices have been growing like crazy. This makes me think to buy a small condo, or even to rent for a while. We haven't really decided yet. \u0026nbsp; Book summary 1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; House prices are high while everything else is low: rents, economy, stocks Yes, there are bigger houses now and rates are low (but won't stay low forever) 2.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Mortgage takes more and more of the average salary, foreclosures and personal bankruptcies are at record high. People is more and more leveraged 3.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The house market is far away from an ideal market. A bunch of lenders really make the prices. Bubble can easily create in inefficient markets 4.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; People think houses can just go up: same mindset as the internet bubble 5.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; House prices have been growing like crazy. The fast growers of the past are the fastest growers now: it is like momentum in stocks 6.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Many of the previous crashes were based on leverage and some kind of Ponzi scheme 7.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; It will start if rates goes up (people can afford less), if they go down (the economy will be very weak), banks become less aggressive in lending, congress reduces tax benefits 8.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Under a worst case scenario Fannie Mae and Freddie Mac ($3 trillion of very leveraged and derivative invested money) stumble and then it may be a worldwide depression as banks credibility goes down 9.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; What you can do: decrease your exposure to real estate (rent, downsize or move to cheaper area), be less leveraged, hedge your real estate exposure by not buying real estate cyclical stocks ","permalink":"https://peaceiris.com/MyBlog/posts/2004-07-28-book-the-coming-crash-in-the-housing-market-john-r-talbott/","tags":["Books","Financial"],"title":"Book: The coming crash in the housing market, John R. Talbott"},{"categories":["Uncategorized"],"contents":"I always thought: why people write this very long posts? Here you have it. \u0026nbsp; How do I design my objects? What is the set of constraints that dictate my design decisions? People talk about objects in very different contexts. A certain amount of confusion derives from not identifying the contexts for our objects. \u0026nbsp; First, kings of them all, there are business objects. My library is full of OO books that describe how to design these guys. We have patterns and anti-patterns. Everybody is out there promoting their own methodology. But if we go deep enough, the most important design task in creating them is assigning responsibilities. This concept is as old as OO itself; it finds its roots in CRC cards. But I digress. Once again, when you design your business objects you have to be very careful to assign responsibilities to the objects that have the right information to perform them. \u0026nbsp; It would be nice if this was all you have to code. A crazy bigot (like me) would think that all the rest is infrastructure (ala naked objects). But we live in the real world, so let's get down to it. \u0026nbsp; A second category of objects I often encounter are network objects. These are the guys you use to communicate data across tiers (logical, physical, webservices). They are usually quite dumb objects, not too much logic in them (if any), and your application creates them by filling their properties from the more noble business objects. Something along the line of the value object pattern. Is assigning responsibilities a very important task here? Heck no!! They don't even have methods!! The most important characteristic they have is bandwidth optimization; you want to retrieve a whole bunch of stuff in one single round trip. More often than not you sacrifice everything else (manageability, good design) to achieve that. \u0026nbsp; This is why I don't believe the quite common ideal of remoting your business objects. The set of constraints you use to design them is completely different (often opposite) to the constraints needed to go over the wire. When anything goes over the wire it becomes just data. Moreover not all of your business state needs to go on the network, but this is another story \u0026nbsp; Another common object category is database objects. There is a big debate if they are the same as business objects or not. I dont' want to go there, but If you want them to be the same you usually pragmatically sacrifice a bit of OO purity to make them more similar to the database tables (you don't want to fight your object relational mapping layer, you want to help it out). To say this in a more positive way, you design your domain model with an eye on how you are going to persist it. If, on the other end, you are willing to create a separate set of objects to represent data coming from the database, then the main constraint for these guys is the same as your database tables: normalization. This is not surprising as they are mirrors of your database. Again assigning responsibilities and being network friendly take the back seat in this case. \u0026nbsp; There are many other object categories I often found useful (i.e. fa\u0026#231;ade objects). I don't want to discuss all of them here. Things are already boring as they are. The central point is that it is very hard to\u0026nbsp;define generic guidelines that work well in all the different contexts. You got to think about your context first. \u0026nbsp; The funny thing is that I work in a place where we are supposed to design features that are generically interesting in all these scenarios. You use C# to code all of them. Oh well, design is the art of choosing trade offs ","permalink":"https://peaceiris.com/MyBlog/posts/2004-07-27-please-the-perfect-object-stand-up/","tags":["csharp","Object Orientation"],"title":"Please the perfect object stand up!!"},{"categories":["Uncategorized"],"contents":"Hello folks, My crazy coworkers finally convinced me to get my own blog. They think I'll say something funny, but I won't - so don't link to me - it's probably not worth it. For the few perseverant ones, here is what I plan to talk about: object orientation, c#, sports, financial stuff and books (not in that order). See you later. \u0026nbsp; BTW: strange how this blog thing reduces the complexity of one's personality to a bunch of categories on the left of the screen ","permalink":"https://peaceiris.com/MyBlog/posts/2004-07-27-my-first-and-last-post/","tags":["Miscellanea"],"title":"My first (and last?) post"},{"categories":["Uncategorized"],"contents":"I\u0026rsquo;m Luca Bolognese.\nI\u0026rsquo;m the Principal Group Program Manager for the C#, VB and F# languages, compilers and IDEs. Before that, I was the LINQ guy. Before that, I was the ObjectSpaces guy.\nIn my spare time, I read a lot of books. I mean: a lot. I\u0026rsquo;m not sure how much I retain. I also try to keep some form of physical shape by playing sports and walking.\nAll in all, I try to recreate my own Italian lifestyle in the Kirkland area.\n","permalink":"https://peaceiris.com/MyBlog/posts/2004-07-27-here-i-am/","tags":["Miscellanea"],"title":"Here I am."},{"categories":null,"contents":" Matching pages    ${title} ${snippet}\n${ isset tags }Tags: ${tags}\n${ end }      ","permalink":"https://peaceiris.com/MyBlog/search/","tags":null,"title":"Search"}]