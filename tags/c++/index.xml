<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Lucabol blog</title>
    <link>https://peaceiris.com/MyBlog/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Lucabol blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Jun 2012 06:45:26 +0000</lastBuildDate>
    
	<atom:link href="https://peaceiris.com/MyBlog/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Writing functional code in C&#43;&#43; V – Miscellaneous and conclusions</title>
      <link>https://peaceiris.com/MyBlog/posts/2012-06-01-writing-functional-code-in-c-v-miscellaneous-and-conclusions/</link>
      <pubDate>Fri, 01 Jun 2012 06:45:26 +0000</pubDate>
      
      <guid>https://peaceiris.com/MyBlog/posts/2012-06-01-writing-functional-code-in-c-v-miscellaneous-and-conclusions/</guid>
      <description>Just a couple of trivialities and my parting thoughts.
Nested functions If your language has lambdas, you don’t need nested functions support because you can implement them using it.
I am a heavy user of nested functions, but I’m of two minds about it. On one side, I like that they sit close to where they are used, avoiding going outside the main function body to understand them. I also like that you don’t need to pass a lot of parameters to them, as they capture the function locals.</description>
    </item>
    
    <item>
      <title>Writing functional code in C&#43;&#43; IV – Algebraic datatypes</title>
      <link>https://peaceiris.com/MyBlog/posts/2012-04-27-writing-functional-code-in-c-iv-algebraic-datatypes/</link>
      <pubDate>Fri, 27 Apr 2012 09:29:00 +0000</pubDate>
      
      <guid>https://peaceiris.com/MyBlog/posts/2012-04-27-writing-functional-code-in-c-iv-algebraic-datatypes/</guid>
      <description>And here comes the guilt bit. I have the strong suspicion (but not certainty) that what I am doing here can be done with templates, but didn’t take the time to do it. With that out of the way, let’s go.
Code for this post is here. Thanks to Steve Bower and Andy Sawyer for reviewing it.
Algebraic datatypes (discriminated unions in F#) are a powerful concept in functional programming. They are the main way to represent type variation in your program.</description>
    </item>
    
    <item>
      <title>Writing functional code in C&#43;&#43; III – Performance of different allocation schemes</title>
      <link>https://peaceiris.com/MyBlog/posts/2012-04-16-writing-functional-code-in-c-iii-performance-of-different-allocation-schemes/</link>
      <pubDate>Mon, 16 Apr 2012 13:32:00 +0000</pubDate>
      
      <guid>https://peaceiris.com/MyBlog/posts/2012-04-16-writing-functional-code-in-c-iii-performance-of-different-allocation-schemes/</guid>
      <description>Now we know how to represent records and we know how to operate on them using a nice F# like syntax. But how do we store our record in a data structure in the first place?
Code for this post is here. Thanks to Andy Sawyer and Steve Bower for reviewing this.
As it is often the case, C++ gives you many options that are not available in standard functional languages.</description>
    </item>
    
    <item>
      <title>Writing functional code in C&#43;&#43; II – Function composition</title>
      <link>https://peaceiris.com/MyBlog/posts/2012-03-30-writing-functional-code-in-c-ii-function-composition/</link>
      <pubDate>Fri, 30 Mar 2012 10:11:00 +0000</pubDate>
      
      <guid>https://peaceiris.com/MyBlog/posts/2012-03-30-writing-functional-code-in-c-ii-function-composition/</guid>
      <description>Function composition is at the core of functional programming. You start by being very confident that certain very small functions are correct, you compose them in well known ways and you end up being very confident that your final program is correct.
You are very confident that the initial functions are correct because they are very small and side effect free. You are very confident that your program is correct because the means of composition are well known and generate functions that are themselves side effect free.</description>
    </item>
    
    <item>
      <title>Writing functional code in C&#43;&#43; – Records</title>
      <link>https://peaceiris.com/MyBlog/posts/2012-03-23-writing-functional-code-in-c-records/</link>
      <pubDate>Fri, 23 Mar 2012 08:11:00 +0000</pubDate>
      
      <guid>https://peaceiris.com/MyBlog/posts/2012-03-23-writing-functional-code-in-c-records/</guid>
      <description>This is the first of a series of posts about writing functional code in C++. My goal is different from FC++, which is a full fledged ‘environment’ to write functional code. Instead, I want to experiment with some of the new C++ 11 language features and see if one can build reasonably looking functional code and stay pretty close to the language. The idea is to judiciously use macros and external libraries to build a thin layer on top of the language that doesn’t change the performance characteristics of it (aka it doesn’t slow it down) and integrates fine with existing C++ code.</description>
    </item>
    
    <item>
      <title>A simple scheme to implement Design by Contract in C&#43;&#43;</title>
      <link>https://peaceiris.com/MyBlog/posts/2012-03-06-a-simple-scheme-to-implement-design-by-contract-in-c/</link>
      <pubDate>Tue, 06 Mar 2012 16:42:58 +0000</pubDate>
      
      <guid>https://peaceiris.com/MyBlog/posts/2012-03-06-a-simple-scheme-to-implement-design-by-contract-in-c/</guid>
      <description>Recently I got interested in C++ again. The new lambda functions in C++ 11 open up a world of opportunities for C++ programmers. I’ll talk more about how you can write functional code in C++ 11 in upcoming posts. For now let’s look at design by contract.
Design by contract is a development style promoted by Bertrand Meyer and it is implemented in his own Eiffel programming language. At core, it advocates using preconditions, postconditions and invariants.</description>
    </item>
    
  </channel>
</rss>