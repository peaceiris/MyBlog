<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="Other parts:
 Part I - Data modeling Part II - Html scraping Part III - Async loader for prices and divs Part V - Adjusting historical data Part VI - Code posted  Downloading splits is a messy affair. The problem is that Yahoo doesn&amp;rsquo;t give you a nice comma-delimitated stream to work with. You have to parse the Html yourself (and it can be on multiple pages). At the end of the post, the overall result is kind of neat, but to get there we need a lot of busywork.">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>Downloading stock prices in F# - Part IV - Async loader for splits | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">❧</a>
            
                <time id="blog_date" > 2008/09/09</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        Downloading stock prices in F# - Part IV - Async loader for splits
    
    </h1>

    </header>

    <main>
        

<p>Other parts:</p>
<ul>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/08/29/downloading-stock-prices-in-f-part-i-data-modeling.aspx">Part I  - Data modeling</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/09/05/downloading-stock-prices-in-f-part-ii-html-scraping.aspx">Part II  - Html scraping</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/09/12/downloading-stock-prices-in-f-part-iii-async-loader-for-prices-and-divs.aspx">Part III  - Async loader for prices and divs</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/09/26/downloading-stock-prices-in-f-part-v-adjusting-historical-data.aspx">Part V  - Adjusting historical data</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/10/20/downloading-stock-prices-in-f-part-vi-code-posted.aspx">Part VI  - Code posted</a></li>
</ul>
<p>Downloading splits is a messy affair. The problem is that Yahoo doesn&rsquo;t give you  a nice comma-delimitated stream to work with. You have to parse the Html yourself (and it can be on multiple pages). At the end of the post, the overall result is kind of neat, but to get there we need a lot of busywork.</p>
<p>First, let&rsquo;s define a function that constructs the correct URL to download splits from. Notice that you need to pass a page number to it.</p>
<pre class="code"><span style="color:blue;">let </span>splitUrl ticker span page =
    <span style="color:maroon;">"http://finance.yahoo.com/q/hp?s=" </span>+ ticker + <span style="color:maroon;">"&a="<br />    </span>+ (span.Start.Month - 1).ToString() + <span style="color:maroon;">"&b=" </span>+ span.Start.Day.ToString() + <span style="color:maroon;">"&c=" <br />    </span>+ span.Start.Year.ToString() + <span style="color:maroon;">"&d=" </span>+ (span.End.Month - 1).ToString() + <span style="color:maroon;">"&e="<br />    </span>+ span.End.Day.ToString() + <span style="color:maroon;">"&f=" </span>+ span.End.Year.ToString() + <span style="color:maroon;">"&g=v&z=66&y="<br />    </span>+ (66 * page).ToString();</pre>
<p>The reason for this particular url format (i.e. 66 * page) is completely unknown to me. I also have the feeling that it might change in the future. Or maybe not given how many people rely on it.</p>
<p>I then describe the driver function for loading splits:</p>
<pre class="code"><span style="color:blue;">let rec </span>loadWebSplitAsync ticker span page splits =
    <span style="color:blue;">let </span>parseSplit text splits =
        List.append splits (parseSplits (scrapHtmlRows text)),<br />                                           not(containsDivsOrSplits (scrapHtmlCells text))
    async {
        <span style="color:blue;">let </span>url = splitUrl ticker span page
        <span style="color:blue;">let! </span>text = loadWebStringAsync url
        <span style="color:blue;">let </span>splits, beyondLastPage = parseSplit text splits
        <span style="color:blue;">if </span>beyondLastPage <span style="color:blue;">then return </span>splits <span style="color:blue;">else<br />                                 return! </span>loadWebSplitAsync ticker span (page + 1) splits }</pre>
<p>This is a bit convoluted (it is an Async recursive function). Let&rsquo;s go through it in some detail. First there is a nested function <u>parseSplit</u>. It takes an html string and a list of observations and returns a tuple of two elements. The first element is the same list of observations augmented with the splits found in the text. The second element is a boolean that is true if we have navigated beyond the last page for the splits.</p>
<p>The function to test that we are beyond the last page is the following:</p>
<pre class="code"><span style="color:blue;">let </span>containsDivsOrSplits cells =
    cells |&gt; Seq.exists<br />        (<span style="color:blue;">fun </span>(x:string) <span style="color:blue;">-&gt; </span>Regex.IsMatch(x, <span style="color:maroon;">@"$.+Dividend"</span>, RegexOptions.Multiline)<br />                           || Regex.IsMatch(x, <span style="color:maroon;">"Stock Split"</span>))  </pre>
<p>This function just checks if the words Stock Split or Dividend are anywhere in the table. If they aren&rsquo;t, then we have finished processing the pages for this particular ticker and date span.</p>
<p>The function to extract the splits observations from the web page takes some cells (a <u>seq&lt;seq<string>&gt;)</u> as input and returns an observation list. It is reproduced below:</p>
<pre class="code"><span style="color:blue;">let </span>parseSplits rows =
    <span style="color:blue;">let </span>parseRow row =
        <span style="color:blue;">if </span>row |&gt; Seq.exists (<span style="color:blue;">fun </span>(x:string) <span style="color:blue;">-&gt; </span>x.Contains(<span style="color:maroon;">"Stock Split"</span>))
        <span style="color:blue;">then
            let </span>dateS = Seq.hd row
            <span style="color:blue;">let </span>splitS = Seq.nth 1 row
            <span style="color:blue;">let </span>date = DateTime.Parse(dateS)
            <span style="color:blue;">let </span>regex = Regex.Match(splitS,<span style="color:maroon;">@"(d+)s+:s+(d+)s+Stock Split"</span>,<br />                                                                   RegexOptions.Multiline)
            <span style="color:blue;">let </span>newShares = shares (float (regex.Groups.Item(1).Value))
            <span style="color:blue;">let </span>oldShares = shares (float (regex.Groups.Item(2).Value))
            Some({Date = date; Event = Split(newShares / oldShares)})
        <span style="color:blue;">else </span>None
    rows |&gt; Seq.choose parseRow |&gt; Seq.to_list</pre>
<p>It just take a bunch of rows and choose the ones that contain stock split information. For these, it parses the information out of the text and creates a Split Observation out of it. I think it is intuitive what the various Seq functions do in this case. Also note my overall addiction to the pipe operator ( |&gt; ). In my opinion this is the third most important keyword in F# (after ‘let&rsquo; and ‘match&rsquo;).</p>
<p>Let&rsquo;s now go back to the loadWebSplitAsync function and discuss the rest of it. In particular this part:</p>
<pre class="code">async {
    <span style="color:blue;">let </span>url = splitUrl ticker span page
    <span style="color:blue;">let! </span>text = loadWebStringAsync url
    <span style="color:blue;">let </span>splits, beyondLastPage = parseSplit text splits
    <span style="color:blue;">if </span>beyondLastPage <span style="color:blue;">then return </span>splits <span style="color:blue;">else<br />        return! </span>loadWebSplitAsync ticker span (page + 1) splits }</pre>
<p>First of all it is an Async function. You should expect some Async stuff to go on inside it. And indeed, after forming the URL in the first line, the very next line is a call to <u>loadWebStringAsync</u>. We discussed this one in the previous installment. It just asynchronously loads a string from an URL. Notice the bang after ‘let&rsquo;. This is your giveaway that async stuff is being performed.</p>
<p>The result of the async request is parsed to extract splits. Also, the <u>beyondLastPage</u> flag is set if we have finished our work. If we have, we return the split observation list; if we haven&rsquo;t, we do it again incrementing the page number to load the html text from.</p>
<p>Now that we have all the pieces in places, we can wrap up the split loading stuff inside this facade function:</p>
<pre class="code"><span style="color:blue;">let </span>loadSplitsAsync ticker span = loadWebSplitAsync ticker span 0 []<br /></pre>
<p>And finally put together the results of this post and the previous one with the overall function-to-rule-them-all:</p>
<pre class="code"><span style="color:blue;">let </span>loadTickerAsync ticker span =
    async {
        <span style="color:blue;">let </span>prices = loadPricesAsync ticker span
        <span style="color:blue;">let </span>divs =  loadDivsAsync ticker span
        <span style="color:blue;">let </span>splits = loadSplitsAsync ticker span
        <span style="color:blue;">let! </span>prices, divs, splits = Async.Parallel3 (prices, divs, splits)
        <span style="color:blue;">return </span>prices |&gt; List.append divs |&gt; List.append splits
        }</pre>
<p>All right, that was a lot of work to get to this simple thing. This is a good entry point to our price/divs/split loading framework. It has the right inputs and outputs: it takes a ticker and a date span and returns an Async of a list of observations. Our caller can decide when he wants to execute the returned Async object.</p>
<p>Notice that in the body of the function I call <u>Async.Parallel</u>. This is debatable. A more flexible solution is to return a tuple containing three Asyncs (prices, divs, splits) and let the caller decide how to put them together. I decided against this for simplicity reasons. This kind of trade-off is very common in Async programming: giving maximum flexibility to your caller against exposing something more understandable.</p>
<p>I have to admit I didn&rsquo;t enjoy much writing (and describing) all this boilerplate code. I&rsquo;m sure it can be written in a better way. I might rewrite plenty of it if I discover bugs. I kind of like the end result though. <u>loadTickerAsync</u> has an overall structure I&rsquo;m pretty happy with.</p>
<p>Next post,  some algorithms with our observations</p>



  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¶</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
            <li><a href="../../MyBlog/tags/financial">Financial</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¶</h2>
    </header>
    


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>