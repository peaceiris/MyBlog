<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="Let’ now look at the parser. First let’s review the grammar:
(* &amp;lt;expression&amp;gt; ::= &amp;lt;name&amp;gt; | &amp;lt;function&amp;gt; | &amp;lt;application&amp;gt; &amp;lt;name&amp;gt; ::= non­blank character sequence &amp;lt;function&amp;gt; ::= \ &amp;lt;name&amp;gt; . &amp;lt;body&amp;gt; &amp;lt;body&amp;gt; ::= &amp;lt;expression&amp;gt; &amp;lt;application&amp;gt; ::= ( &amp;lt;function expression&amp;gt; &amp;lt;argument expression&amp;gt; ) &amp;lt;function expression&amp;gt; ::= &amp;lt;expression&amp;gt; &amp;lt;argument expression&amp;gt; ::= &amp;lt;expression&amp;gt; *)  And the data type to represent it:
type Name = string and Body = Expression and Function = Name * Expression and FunctionExpression = Expression and ArgumentExpression = Expression and Expression = | EName of string | Function of Expression * Body | Application of FunctionExpression * ArgumentExpression | EOT In essence, the data type need to store all the information needed for subsequent stages of computation (i.">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>Adventure in parserland – parsing lambda expressions in F# – Part IV | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">❧</a>
            
                <time id="blog_date" > 2011/09/09</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        Adventure in parserland – parsing lambda expressions in F# – Part IV
    
    </h1>

    </header>

    <main>
        

<p>Let’ now look at the parser. First let’s review the grammar:</p>
<pre class="code"><span style="color:green;">(*
        &lt;expression&gt; ::= &lt;name&gt; | &lt;function&gt; | &lt;application&gt;
        &lt;name&gt; ::= non­blank character sequence
        &lt;function&gt; ::= \ &lt;name&gt; . &lt;body&gt;
        &lt;body&gt; ::= &lt;expression&gt;
        &lt;application&gt; ::= ( &lt;function expression&gt; &lt;argument expression&gt; )
        &lt;function expression&gt; ::= &lt;expression&gt;
        &lt;argument expression&gt; ::= &lt;expression&gt;
    *)
</span></pre>
<p>And the data type to represent it:</p>
<pre class="code"><span style="color:blue;">type </span>Name = string
<span style="color:blue;">and </span>Body = Expression
<span style="color:blue;">and </span>Function = Name * Expression
<span style="color:blue;">and </span>FunctionExpression = Expression
<span style="color:blue;">and </span>ArgumentExpression = Expression
<span style="color:blue;">and </span>Expression =
| EName <span style="color:blue;">of </span>string
| Function <span style="color:blue;">of </span>Expression * Body
| Application <span style="color:blue;">of </span>FunctionExpression * ArgumentExpression
| EOT</pre>
<p>In essence, the data type need to store all the information needed for subsequent stages of computation (i.e. beta reductions and such). The closer it is to the grammar, the better. In this case it looks pretty close.</p>
<p>Remember what is the main goal of our parser:</p>
<pre class="code"><span style="color:blue;">let </span>parseTextReader: TextReader <span style="color:blue;">-&gt; </span>seq&lt;Expression&gt; =
                    textReaderToLazyList &gt;&gt; tokenStream &gt;&gt; parseExpressions</pre>
<p>We have already looked at <em>TextReaderToLazyList</em> and <em>tokenStream</em>. Now it is the time to look at <em>parseExpressions</em>. It’s goal is to  parse the <em>LazyList<Token></em> and return a sequence of expressions. The choice of returning a sequence at this point is to make the <em>parseTextReader</em>, which is the main function in the program, return a more ‘standard’ type.</p>
<pre class="code"><span style="color:blue;">and </span>parseExpressions tokens = seq {
   <span style="color:blue;">let </span>tokens = parseOptionalWs tokens
   <span style="color:blue;">let </span>expr, tokens = parseExpr tokens
   <span style="color:blue;">let </span>tokens = parseOptionalWs tokens
   <span style="color:blue;">match </span>expr <span style="color:blue;">with
    </span>| EOT   <span style="color:blue;">-&gt; yield </span>EOT
    | exp   <span style="color:blue;">-&gt; yield </span>exp; <span style="color:blue;">yield! </span>parseExpressions tokens }</pre>
<p><em>parseOtionalWs</em> simply skips ahead whatever whitespaces it finds.</p>
<pre class="code"><span style="color:blue;">and </span>parseOptionalWs tokens = <span style="color:blue;">match </span>tokens <span style="color:blue;">with
                                </span>| LazyList.Nil <span style="color:blue;">-&gt; </span>LazyList.empty
                                | LazyList.Cons(h, t) <span style="color:blue;">-&gt;
                                    match </span>h <span style="color:blue;">with
                                       </span>| Ws _ <span style="color:blue;">-&gt; </span>parseOptionalWs t
                                       | _ <span style="color:blue;">-&gt; </span>tokens</pre>
<p><em>parseExpr</em> is more interesting. It is the main switch that creates expression kinds.</p>
<pre class="code"><span style="color:blue;">let rec </span>parseExpr tokens = <span style="color:blue;">match </span>tokens <span style="color:blue;">with
                            </span>| LazyList.Nil <span style="color:blue;">-&gt; </span>EOT, LazyList.empty
                            | LazyList.Cons(h, t) <span style="color:blue;">-&gt;
                                match </span>h <span style="color:blue;">with
                                    </span>| EOF <span style="color:blue;">-&gt; </span>parseEOF tokens
                                    | Name _ <span style="color:blue;">-&gt; </span>parseName  tokens
                                    | Lambda <span style="color:blue;">-&gt; </span>parseFunction tokens
                                    | OpenParens <span style="color:blue;">-&gt; </span>parseApplication tokens
                                    | token <span style="color:blue;">-&gt; </span>errorAtStart <span style="color:maroon;">"Expression" </span>token</pre>
<p><em>parseEOF</em> is not.</p>
<pre class="code"><span style="color:blue;">and </span>parseEOF tokens = EOT, LazyList.empty</pre>
<p><em>parseName</em> just returns a <em>EName</em>, unwrapping it from Name.</p>
<pre class="code"><span style="color:blue;">and </span>parseName tokens = EName (head tokens |&gt; unwrapName), tail tokens</pre>
<p>Unwrap just unwraps it.</p>
<pre class="code"><span style="color:blue;">let </span>unwrapName = <span style="color:blue;">function
    </span>| Name(s) <span style="color:blue;">-&gt; </span>s
    | tok <span style="color:blue;">-&gt; </span>errorExpecting <span style="color:maroon;">"a Name" </span>&lt;| writeToken tok</pre>
<p><em>parseFunction</em> just conumes a Lambda, a name, a Dot token, a body (i.e. \x.x)and assembles them in a Function:</p>
<pre class="code"><span style="color:blue;">and </span>parseFunction tokens =
    <span style="color:blue;">let </span>tokens = consumeToken Lambda tokens
    <span style="color:blue;">let </span>name, tokens = parseName tokens
    <span style="color:blue;">let </span>tokens = consumeToken Dot tokens
    <span style="color:blue;">let </span>body, tokens = parseExpr tokens
    Function(name, body), tokens</pre>
<p><em>consumeToken</em> tries to consume a token generating an error if it doesn’t find it:</p>
<pre class="code"><span style="color:blue;">let </span>consumeToken token =
    genericConsumeToken (<span style="color:blue;">fun </span>token' _ <span style="color:blue;">-&gt; </span>errorExpecting (writeToken token') (writeToken token)) token</pre>
<p><em>genericConsumeToken</em> is just a generalization of the function above:</p>
<pre class="code"><span style="color:blue;">let </span>genericConsumeToken noMatch token = <span style="color:blue;">function
    </span>| LazyList.Nil <span style="color:blue;">-&gt; </span>LazyList.empty
    | LazyList.Cons(h, t) <span style="color:blue;">as </span>originalTokens <span style="color:blue;">-&gt;
        match </span>h <span style="color:blue;">with
        </span>| tok <span style="color:blue;">when </span>tok = token <span style="color:blue;">-&gt; </span>t
        | tok <span style="color:blue;">-&gt; </span>noMatch token originalTokens</pre>
<p>The last thing left to consume is an application which is in this form (func args):</p>
<pre class="code"><span style="color:blue;">and </span>parseApplication tokens =
    <span style="color:blue;">let </span>tokens = consumeToken OpenParens tokens
    <span style="color:blue;">let </span>funExpr, tokens = parseExpr tokens
    <span style="color:blue;">let </span>tokens = parseOptionalWs tokens
    <span style="color:blue;">let </span>argExpr, tokens = parseExpr tokens
    <span style="color:blue;">let </span>tokens = consumeToken CloseParens tokens
    Application(funExpr, argExpr), tokens</pre>
<p>Various error and utility functions are defined below:</p>
<pre class="code"><span style="color:blue;">let </span>errorEOF expecting = failwith  (<span style="color:maroon;">"Expected " </span>+ expecting + <span style="color:maroon;">", got EOF"</span>)
<span style="color:blue;">let </span>errorExpecting expecting gotToken = failwith (<span style="color:maroon;">"Expected " </span>+ expecting + <span style="color:maroon;">", got" </span>+ gotToken)
<span style="color:blue;">let </span>errorAtStart expecting gotToken = failwith (<span style="color:maroon;">"Expected " </span>+ expecting + <span style="color:maroon;">" which cannot start with" </span>+ writeToken gotToken)
<span style="color:blue;">let </span>tail = LazyList.tail
<span style="color:blue;">let </span>head = LazyList.head</pre>
<p>And that is the parser. All 100+ lines of it. As you can tell it is rather formulaic to go from a grammar to a lexer and a parser, which is why you shouldn’t do it, but instead let a tool generate the code for you given the grammar or use FParsec.</p>
<p>We have written 200+ code and I don’t think we can be too proud of our achievement. It is:</p>
<ul>
<li>Certainly buggy</li>
<li>Primitive in error handling</li>
<li>Not tail recursive (big text is likely to blow up our stack)</li>
<li>Probably inefficient</li>
</ul>
<p>So let’s look next at a better way to do it.</p>



  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¶</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
            <li><a href="../../MyBlog/tags/lambda-expressions">Lambda expressions</a></li>
        
            <li><a href="../../MyBlog/tags/parsing">Parsing</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¶</h2>
    </header>
    


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>