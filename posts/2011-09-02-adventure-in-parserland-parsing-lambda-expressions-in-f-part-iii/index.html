<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="Let’s start from the lexer. Remember, I wrote this code based on my memory of how a lexer ought to look like. I didn’t read again the relevant chapters in the Dragon book. But I think it came out all right after all.
The tokenStream function we looked at last time takes a LazyList and returns a LazyList. It uses the unfold method on LazyList to call matchToken on each char until the stream is empty.">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>Adventure in parserland – parsing lambda expressions in F# – Part III | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">❧</a>
            
                <time id="blog_date" > 2011/09/09</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        Adventure in parserland – parsing lambda expressions in F# – Part III
    
    </h1>

    </header>

    <main>
        

<p>Let’s start from the lexer. Remember, I wrote this code based on my memory of how a lexer ought to look like. I didn’t read again the relevant chapters in <a href="http://en.wikipedia.org/wiki/Principles_of_Compiler_Design">the Dragon book</a>. But I think it came out all right after all.</p>
<p>The <em>tokenStream</em> function we looked at last time takes a <em>LazyList<char></em> and returns a <em>LazyList<Token></em>. It uses the unfold method on <em>LazyList</em> to call <em>matchToken</em> on each char until the stream is empty.</p>
<pre class="code"><span style="color:blue;">let rec </span>tokenStream chars =
    LazyList.unfold
        (<span style="color:blue;">fun </span>chList <span style="color:blue;">-&gt;
            match </span>chList <span style="color:blue;">with
            </span>| LazyList.Nil <span style="color:blue;">-&gt; </span>None
            | chList <span style="color:blue;">-&gt;
                let </span>token, chList' = matchToken chList
                Some(token, chList')
        )
        chars </pre>
<p>A token is what gets passed up to the parser to do syntactic analysis on. It is the vocabulary of our language. The lexer divide a phrase in words, the parser put together the words in a phrase. So, these are the words.</p>
<pre class="code"><span style="color:blue;">type </span>Token =
    | Name <span style="color:blue;">of </span>string
    | Dot
    | OpenParens
    | CloseParens
    | Lambda
    | Def
    | Ws <span style="color:blue;">of </span>string
    | NewLine
    | EOF</pre>
<p>Matching is a process whereas you try to return the token that you have read plus the list of characters yet to be read. Matching a Token is defined below:</p>
<pre class="code"><span style="color:blue;">let </span>matchToken = <span style="color:blue;">function
    </span>| LazyList.Nil                 <span style="color:blue;">-&gt; </span>EOF, LazyList.empty
    | LazyList.Cons(h, t) <span style="color:blue;">as </span>chars <span style="color:blue;">-&gt;
        match </span>h <span style="color:blue;">with
        </span>| ch <span style="color:blue;">when </span>isWs ch <span style="color:blue;">-&gt; </span>matchWs chars
        | ch <span style="color:blue;">when </span>isSpecialChar ch <span style="color:blue;">-&gt; </span>matchSpecialChar ch t
        | _ <span style="color:blue;">-&gt; </span>matchString chars</pre></p> 
<p>A token is either nothing, a whitespace, a special char or anything else.</p>
<p>Let’s look at what matching each one of them means.  Matching whitespaces means consuming them and remembering what was consumed.</p>
<pre class="code"><span style="color:blue;">let </span>matchWs chars =
    <span style="color:blue;">let </span>value, remainingChars = matchSeriesOfChars isWs chars
    Ws value, remainingChars</pre>
<p><em>matchSeriesOfChars</em> takes a predicate and a <em>LazyList</em> of chars and returns the string composed of all the consecutive chars for which the predicate is true, plus, as always, the remaining chars to be matched. In this case the predicate returns true if the char is a whitespace.</p>
<p>To write <em>matchSeriesOfChars</em> I need a function that reverses a LazyList. Not having found such thing, I wrote it.</p>
<pre class="code"><span style="color:blue;">let </span>reversell l =
    <span style="color:blue;">let rec </span>go l' a = <span style="color:blue;">match </span>l', a <span style="color:blue;">with
                        </span>| LazyList.Nil, a <span style="color:blue;">-&gt; </span>a
                        | LazyList.Cons(h, t), a <span style="color:blue;">-&gt; </span>go t (LazyList.cons h a)
    go l LazyList.empty</pre>
<p>Then I wrote <em>matchSeriesOfChars</em>. The function uses an accumulator. It adds to the front whenever the predicate is true, it reverses it and translates it to a string (I could have reversed the string instead, it might have been better).</p>
<pre class="code"><span style="color:blue;">let </span>matchSeriesOfChars comparer chars =
    <span style="color:blue;">let rec </span>go result = <span style="color:blue;">function
        </span>| LazyList.Nil    <span style="color:blue;">-&gt; </span>charListToString(reversell result), LazyList.empty
        | LazyList.Cons(h, t) <span style="color:blue;">-&gt; if </span>comparer h <span style="color:blue;">then </span>go (LazyList.cons h result) t
                                 <span style="color:blue;">else </span>charListToString (reversell result), LazyList.cons h t
    go LazyList.empty chars</pre>
<p>These are  predicates we’ll use later on to recognize characters:</p>
<pre class="code"><span style="color:blue;">let </span>isInString (ch: char) (s: string) = s.IndexOf(ch) &lt;&gt; -1
<span style="color:blue;">let </span>isWs (chr: char) = isInString chr wsChars
<span style="color:blue;">let </span>isNameChar (chr: char) = not (isInString chr (wsChars + specialChars))
<span style="color:blue;">let </span>isSpecialChar ch = isInString ch specialChars</pre>
<p><em>wsChar</em> and <em>specialChars</em> are defined below:</p>
<pre class="code"><span style="color:blue;">let </span>wsChars = <span style="color:maroon;">" \t"</span></pre>
<pre class="code"><span style="color:blue;">    let </span>charTokens =
        Map.ofList [
            <span style="color:maroon;">'.' </span>, Dot
            <span style="color:maroon;">'(' </span>, OpenParens
            <span style="color:maroon;">')' </span>, CloseParens
            <span style="color:maroon;">'\\'</span>, Lambda
            <span style="color:maroon;">'\n'</span>, NewLine
         ]<br />
    <span style="color:blue;">let </span>specialChars = charTokens |&gt; Map.fold (<span style="color:blue;">fun </span>s k v <span style="color:blue;">-&gt; </span>s + k.ToString()) <span style="color:maroon;">""</span></pre>
<p>Getting back to the more important matching functions, matching a special character is defined as a simple lookup in the <em>charToken</em> map:</p>
<pre class="code"><span style="color:blue;">let </span>matchSpecialChar ch chars = Map.find ch charTokens, chars</pre>
<p>We are left with matchString, this simply matches the characters until it finds a char that cannot be part of a name. It then looks it up in a list of special strings. If it finds it, it returns it, otherwise it just returns the name.</p>
<pre class="code"><span style="color:blue;">let </span>stringTokens =
    Map.ofList [
        <span style="color:maroon;">"Def"</span>, Def
    ]</pre>
<pre class="code"><span style="color:blue;">let </span>matchString chars =
    <span style="color:blue;">let </span>value, remainingChars = matchSeriesOfChars isNameChar chars
    <span style="color:blue;">let </span>specialString = Map.tryFind value stringTokens
    <span style="color:blue;">if </span>specialString.IsSome
        <span style="color:blue;">then </span>specialString.Value, remainingChars
        <span style="color:blue;">else </span>Name(value), remainingChars</pre>
<p>And we are done with the lexer, all of 100+ lines of it …</p>



  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¶</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
            <li><a href="../../MyBlog/tags/lambda-expressions">Lambda expressions</a></li>
        
            <li><a href="../../MyBlog/tags/parsing">Parsing</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¶</h2>
    </header>
    


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>