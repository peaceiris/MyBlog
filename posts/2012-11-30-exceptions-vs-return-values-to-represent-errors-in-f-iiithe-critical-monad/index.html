<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="Code for this post is here.
In the last post we looked at some Critical code and decided that, albeit correct, it is convoluted. The error management path obfuscates the underlying logic. Also we have no way of knowing if a developer had thought about the error path or not when invoking a function.
Let’s tackle the latter concern first as it is easier. We want the developer to declaratively tag each method call with something that represents his intent about managing the Contingencies or Faults of the function.">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>Exceptions vs. Return Values to represent errors (in F#) – III–The Critical monad | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">❧</a>
            
                <time id="blog_date" > 2012/11/11</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        Exceptions vs. Return Values to represent errors (in F#) – III–The Critical monad
    
    </h1>

    </header>

    <main>
        

<p>Code for this post is <a href="https://github.com/lucabol/ErrorExceptional">here</a>.</p>
<p>In the last post we looked at some Critical code and decided that, albeit correct, it is convoluted. The error management path obfuscates the underlying logic. Also we have no way of knowing if a developer had thought about the error path or not when invoking a function.</p>
<p>Let’s tackle the latter concern first as it is easier. We want the developer to declaratively tag each method call with something that represents his intent about managing the Contingencies or Faults of the function.  Moreover if the function has contingencies, we want to force the developer to manage them explicitly.</p>
<p>We cannot use attributes for this as function calls happen in the middle of the code, so there is no place to stick attributes into. So we are going to use higher level functions to wrap the function calls.</p>
<p>The first case is easy. If the developer thinks that the caller of his code has no way to recover from all the exceptions thrown by a function, he can prepend his function call with the ‘fault’ word as in:</p>
<pre class="code"><span style="background:white;color:black;">fault parseUser userText</span></pre>
<p>That signals readers of the code that the developer is willing to propagate up all the exceptions thrown by the function parseUser. Embarrassingly, ‘fault’ is implemented as:</p>
<pre class="code"><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">fault f = f
</span></pre>
<p>So it is just a tag. Things get trickier when the function has contingencies. We want to find a way to manage them without introducing undue complexity in the code.</p>
<p>We’d like to catch some exceptions thrown by the function and convert them to return values and then either return such return values or manage the contingency immediately after the function call. On top of that, we’d want all of the code written after the function call to appear as clean as if no error management were taking place. Monads (computation values) can be used to achieve these goals.</p>
<p>Last time we introduced a type to represent error return values:</p>
<pre class="code"><span style="background:white;color:blue;">type </span><span style="background:white;color:black;">Result&lt;'a, 'b&gt; =
| Success </span><span style="background:white;color:blue;">of </span><span style="background:white;color:black;">'a
| Failure </span><span style="background:white;color:blue;">of </span><span style="background:white;color:black;">'b
</span></pre>
<pre class="code"><span style="background:white;color:blue;">type </span><span style="background:white;color:black;">UserFetchError =
| UserNotFound  </span><span style="background:white;color:blue;">of </span><span style="background:white;color:black;">exn
| NotAuthorized </span><span style="background:white;color:blue;">of </span><span style="background:white;color:black;">int * exn </span></pre>
<p>We can then create a computation expression that ‘abstracts out’ the Failure case and let you write the code as cleanly as if you were not handling errors. Let’s call such thing ‘critical’. Here is how the final code looks like:</p>
<pre class="code"><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">tryFetchUser3 userName =
    </span><span style="background:white;color:blue;">if </span><span style="background:white;color:black;">String.IsNullOrEmpty userName </span><span style="background:white;color:blue;">then </span><span style="background:white;color:black;">invalidArg </span><span style="background:white;color:#a31515;">"userName" "userName cannot be null/empty"
    </span><span style="background:white;color:blue;">critical </span><span style="background:white;color:black;">{
        </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">Unauthorized (ex:exn) = NotAuthorized (ex.Message.Length, ex)</span><span style="background:white;color:green;">
        </span><span style="background:white;color:blue;">let! </span><span style="background:white;color:black;">userText = contingent1
                            [FileNotFoundException()        :&gt; exn, UserNotFound;
                             UnauthorizedAccessException()  :&gt; exn, Unauthorized]
                            dbQuery (userName + </span><span style="background:white;color:#a31515;">".user"</span><span style="background:white;color:black;">)
        </span><span style="background:white;color:blue;">return </span><span style="background:white;color:black;">fault parseUser userText
    }</span></pre>
<p>You can compare this with the code you would have to write without the ‘critical’ library (from last post):</p>
<pre class="code"><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">tryFetchUser1 userName =
    </span><span style="background:white;color:blue;">if </span><span style="background:white;color:black;">String.IsNullOrEmpty userName </span><span style="background:white;color:blue;">then </span><span style="background:white;color:black;">invalidArg </span><span style="background:white;color:#a31515;">"userName" "userName cannot be null/empty"
    </span><span style="background:white;color:green;">// Could check for file existence in this case, but often not (i.e. db)
    </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">userResult =    </span><span style="background:white;color:blue;">try
                            </span><span style="background:white;color:black;">Success(dbQuery(userName + </span><span style="background:white;color:#a31515;">".user"</span><span style="background:white;color:black;">))
                        </span><span style="background:white;color:blue;">with
                        </span><span style="background:white;color:black;">| FileNotFoundException </span><span style="background:white;color:blue;">as </span><span style="background:white;color:black;">ex        </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">Failure(UserNotFound ex)
                        | UnauthorizedAccessException </span><span style="background:white;color:blue;">as </span><span style="background:white;color:black;">ex  </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">Failure(NotAuthorized(2, ex))
                        | ex                                    </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">reraise ()
    </span><span style="background:white;color:blue;">match </span><span style="background:white;color:black;">userResult </span><span style="background:white;color:blue;">with
    </span><span style="background:white;color:black;">| Success(userText) </span><span style="background:white;color:blue;">-&gt;
        let </span><span style="background:white;color:black;">user        = Success(parseUser(userText))
        user
    | Failure(ex)       </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">Failure(ex)
</span></pre>
<p>And with the original (not critical) function:</p>
<pre class="code"><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">fetchUser userName =
    </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">userText            = dbQuery (userName + </span><span style="background:white;color:#a31515;">".user"</span><span style="background:white;color:black;">)
    </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">user                = parseUser(userText)
    user
</span></pre>
<p><span style="background:white;color:black;"></span></p>
<p>Let’s go step by step and see how it works. First of all, you need to enclose the Critical parts of your code (perhaps your whole program) in a ‘critical’ computation:</p>
<pre class="code"><span style="background:white;color:black;">    </span><span style="background:white;color:blue;">critical </span><span style="background:white;color:black;">{<br />       …
</span><span style="background:white;color:black;">    }
</span></pre>
<p>This allows you to call functions that return a Result and manage the return result as if it were the successful result. If an error were generated, it would be returned instead. We will show how to manage contingencies immediately after the function call later.</p>
<p>The above is illustrated by the following:</p>
<pre class="code"><span style="background:white;color:black;">        </span><span style="background:white;color:blue;">let! </span><span style="background:white;color:black;">userText = contingent1
                            [FileNotFoundException()        :&gt; exn, UserNotFound;
                             UnauthorizedAccessException()  :&gt; exn, Unauthorized]
                            dbQuery (userName + </span><span style="background:white;color:#a31515;">".user"</span><span style="background:white;color:black;">)</span></pre>
<p>Here ‘contingent1’ is a function that returns a Result, but userText has type string. The Critical monad, and in particular the usage of ‘let!’ is what allows the magic to happen.</p>
<p>‘contingentN’ is a function that you call when you want to manage certain exceptions thrown by a function as contingencies. The N part represents how many parameters the function takes.</p>
<p>The first parameter to ‘contingent1’ is a list of pairs (Exception, ErrorReturnConstructor). That means: when an exception of type Exception is thrown, return the result of calling ‘ErrorReturnConstructor(Exception)’ wrapped inside a ‘Failure’ object. The second parameter to ‘contingent1’ is the function to invoke and the third is the argument to pass to it.</p>
<p>Conceptually, ‘ContingentN’ is a tag that says: if the function throws one of these exceptions, wrap them in these return values and propagate all the other exceptions. Notice that Unauthorized takes an integer and an exception as parameters while the ErrorReturnConstructor takes just an exception. So we need to add this line of code:</p>
<pre class="code"><span style="background:white;color:black;">        </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">Unauthorized (ex:exn) = NotAuthorized (ex.Message.Length, ex) </span></pre>
<p>After the contingent1 call, we can then write code as if the function returned a normal string:</p>
<pre class="code"><span style="background:white;color:black;">        </span><span style="background:white;color:blue;">return </span><span style="background:white;color:black;">fault parseUser userText
</span></pre>
<p>This achieves that we set up to do at the start of the series:</p>
<ul>
<li>Contingencies are now explicit in the signature of tryFetchUser3</li>
<li>The developer needs to indicate for each function call how he intend to manage contingencies and faults</li>
<li>The code is only slightly more complex than the non-critical one</li>
</ul>
<p>You can also decide to manage your contingencies immediately after calling a function. Perhaps there is a way to recover from the problem. For example, if the user is not in the database, you might want to add a standard one:</p>
<pre class="code"><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">createAndReturnUser userName = </span><span style="background:white;color:blue;">critical </span><span style="background:white;color:black;">{ </span><span style="background:white;color:blue;">return </span><span style="background:white;color:black;">{Name = userName; Age = 43}}<br />
</span>&lt;/font>let &lt;/span><span style="background:white;color:black;">tryFetchUser4 userName =
    </span><span style="background:white;color:blue;">if </span><span style="background:white;color:black;">String.IsNullOrEmpty userName </span><span style="background:white;color:blue;">then </span><span style="background:white;color:black;">invalidArg </span><span style="background:white;color:#a31515;">"userName" "userName cannot be null/empty"
    </span><span style="background:white;color:blue;">critical </span><span style="background:white;color:black;">{
        </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">Unauthorized (ex:exn) = NotAuthorized (ex.Message.Length, ex) </span><span style="background:white;color:green;">// depends on ex
        </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">userFound = contingent1
                            [FileNotFoundException()        :&gt; exn, UserNotFound;
                             UnauthorizedAccessException()  :&gt; exn, Unauthorized]
                            dbQuery (userName + </span><span style="background:white;color:#a31515;">".user"</span><span style="background:white;color:black;">)
        </span><span style="background:white;color:blue;">match </span><span style="background:white;color:black;">userFound </span><span style="background:white;color:blue;">with
        </span><span style="background:white;color:black;">| Success(userText)         </span><span style="background:white;color:blue;">-&gt; return  </span><span style="background:white;color:black;">fault parseUser userText
        | Failure(UserNotFound(_))  </span><span style="background:white;color:blue;">-&gt; return! </span><span style="background:white;color:black;">createAndReturnUser(userName)
        | Failure(x)                </span><span style="background:white;color:blue;">-&gt; return! </span><span style="background:white;color:black;">Failure(x)
    }</span></pre>
<p>
  The only difference in this case is the usage of ‘let’ instead of ‘let!’. This exposes the real return type of the function allowing you to pattern match against it.
</p>
<p>
  Sometimes a simple exception to return value mapping might not be enough and you want more control on which exceptions to catch and how to convert them to return values. In such cases you can use contingentGen:
</p>
<pre class="code"><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">tryFetchUser2 userName =
    </span><span style="background:white;color:blue;">if </span><span style="background:white;color:black;">String.IsNullOrEmpty userName </span><span style="background:white;color:blue;">then </span><span style="background:white;color:black;">invalidArg </span><span style="background:white;color:#a31515;">"userName" "userName cannot be null/empty"
    </span><span style="background:white;color:blue;">critical </span><span style="background:white;color:black;">{
        </span><span style="background:white;color:blue;">let! </span><span style="background:white;color:black;">userText = contingentGen
                            (</span><span style="background:white;color:blue;">fun </span><span style="background:white;color:black;">ex </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">ex FileNotFoundException || ex UnauthorizedAccessException)
                            (</span><span style="background:white;color:blue;">fun </span><span style="background:white;color:black;">ex </span><span style="background:white;color:blue;">-&gt;
                                match </span><span style="background:white;color:black;">ex </span><span style="background:white;color:blue;">with
                                       </span><span style="background:white;color:black;">| FileNotFoundException       </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">UserNotFound(ex)
                                       | UnauthorizedAccessException </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">NotAuthorized(3, ex)
                                       | _ </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">raise ex)
                            (</span><span style="background:white;color:blue;">fun </span><span style="background:white;color:black;">_ </span><span style="background:white;color:blue;">-&gt; </span><span style="background:white;color:black;">dbQuery (userName + </span><span style="background:white;color:#a31515;">".user"</span><span style="background:white;color:black;">))
        </span><span style="background:white;color:blue;">return </span><span style="background:white;color:black;">fault parseUser userText
    }
</span></pre>
<p>
  The first parameter is a lambda describing when to catch an exception. The second lambda translate between exceptions and return values. The third lambda represents which function to call.
</p>
<p>
  Sometimes you might want to catch all the exceptions that a function might throw and convert them to a single return value:
</p>
<pre class="code"><span style="background:white;color:blue;">type </span><span style="background:white;color:black;">GenericError = GenericError </span><span style="background:white;color:blue;">of </span><span style="background:white;color:black;">exn
 </span><span style="background:white;color:green;">// 1. Wrapper that prevents exceptions for escaping the method by wrapping them in a generic critical result
</span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">tryFetchUserNoThrow userName =
    </span><span style="background:white;color:blue;">if </span><span style="background:white;color:black;">String.IsNullOrEmpty userName </span><span style="background:white;color:blue;">then </span><span style="background:white;color:black;">invalidArg </span><span style="background:white;color:#a31515;">"userName" "userName cannot be null/empty"
    </span><span style="background:white;color:blue;">critical </span><span style="background:white;color:black;">{
        </span><span style="background:white;color:blue;">let! </span><span style="background:white;color:black;">userText = neverThrow1 GenericError dbQuery (userName + </span><span style="background:white;color:#a31515;">".user"</span><span style="background:white;color:black;">)
        </span><span style="background:white;color:blue;">return </span><span style="background:white;color:black;">fault parseUser userText
    }</span></pre>
<p>
  And sometimes you might want to go the opposite way. Given a function that exposes some contingencies, you want to translate them to faults because you don’t know how to recover from them.
</p>
<pre class="code"><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">operateOnExistingUser userName =
    </span><span style="background:white;color:blue;">let </span><span style="background:white;color:black;">user = alwaysThrow GenericException tryFetchUserNoThrow userName
    ()</span></pre>
<p>
  Next time we’ll look at how the Critical computation expression is implemented.
</p>


  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¶</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¶</h2>
    </header>
    


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>