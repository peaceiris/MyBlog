<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="I always forget the pattern to use to create a functioning MailboxProcessor in F#. I mean, which piece has to be async and how to structure the recursive loop. When I find myself in that kind of a situation situation, my instincts scream at me: “Wrap it and make it work how your mind expects it to work”. So here is a simplification of the paradigm.
Let’s see how some standard MailboxProcessor code looks like:">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>A simpler F# MailboxProcessor | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">❧</a>
            
                <time id="blog_date" > 2010/02/02</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        A simpler F# MailboxProcessor
    
    </h1>

    </header>

    <main>
        

<p>I always forget the pattern to use to create a functioning <em>MailboxProcessor</em> in F#. I mean, which piece has to be async and how to structure the recursive loop. When I find myself in that kind of a situation situation, my instincts scream at me: “Wrap it and make it work how your mind expects it to work”. So here is a simplification of the paradigm.</p>
<p>Let’s see how some standard <em>MailboxProcessor</em> code looks like:</p>
<pre class="code"><span style="color:blue;">let </span>counter0 =
    MailboxProcessor.Start(<span style="color:blue;">fun </span>inbox <span style="color:blue;">-&gt;
        let rec </span>loop n =
            async {
                    <span style="color:blue;">let! </span>msg = inbox.Receive()
                    <span style="color:blue;">return! </span>loop(n+msg) }
        loop 0)</pre>
<p>This keeps a running sum of the messages it receives. The only part that is really unique to this guy is “n + msg”. All the rest is infrastructure.</p>
<p>You’d probably prefer to write code like the following:</p>
<pre class="code"><span style="color:blue;">let </span>counter1 = MailboxProcessor.SpawnAgent( (<span style="color:blue;">fun </span>msg n <span style="color:blue;">-&gt; </span>msg + n), 0)</pre>
<p>Yep, just one line of code. But, is it possible? Let’s look at one way of doing it:</p>
<pre class="code"><span style="color:blue;">type </span>AfterError&lt;'state&gt; =
| ContinueProcessing <span style="color:blue;">of </span>'state
| StopProcessing
| RestartProcessing
<span style="color:blue;">type </span>MailboxProcessor&lt;'a&gt; <span style="color:blue;">with
    static member public </span>SpawnAgent&lt;'b&gt;(messageHandler :'a<span style="color:blue;">-&gt;</span>'b<span style="color:blue;">-&gt;</span>'b,<br />                                        initialState : 'b, ?timeout:'b <span style="color:blue;">-&gt; </span>int,
                                        ?timeoutHandler:'b <span style="color:blue;">-&gt; </span>AfterError&lt;'b&gt;,<br />                                        ?errorHandler:<br />                                            Exception <span style="color:blue;">-&gt; </span>'a option <span style="color:blue;">-&gt; </span>'b <span style="color:blue;">-&gt; </span>AfterError&lt;'b&gt;)<br />                                        : MailboxProcessor&lt;'a&gt; =
        <span style="color:blue;">let </span>timeout = defaultArg timeout (<span style="color:blue;">fun </span>_ <span style="color:blue;">-&gt; </span>-1)
        <span style="color:blue;">let </span>timeoutHandler = defaultArg timeoutHandler (<span style="color:blue;">fun </span>state –<span style="color:blue;">&gt;<br />                                                                  </span>ContinueProcessing(state))
        <span style="color:blue;">let </span>errorHandler = defaultArg errorHandler (<span style="color:blue;">fun </span>_ _ state –<span style="color:blue;">&gt;<br />                                                                  </span>ContinueProcessing(state))
        MailboxProcessor.Start(<span style="color:blue;">fun </span>inbox <span style="color:blue;">-&gt;
            let rec </span>loop(state) = async {
                <span style="color:blue;">let! </span>msg = inbox.TryReceive(timeout(state))
                <span style="color:blue;">try
                    match </span>msg <span style="color:blue;">with
                    </span>| None      <span style="color:blue;">-&gt; match </span>timeoutHandler state <span style="color:blue;">with
                                    </span>| ContinueProcessing(newState)    <span style="color:blue;">-&gt;<br />                                                                   return! </span>loop(newState)
                                    | StopProcessing        <span style="color:blue;">-&gt; return </span>()
                                    | RestartProcessing     <span style="color:blue;">-&gt; return! </span>loop(initialState)
                    | Some(m)   <span style="color:blue;">-&gt; return! </span>loop(messageHandler m state)
                <span style="color:blue;">with
                </span>| ex <span style="color:blue;">-&gt; match </span>errorHandler ex msg state <span style="color:blue;">with
                        </span>| ContinueProcessing(newState)    <span style="color:blue;">-&gt; return! </span>loop(newState)
                        | StopProcessing        <span style="color:blue;">-&gt; return </span>()
                        | RestartProcessing     <span style="color:blue;">-&gt; return! </span>loop(initialState)
                }
            loop(initialState))</pre>
<p>The funny formatting is because I have to fit it in the small horizontal space of this blog. In any case, this is just a simple (?) wrapper for the <em>MailboxProcessor</em> pattern. The function takes two necessary parameters and two optional ones:</p>
<ul>
<li><strong>messageHandler</strong>: a function to execute when a message comes in, it takes the message and the current state as parameters and returns the new state.</li>
<li><strong>initialState</strong>: the initial state for the <em>MailboxProcessor</em></li>
<li><strong>timeoutHandler</strong>: a function that is executed whenever a timeout occurs. It takes as a parameter the current state and returns one of <em>ContinueProcessing(newState), StopProcessing or RestartProcessing</em></li>
<li><strong>errorHandler</strong>: a function that gets call if an exception is generated inside the <em>messageHandler</em> function. It takes the exception, the message, the current state and returns <em>ContinueProcessing(newState), StopProcessing or RestartProcessing</em></li>
</ul>
<p>An example of how to use <em>errorHandler</em> to implement the CountingAgent in the Expert F# book follows:</p>
<pre class="code"><span style="color:blue;">type </span>msg = Increment <span style="color:blue;">of </span>int | Fetch <span style="color:blue;">of </span>AsyncReplyChannel&lt;int&gt; | Stop
<span style="color:blue;">exception </span>StopException
<span style="color:blue;">type </span>CountingAgent() =
    <span style="color:blue;">let </span>counter = MailboxProcessor.SpawnAgent((<span style="color:blue;">fun </span>msg n <span style="color:blue;">-&gt;
                    match </span>msg <span style="color:blue;">with
                    </span>| Increment m <span style="color:blue;">-&gt;  </span>n + m
                    | Stop <span style="color:blue;">-&gt; </span>raise(StopException)
                    | Fetch replyChannel <span style="color:blue;">-&gt;
                        do </span>replyChannel.Reply(n)
                        n
                  ), 0, errorHandler = (<span style="color:blue;">fun </span>_ _ _ <span style="color:blue;">-&gt; </span>StopProcessing))
    <span style="color:blue;">member </span>a.Increment(n) = counter.Post(Increment(n))
    <span style="color:blue;">member </span>a.Stop() = counter.Post(Stop)
    <span style="color:blue;">member </span>a.Fetch() = counter.PostAndReply(<span style="color:blue;">fun </span>replyChannel <span style="color:blue;">-&gt; </span>Fetch(replyChannel))
<span style="color:blue;">let </span>counter2 = CountingAgent()
counter2.Increment(1)
counter2.Fetch()
counter2.Increment(2)
counter2.Fetch()
counter2.Stop()                             </pre>
<p>Sometimes your agent doesn’t need a state, it is purely stateless. Something as simple as the following:</p>
<pre class="code"><span style="color:blue;">let </span>echo = MailboxProcessor&lt;_&gt;.SpawnWorker(<span style="color:blue;">fun </span>msg <span style="color:blue;">-&gt; </span>printfn <span style="color:maroon;">"%s" </span>msg)</pre>
<p>You can easily make that happen by using this toned down version of an agent, called worker:</p>
<pre class="code"><span style="color:blue;">static member public </span>SpawnWorker(messageHandler,  ?timeout, ?timeoutHandler,?errorHandler) =
    <span style="color:blue;">let </span>timeout = defaultArg timeout (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt; </span>-1)
    <span style="color:blue;">let </span>timeoutHandler = defaultArg timeoutHandler (<span style="color:blue;">fun </span>_ <span style="color:blue;">-&gt; </span>ContinueProcessing(()))
    <span style="color:blue;">let </span>errorHandler = defaultArg errorHandler (<span style="color:blue;">fun </span>_ _ <span style="color:blue;">-&gt; </span>ContinueProcessing(()))
    MailboxProcessor.SpawnAgent((<span style="color:blue;">fun </span>msg _ <span style="color:blue;">-&gt; </span>messageHandler msg; ()),<br />                                 (), timeout, timeoutHandler,<br />                                 (<span style="color:blue;">fun </span>ex msg _ <span style="color:blue;">-&gt; </span>errorHandler ex msg))</pre></p> 
<p>Given that they are parallel, you might want to run a whole bunch of them at the same time. You might want something that looks like a worker, but that, under the cover, execute each <em>messageHandler</em> in parallel. Something like:</p>
<pre class="code"><span style="color:blue;">type </span>msg1 = Message1 | Message2 <span style="color:blue;">of </span>int | Message3 <span style="color:blue;">of </span>string
<span style="color:blue;">let </span>a = MailboxProcessor.SpawnParallelWorker(<span style="color:blue;">function
                </span>| Message1 <span style="color:blue;">-&gt; </span>printfn <span style="color:maroon;">"Message1"</span>;
                | Message2 n <span style="color:blue;">-&gt; </span>printfn <span style="color:maroon;">"Message2 %i" </span>n;
                | Message3 _ <span style="color:blue;">-&gt; </span>failwith <span style="color:maroon;">"I failed"
                </span>, 10
                , errorHandler = (<span style="color:blue;">fun </span>ex _ <span style="color:blue;">-&gt; </span>printfn <span style="color:maroon;">"%A" </span>ex; ContinueProcessing()))
a.Post(Message1)
a.Post(Message2(100))
a.Post(Message3(<span style="color:maroon;">"abc"</span>))
a.Post(Message2(100))</pre></p> 
<p>In this example, the different messages, are likely to cause things to print out of order. Notice the number 10 above which is how many workers you want to process your messages. This is implemented by round-robin messages to the various workers:</p>
<pre class="code"><span style="color:blue;">static member public </span>SpawnParallelWorker(messageHandler, howMany, ?timeout,<br />                                                        ?timeoutHandler,?errorHandler) =
    <span style="color:blue;">let </span>timeout = defaultArg timeout (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt; </span>-1)
    <span style="color:blue;">let </span>timeoutHandler = defaultArg timeoutHandler (<span style="color:blue;">fun </span>_ <span style="color:blue;">-&gt; </span>ContinueProcessing(()))
    <span style="color:blue;">let </span>errorHandler = defaultArg errorHandler (<span style="color:blue;">fun </span>_ _ <span style="color:blue;">-&gt; </span>ContinueProcessing(()))
    MailboxProcessor&lt;'a&gt;.SpawnAgent((<span style="color:blue;">fun </span>msg (workers:MailboxProcessor&lt;'a&gt; array, index) <span style="color:blue;">-&gt;
                                        </span>workers.[index].Post msg
                                        (workers, (index + 1) % howMany))
                                    , (Array.init howMany<br />                                      (<span style="color:blue;">fun </span>_ <span style="color:blue;">-&gt; </span>MailboxProcessor&lt;'a&gt;.SpawnWorker(<br />                                                 messageHandler, timeout, timeoutHandler,<br />                                                 errorHandler)), 0))</pre>
<p>One drawback with the current code is that it doesn’t supports cancellations. It should be possible to wrap that too, but I haven’t done it (yet). If you don’t want to cut and paste the code, it is inside the AgentSystem.fs file <a href="http://blogs.msdn.com/lucabol/archive/2009/06/12/lagent-an-agent-framework-in-f-part-iii-default-error-management.aspx">here</a>.</p>



  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¶</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¶</h2>
    </header>
    


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>