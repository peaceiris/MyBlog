<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="Main ideas This is a port of LLIte in C. The reason for it is to experiment with writing functional code in standard C and compare the experience with using a functional language like F#. It is in a way a continuation of my previous posts on the topic.
I will be using glib and an header of convenient macros/functions to help me (lutils.h). I don’t think that is cheating. Any modern C praticoner has its bag of tricks …">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>Funky C for literate programming | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">❧</a>
            
                <time id="blog_date" > 2013/03/03</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        Funky C for literate programming
    
    </h1>

    </header>

    <main>
        

<h2 id="main-ideas">Main ideas</h2>
<p>This is a port of <a href="https://github.com/lucabol/LLite/blob/master/Program.fs">LLIte</a> in C. The reason for it is to experiment with writing functional code in standard C and compare the experience with using a functional language like F#. It is in a way a continuation of my previous posts on the topic.</p>
<p>I will be using glib and an header of convenient macros/functions to help me (lutils.h). I don’t think that is cheating. Any modern C praticoner has its bag of tricks …</p>
<p>Don’t tell me this is not idiomatic C. I already know that.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">include</span> <span style="color:#999;font-weight:bold">&lt;string.h&gt;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">include</span> <span style="color:#999;font-weight:bold">&lt;stdbool.h&gt;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">include</span> <span style="color:#999;font-weight:bold">&lt;glib.h&gt;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">include</span> <span style="color:#999;font-weight:bold">&lt;glib/gprintf.h&gt;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">ifdef ARENA</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">include</span> <span style="color:#999;font-weight:bold">&#34;arena.h&#34;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">endif</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">include</span> <span style="color:#999;font-weight:bold">&#34;lutils.h&#34;</span><span style="color:#999;font-weight:bold">
</span></code></pre></div><h2 id="lack-of-tuples">Lack of tuples</h2>
<p>In the snippet below I overcomed such deficiency by declaring a struct. Using the new constructor syntax makes initializing a static table simple.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="font-weight:bold">typedef</span> <span style="font-weight:bold">struct</span> LangSymbols { <span style="color:#458;font-weight:bold">char</span> language[<span style="color:#099">40</span>]; <span style="color:#458;font-weight:bold">char</span> start[<span style="color:#099">10</span>]; <span style="color:#458;font-weight:bold">char</span> end[<span style="color:#099">10</span>];} LangSymbols;

<span style="font-weight:bold">static</span>
LangSymbols<span style="font-weight:bold">*</span> s_lang_params_table[] <span style="font-weight:bold">=</span> {
    <span style="font-weight:bold">&amp;</span>(LangSymbols) {.language <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">fsharp</span><span style="color:#b84">&#34;</span>,   .start <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">(*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span>, .end <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*)</span><span style="color:#b84">&#34;</span>},
    <span style="font-weight:bold">&amp;</span>(LangSymbols) {.language <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">c</span><span style="color:#b84">&#34;</span>,        .start <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">/*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span>, .end <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*/</span><span style="color:#b84">&#34;</span>},
    <span style="font-weight:bold">&amp;</span>(LangSymbols) {.language <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">csharp</span><span style="color:#b84">&#34;</span>,   .start <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">/*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span>, .end <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*/</span><span style="color:#b84">&#34;</span>},
    <span style="font-weight:bold">&amp;</span>(LangSymbols) {.language <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">java</span><span style="color:#b84">&#34;</span>,     .start <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">/*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span>, .end <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*</span><span style="color:#b84">&#34;</span> <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">*/</span><span style="color:#b84">&#34;</span>},
    <span style="color:#999">NULL</span>
};
</code></pre></div><h2 id="folding-over-arrays">Folding over arrays</h2>
<p>I need to gather all the languages, aka perform a fold over the array. You might have noticed the propensity to add a NULL terminator marker to arrays (as for strings). This allows me to avoid passing a size to functions and makes simpler writing utility macros (as foreach below) more simply.</p>
<p>In the rest of the program, every time I end a function with _z, it is because I consider it generally usable and I add a version of it without the _z to lutils.h.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">define array_foreach_z(p) for(; *symbols != NULL; ++symbols)</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
<span style="font-weight:bold">static</span>
<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">summary</span>(LangSymbols<span style="font-weight:bold">*</span><span style="font-weight:bold">*</span> symbols) {

    GString<span style="font-weight:bold">*</span> langs <span style="font-weight:bold">=</span> g_string_sized_new(<span style="color:#099">20</span>);
    array_foreach(symbols) g_string_append_printf(langs, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">%s </span><span style="color:#b84">&#34;</span>, (<span style="font-weight:bold">*</span>symbols)<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>language);

    g_string_truncate(langs, strlen(langs<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str) <span style="font-weight:bold">-</span> <span style="color:#099">1</span>);

    GString<span style="font-weight:bold">*</span> usage <span style="font-weight:bold">=</span> g_string_sized_new(<span style="color:#099">100</span>);

    g_string_printf(usage,
        <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">You should specify:nt. either -l or -o and -pn</span><span style="color:#b84">&#34;</span>
        <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">t. either -indent or -P and -Cn</span><span style="color:#b84">&#34;</span>
        <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">t. -l supports: %s</span><span style="color:#b84">&#34;</span>
        ,langs<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str);

    <span style="font-weight:bold">return</span> usage<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str;
}
</code></pre></div><p>Find an item in an array based on some expression. Returns NULL if not found. Again, this is a common task, hence I’ll abstract it out with a macro (that ends up being a cute use of gcc statment expressions).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">define array_find_z(arr, ...)                          </span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>    ({                                                  
        array_foreach(arr) <span style="font-weight:bold">if</span> (__VA_ARGS__) <span style="font-weight:bold">break</span>;      
        <span style="font-weight:bold">*</span>arr;                                           
    })

<span style="font-weight:bold">static</span>
LangSymbols<span style="font-weight:bold">*</span> lang_find_symbols(LangSymbols<span style="font-weight:bold">*</span><span style="font-weight:bold">*</span> symbols, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> lang) {
    g_assert(symbols);
    g_assert(lang);

    <span style="font-weight:bold">return</span> <span style="color:#900;font-weight:bold">array_find</span>(symbols, <span style="font-weight:bold">!</span>strcmp((<span style="font-weight:bold">*</span>symbols)<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>language, lang));
}
</code></pre></div><h2 id="deallocating-stuff">Deallocating stuff</h2>
<p>You might wonder why I don’t seem overly worried about deallocating the memory that I allocate. I haven’t gone crazy(yet). You’ll see.</p>
<h2 id="discriminated-unions">Discriminated unions</h2>
<p>Here are the discriminated unions macros from a previous blog post of mine. I’ll need a couple of these and pre-declare two functions.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">union_decl(CodeSymbols, Indented, Surrounded)
    union_type(Indented,    <span style="color:#458;font-weight:bold">int</span> indentation;)
    union_type(Surrounded,  <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> start_code; <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> end_code;)
union_end(CodeSymbols);

<span style="font-weight:bold">typedef</span> <span style="font-weight:bold">struct</span> Options {
    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>           start_narrative;
    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>           end_narrative;
    CodeSymbols<span style="font-weight:bold">*</span>    code_symbols;
} Options;

<span style="font-weight:bold">static</span>
gchar<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">translate</span>(Options<span style="font-weight:bold">*</span>, gchar<span style="font-weight:bold">*</span>);

union_decl(Block, Code, Narrative)
    union_type(Code,        <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> code)
    union_type(Narrative,   <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> narrative)
union_end(Block);
</code></pre></div><h2 id="main-data-structure">Main data structure</h2>
<p>We want to use higher level abstractions that standard C arrays, hence we’ll pick a convenient data structure to use in the rest of the code. A queue lets you to insert at the front and back, with just a one pointer overhead over a single linked list. Hence it is my data structure of choice for this program.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">blockize</span>(Options<span style="font-weight:bold">*</span>, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>);
There is already a function in glib to check <span style="font-weight:bold">if</span> a string has a certain <span style="color:#900;font-weight:bold">prefix</span> (g_str_has_prefix). We need one that returns the remaining string after the prefix. We also define a g_slow_assert that is executed just <span style="font-weight:bold">if</span> G_ENABLE_SLOW_ASSERT is defined

<span style="font-weight:bold">static</span>
<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> str_after_prefix(<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> src, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> prefix) {
    g_assert(src);
    g_assert(prefix);
    g_slow_assert(g_str_has_prefix(src, prefix));

    <span style="font-weight:bold">while</span>(<span style="font-weight:bold">*</span>prefix <span style="font-weight:bold">!</span><span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">0</span><span style="color:#b84">&#39;</span>)
        <span style="font-weight:bold">if</span>(<span style="font-weight:bold">*</span>src <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> <span style="font-weight:bold">*</span>prefix) <span style="font-weight:bold">+</span><span style="font-weight:bold">+</span>src, <span style="font-weight:bold">+</span><span style="font-weight:bold">+</span>prefix;
        <span style="font-weight:bold">else</span> <span style="font-weight:bold">break</span>;

    <span style="font-weight:bold">return</span> src;
}
</code></pre></div><h2 id="tokenizer">Tokenizer</h2>
<p>The structure of the function is identical to the F# version. The big bread-winners are statement expressions and local functions …</p>
<p>It is interesting how you can replicate the shape of an F# function by substituting ternary operators for match statements.</p>
<p>It is nothing magic, just a way to have a case statment as an expression, but it is suggestive of its more functional counterpart.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">define NL &#34;n&#34;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
union_decl(Token, OpenComment, CloseComment, Text)
    union_type(OpenComment, <span style="color:#458;font-weight:bold">int</span> line)
    union_type(CloseComment,<span style="color:#458;font-weight:bold">int</span> line)
    union_type(Text,        <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> text)
union_end(Token);

GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">tokenize</span>(Options<span style="font-weight:bold">*</span> options, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> source) {
    g_assert(options);
    g_assert(source);

    <span style="font-weight:bold">struct</span> tuple { <span style="color:#458;font-weight:bold">int</span> line; GString<span style="font-weight:bold">*</span> acc; <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> rem;};

    <span style="color:#458;font-weight:bold">bool</span> is_opening(<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> src)      { <span style="font-weight:bold">return</span> g_str_has_prefix(src, options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>start_narrative);}
    <span style="color:#458;font-weight:bold">bool</span> is_closing(<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> src)      { <span style="font-weight:bold">return</span> g_str_has_prefix(src, options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>end_narrative);}
    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> remaining_open (<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> src){ <span style="font-weight:bold">return</span> str_after_prefix(src, options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>start_narrative);}
    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> remaining_close(<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> src){ <span style="font-weight:bold">return</span> str_after_prefix(src, options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>end_narrative);}

    <span style="font-weight:bold">struct</span> tuple text(<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> src, GString<span style="font-weight:bold">*</span> acc, <span style="color:#458;font-weight:bold">int</span> line) {
        <span style="font-weight:bold">inline</span> <span style="font-weight:bold">struct</span> tuple stop_parse_text()
            { <span style="font-weight:bold">return</span> (<span style="font-weight:bold">struct</span> tuple) {.line <span style="font-weight:bold">=</span> line, .acc <span style="font-weight:bold">=</span> acc, .rem <span style="font-weight:bold">=</span> src};}

        <span style="font-weight:bold">return</span>  str_empty (src)<span style="font-weight:bold">?</span> stop_parse_text() <span style="font-weight:bold">:</span>
                is_opening(src)<span style="font-weight:bold">?</span> stop_parse_text() <span style="font-weight:bold">:</span>
                is_closing(src)<span style="font-weight:bold">?</span> stop_parse_text() <span style="font-weight:bold">:</span>
                                ({
                                  <span style="color:#458;font-weight:bold">int</span> line2         <span style="font-weight:bold">=</span> g_str_has_prefix(src, NL) <span style="font-weight:bold">?</span> line <span style="font-weight:bold">+</span> <span style="color:#099">1</span>
                                                                                <span style="font-weight:bold">:</span> line;
                                  GString<span style="font-weight:bold">*</span> newAcc   <span style="font-weight:bold">=</span> g_string_append_c(acc, <span style="font-weight:bold">*</span>src);
                                  <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> rem         <span style="font-weight:bold">=</span> src <span style="font-weight:bold">+</span> <span style="color:#099">1</span>;
                                  text(rem, newAcc, line2);
                                });
    }

    GQueue<span style="font-weight:bold">*</span> tokenize_rec(<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> src, GQueue<span style="font-weight:bold">*</span> acc, <span style="color:#458;font-weight:bold">int</span> line) {
        <span style="font-weight:bold">return</span>  str_empty(src)  <span style="font-weight:bold">?</span>   acc                     :
                is_opening(src) <span style="font-weight:bold">?</span>   tokenize_rec(remaining_open(src),
                                        g_queue_push_back(acc, union_new(
                                                    Token, OpenComment, .line <span style="font-weight:bold">=</span> line)),
                                        line)        <span style="font-weight:bold">:</span>
                is_closing(src) <span style="font-weight:bold">?</span>   tokenize_rec(remaining_close(src),
                                               g_queue_push_back(acc, union_new(
                                                    Token, CloseComment, .line <span style="font-weight:bold">=</span> line)),
                                        line)        <span style="font-weight:bold">:</span>
                                ({
                                    <span style="font-weight:bold">struct</span> tuple t <span style="font-weight:bold">=</span> text(src, g_string_sized_new(<span style="color:#099">200</span>), line);
                                    tokenize_rec(t.rem,
                                        g_queue_push_back(acc, union_new(
                                                    Token, Text, .text <span style="font-weight:bold">=</span> t.acc<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str)), t.line);
                                 });
    }

    <span style="font-weight:bold">return</span> tokenize_rec(source, g_queue_new(), <span style="color:#099">1</span>);
}
</code></pre></div><h2 id="parser">Parser</h2>
<p>This again has a similar structure to the F# version, just longer. It is very long because it contains 3 (nested) functions which are on the verbose side in C.</p>
<p>The creation of a error macro is unfortunate. I just don’t know how to adapt g_assert_e so that it works for not pointer returning functions.</p>
<p>I also need a simple function report_error to exit gracefully giving a message to the user. I didn’t found such thing in glib (?)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">define report_error_z(...) G_STMT_START { g_print(__VA_ARGS__); exit(1); } G_STMT_END                                                            </span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
union_decl(Chunk, NarrativeChunk, CodeChunk)
    union_type(NarrativeChunk,  GQueue<span style="font-weight:bold">*</span> tokens)
    union_type(CodeChunk,       GQueue<span style="font-weight:bold">*</span> tokens)
union_end(Chunk);

<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">parse</span>(Options<span style="font-weight:bold">*</span> options, GQueue<span style="font-weight:bold">*</span> tokens) {
    g_assert(options);
    g_assert(tokens);

    <span style="font-weight:bold">struct</span> tuple { GQueue<span style="font-weight:bold">*</span> acc; GQueue<span style="font-weight:bold">*</span> rem;};

    <span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">define error(...) </span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>        ({ report_error(__VA_ARGS__); (<span style="font-weight:bold">struct</span> tuple) {.acc <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>, .rem <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>}; })

    <span style="font-weight:bold">struct</span> tuple parse_narrative(GQueue<span style="font-weight:bold">*</span> acc, GQueue<span style="font-weight:bold">*</span> rem) {

        <span style="color:#458;font-weight:bold">bool</span> isEmpty    <span style="font-weight:bold">=</span> g_queue_is_empty(rem);
        Token<span style="font-weight:bold">*</span> h        <span style="font-weight:bold">=</span> g_queue_pop_head(rem);
        GQueue<span style="font-weight:bold">*</span> t       <span style="font-weight:bold">=</span> rem;

        <span style="font-weight:bold">return</span>  isEmpty                 <span style="font-weight:bold">?</span>
                                    error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">You haven&#39;t closed your last narrative comment</span><span style="color:#b84">&#34;</span>) <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> OpenComment  <span style="font-weight:bold">?</span>
                    error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Don&#39;t open narrative comments inside narrative comments at line %i</span><span style="color:#b84">&#34;</span>,
                          h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>OpenComment.line)                                              <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> CloseComment <span style="font-weight:bold">?</span> (<span style="font-weight:bold">struct</span> tuple) {.acc <span style="font-weight:bold">=</span> acc, .rem <span style="font-weight:bold">=</span> t}             <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Text         <span style="font-weight:bold">?</span> parse_narrative(g_queue_push_back(acc, h), t)     <span style="font-weight:bold">:</span>
                                          error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Should never get here</span><span style="color:#b84">&#34;</span>);
    };

    <span style="font-weight:bold">struct</span> tuple parse_code(GQueue<span style="font-weight:bold">*</span> acc, GQueue<span style="font-weight:bold">*</span> rem) {

        <span style="color:#458;font-weight:bold">bool</span> isEmpty    <span style="font-weight:bold">=</span> g_queue_is_empty(rem);
        Token<span style="font-weight:bold">*</span> h    <span style="font-weight:bold">=</span> g_queue_pop_head(rem);
        GQueue<span style="font-weight:bold">*</span> t   <span style="font-weight:bold">=</span> rem;

        <span style="font-weight:bold">return</span>  isEmpty                 <span style="font-weight:bold">?</span> (<span style="font-weight:bold">struct</span> tuple) {.acc <span style="font-weight:bold">=</span> acc, .rem <span style="font-weight:bold">=</span> t}         <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> OpenComment  <span style="font-weight:bold">?</span>
                    (<span style="font-weight:bold">struct</span> tuple) {.acc <span style="font-weight:bold">=</span> acc, .rem <span style="font-weight:bold">=</span> g_queue_push_front(rem, h)}      <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> CloseComment <span style="font-weight:bold">?</span> parse_code(g_queue_push_back(acc, h), rem)    <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Text         <span style="font-weight:bold">?</span> parse_code(g_queue_push_back(acc, h), rem)    <span style="font-weight:bold">:</span>
                                          error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Should never get here</span><span style="color:#b84">&#34;</span>);
    };
    <span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">undef error</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
    GQueue<span style="font-weight:bold">*</span> parse_rec(GQueue<span style="font-weight:bold">*</span> acc, GQueue<span style="font-weight:bold">*</span> rem) {

        <span style="color:#458;font-weight:bold">bool</span> isEmpty    <span style="font-weight:bold">=</span> g_queue_is_empty(rem);
        Token<span style="font-weight:bold">*</span> h    <span style="font-weight:bold">=</span> g_queue_pop_head(rem);
        GQueue<span style="font-weight:bold">*</span> t   <span style="font-weight:bold">=</span> rem;

        <span style="font-weight:bold">return</span>  isEmpty                 <span style="font-weight:bold">?</span> acc                                           :
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> OpenComment  <span style="font-weight:bold">?</span> ({
                                           GQueue<span style="font-weight:bold">*</span> emp <span style="font-weight:bold">=</span> g_queue_new();
                                           <span style="font-weight:bold">struct</span> tuple tu <span style="font-weight:bold">=</span> parse_narrative(emp, t);
                                           Chunk<span style="font-weight:bold">*</span> ch <span style="font-weight:bold">=</span> union_new(
                                                Chunk, NarrativeChunk, .tokens <span style="font-weight:bold">=</span> tu.acc );
                                           GQueue<span style="font-weight:bold">*</span> newQ <span style="font-weight:bold">=</span> g_queue_push_back(acc, ch);
                                           parse_rec(newQ, tu.rem);
                                           })                                            <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> CloseComment <span style="font-weight:bold">?</span>
                    report_error_e(
                        <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Don&#39;t insert a close narrative comment at the start of your</span><span style="color:#b84">&#34;</span>
                        <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84"> program at line %i</span><span style="color:#b84">&#34;</span>,
                                            h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>OpenComment.line)                         <span style="font-weight:bold">:</span>
                h<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Text         <span style="font-weight:bold">?</span>
                                        ({
                                           GQueue<span style="font-weight:bold">*</span> emp <span style="font-weight:bold">=</span> g_queue_new();
                                           <span style="font-weight:bold">struct</span> tuple tu <span style="font-weight:bold">=</span>
                                                parse_code(g_queue_push_front(emp, h), t);
                                           parse_rec(g_queue_push_back
                                            (acc,
                                             union_new(Chunk, CodeChunk, .tokens <span style="font-weight:bold">=</span> tu.acc)),
                                             tu.rem);
                                          })                                                               <span style="font-weight:bold">:</span>
                                          g_assert_no_match;
    }

    <span style="font-weight:bold">return</span> parse_rec(g_queue_new(), tokens);
}
</code></pre></div><h2 id="flattener">Flattener</h2>
<p>This follows the usual practice of representing fold as foreach statments (and maps to). Pheraps I shall build better abstractions for them at some point. I also introduce a little macro to simplify writing of GFunc lambdas, given how pervasive they are.</p>
<p>Again, note how heavy ternary operated this is …</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">define g_func_z(type, name, ...) lambda(void,                                              </span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>                                        (<span style="color:#458;font-weight:bold">void</span><span style="font-weight:bold">*</span> private_it, G_GNUC_UNUSED <span style="color:#458;font-weight:bold">void</span><span style="font-weight:bold">*</span> private_no){ 
                                       type name <span style="font-weight:bold">=</span> private_it;                              
                                       __VA_ARGS__                                          
                                })

<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> flatten(Options<span style="font-weight:bold">*</span> options, GQueue<span style="font-weight:bold">*</span> chunks) {
    GString<span style="font-weight:bold">*</span> token_to_string_narrative(Token<span style="font-weight:bold">*</span> tok) {
        <span style="font-weight:bold">return</span>  tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> OpenComment <span style="font-weight:bold">|</span><span style="font-weight:bold">|</span>
                tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> CloseComment   <span style="font-weight:bold">?</span>
                    report_error_e(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Cannot nest narrative comments at line %i</span><span style="color:#b84">&#34;</span>,
                                   tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>OpenComment.line)                                   <span style="font-weight:bold">:</span>
                tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Text           <span style="font-weight:bold">?</span> g_string_new(tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Text.text)                  <span style="font-weight:bold">:</span>
                                              g_assert_no_match;
    }
    GString<span style="font-weight:bold">*</span> token_to_string_code(Token<span style="font-weight:bold">*</span> tok) {
        <span style="font-weight:bold">return</span>  tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> OpenComment    <span style="font-weight:bold">?</span>
                report_error_e(
                    <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Open narrative comment cannot be in code at line %i.</span><span style="color:#b84">&#34;</span>
                    <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84"> Pheraps you have an open comment </span><span style="color:#b84">&#34;</span>
                    <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">in a code string before this comment tag?</span><span style="color:#b84">&#34;</span>
                    , tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>OpenComment.line)                                                <span style="font-weight:bold">:</span>
                tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> CloseComment   <span style="font-weight:bold">?</span> g_string_new(options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>end_narrative)          <span style="font-weight:bold">:</span>
                tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Text           <span style="font-weight:bold">?</span> g_string_new(tok<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Text.text)                  <span style="font-weight:bold">:</span>
                                              g_assert_no_match;
    }
    Block<span style="font-weight:bold">*</span> flatten_chunk(Chunk<span style="font-weight:bold">*</span> ch) {
        <span style="font-weight:bold">return</span>  ch<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> NarrativeChunk  <span style="font-weight:bold">?</span> ({
                               GQueue<span style="font-weight:bold">*</span> tokens <span style="font-weight:bold">=</span> ch<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>NarrativeChunk.tokens;
                               GString<span style="font-weight:bold">*</span> res <span style="font-weight:bold">=</span> g_string_sized_new(<span style="color:#099">256</span>);
                               g_queue_foreach(tokens, g_func(Token<span style="font-weight:bold">*</span>, tok,
                                                g_string_append(
                                                    res,
                                                    token_to_string_narrative(tok)<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str);
                                                ), <span style="color:#999">NULL</span>);
                               union_new(Block, Narrative, .narrative <span style="font-weight:bold">=</span> res<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str);
                                               })   <span style="font-weight:bold">:</span>
                ch<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> CodeChunk       <span style="font-weight:bold">?</span> ({
                               GQueue<span style="font-weight:bold">*</span> tokens <span style="font-weight:bold">=</span> ch<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>CodeChunk.tokens;
                               GString<span style="font-weight:bold">*</span> res <span style="font-weight:bold">=</span> g_string_sized_new(<span style="color:#099">256</span>);
                               g_queue_foreach(tokens, g_func(Token<span style="font-weight:bold">*</span>, tok,
                                                        g_string_append(
                                                            res,
                                                            token_to_string_code(tok)<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str);
                                                        ), <span style="color:#999">NULL</span>);
                               union_new(Block, Code, .code <span style="font-weight:bold">=</span> res<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str);
                                               })   <span style="font-weight:bold">:</span>
                               g_assert_no_match;
    }

    GQueue<span style="font-weight:bold">*</span> res <span style="font-weight:bold">=</span> g_queue_new();
    g_queue_foreach(chunks, g_func(Chunk<span style="font-weight:bold">*</span>, ch,
                                Block<span style="font-weight:bold">*</span> b <span style="font-weight:bold">=</span> flatten_chunk(ch);
                                g_queue_push_tail(res, b);
                                ) ,<span style="color:#999">NULL</span>);
    <span style="font-weight:bold">return</span> res;
}
</code></pre></div><p>Now we can tie everything together to build blockize, which is our parse tree.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">blockize</span>(Options<span style="font-weight:bold">*</span> options, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> source) {
    GQueue<span style="font-weight:bold">*</span> tokens  <span style="font-weight:bold">=</span> tokenize(options, source);
    GQueue<span style="font-weight:bold">*</span> blocks  <span style="font-weight:bold">=</span> parse(options, tokens);
    <span style="font-weight:bold">return</span> flatten(options, blocks);
}
<span style="color:#099">10</span> Define the phases
In C you can easily forward declare function, so you don<span style="color:#a61717;background-color:#e3d2d2">’</span>t have to come up with some clever escabotage like we had to <span style="font-weight:bold">do</span> in F<span style="color:#a61717;background-color:#e3d2d2">#</span>.

<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> remove_empty_blocks(Options<span style="font-weight:bold">*</span>, GQueue<span style="font-weight:bold">*</span>);
<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">merge_blocks</span>(Options<span style="font-weight:bold">*</span>, GQueue<span style="font-weight:bold">*</span>);
<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">add_code_tags</span>(Options<span style="font-weight:bold">*</span>, GQueue<span style="font-weight:bold">*</span>);

<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">process_phases</span>(Options<span style="font-weight:bold">*</span> options, GQueue<span style="font-weight:bold">*</span> blocks) {

    blocks          <span style="font-weight:bold">=</span> remove_empty_blocks(options, blocks);
    blocks          <span style="font-weight:bold">=</span> merge_blocks(options, blocks);
    blocks          <span style="font-weight:bold">=</span> add_code_tags(options, blocks);
    <span style="font-weight:bold">return</span> blocks;
}

<span style="font-weight:bold">static</span>
<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">extract</span>(Block<span style="font-weight:bold">*</span> b) {
    <span style="font-weight:bold">return</span>  b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Code         <span style="font-weight:bold">?</span> b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Code.code          :
            b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Narrative    <span style="font-weight:bold">?</span> b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Narrative.narrative:
                                      g_assert_no_match;
}
</code></pre></div><p>There must be a higher level way to write this utility function …</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="font-weight:bold">static</span>
<span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">is_str_all_spaces</span>(<span style="font-weight:bold">const</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> str) {
    g_assert(str);
    <span style="font-weight:bold">while</span>(<span style="font-weight:bold">*</span>str <span style="font-weight:bold">!</span><span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">0</span><span style="color:#b84">&#39;</span>) {
        <span style="font-weight:bold">if</span>(<span style="font-weight:bold">!</span>g_ascii_isspace(<span style="font-weight:bold">*</span>str))
            <span style="font-weight:bold">return</span> <span style="color:#999">false</span>;
        str<span style="font-weight:bold">+</span><span style="font-weight:bold">+</span>;
    }
    <span style="font-weight:bold">return</span> <span style="color:#999">true</span>;
}

<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">remove_empty_blocks</span>(G_GNUC_UNUSED Options<span style="font-weight:bold">*</span> options, GQueue<span style="font-weight:bold">*</span> blocks) {

    g_queue_foreach(blocks, g_func(Block<span style="font-weight:bold">*</span>, b,
        <span style="font-weight:bold">if</span>(is_str_all_spaces(extract(b)))
            g_queue_remove(blocks, b);
                                   ), <span style="color:#999">NULL</span>);
    <span style="font-weight:bold">return</span> blocks;
}

<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">merge_blocks</span>(G_GNUC_UNUSED Options<span style="font-weight:bold">*</span>options, GQueue<span style="font-weight:bold">*</span> blocks) {
    <span style="font-weight:bold">return</span>  g_queue_is_empty(blocks)            <span style="font-weight:bold">?</span> blocks            :
            g_queue_get_length(blocks) <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> <span style="color:#099">1</span>     <span style="font-weight:bold">?</span> blocks            :
                ({
                 Block<span style="font-weight:bold">*</span> h1 <span style="font-weight:bold">=</span> g_queue_pop_head(blocks);
                 Block<span style="font-weight:bold">*</span> h2 <span style="font-weight:bold">=</span> g_queue_pop_head(blocks);
                 h1<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Code <span style="font-weight:bold">&amp;</span><span style="font-weight:bold">&amp;</span> h2<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Code <span style="font-weight:bold">?</span> ({
                     <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> newCode <span style="font-weight:bold">=</span>
                        g_strjoin(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">&#34;</span>, h1<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Code.code, NL, h2<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Code.code, <span style="color:#999">NULL</span>);
                     Block<span style="font-weight:bold">*</span> b <span style="font-weight:bold">=</span> union_new(Block, Code, .code <span style="font-weight:bold">=</span> newCode);
                     merge_blocks(options, g_queue_push_front(blocks, b));
                                                         })         <span style="font-weight:bold">:</span>
                 h1<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Narrative <span style="font-weight:bold">&amp;</span><span style="font-weight:bold">&amp;</span> h2<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Narrative <span style="font-weight:bold">?</span> ({
                     <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> newNarr <span style="font-weight:bold">=</span>
                        g_strjoin(
                            <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">&#34;</span>, h1<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Narrative.narrative, NL, h2<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Narrative.narrative, <span style="color:#999">NULL</span>);
                     Block<span style="font-weight:bold">*</span> b <span style="font-weight:bold">=</span> union_new(Block, Narrative, .narrative <span style="font-weight:bold">=</span> newNarr);
                     merge_blocks(options, g_queue_push_front(blocks, b));
                                                         })         <span style="font-weight:bold">:</span>
                                                         ({
                     GQueue<span style="font-weight:bold">*</span> newBlocks <span style="font-weight:bold">=</span>
                        merge_blocks(options, g_queue_push_front(blocks, h2));
                     g_queue_push_front(newBlocks, h1);
                                                         });
                 });
}
</code></pre></div><p>This really should be in glib …</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="font-weight:bold">inline</span> <span style="font-weight:bold">static</span>
gint <span style="color:#900;font-weight:bold">g_asprintf_z</span>(gchar<span style="font-weight:bold">*</span><span style="font-weight:bold">*</span> string, gchar <span style="font-weight:bold">const</span> <span style="font-weight:bold">*</span>format, ...) {
	va_list argp;
	va_start(argp, format);
	gint bytes <span style="font-weight:bold">=</span> g_vasprintf(string, format, argp);
	va_end(argp);
    <span style="font-weight:bold">return</span> bytes;
}

<span style="font-weight:bold">static</span>
<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">indent</span>(<span style="color:#458;font-weight:bold">int</span> n, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> s) {
    g_assert(s);

    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> ind       <span style="font-weight:bold">=</span> g_strnfill(n, <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84"> </span><span style="color:#b84">&#39;</span>);
    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> tmp;
    g_asprintf(<span style="font-weight:bold">&amp;</span>tmp, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">%s%s</span><span style="color:#b84">&#34;</span>, ind, s);

    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> withNl;
    g_asprintf(<span style="font-weight:bold">&amp;</span>withNl, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">n%s</span><span style="color:#b84">&#34;</span>, ind);

    <span style="font-weight:bold">return</span> g_strjoinv(withNl, g_strsplit(tmp, NL, <span style="font-weight:bold">-</span><span style="color:#099">1</span>));
}
And finally I ended up defining map. See <span style="font-weight:bold">if</span> you like how the usage looks in the function below.

<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">define g_queue_map_z(q, type, name, ...) ({                                </span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>        GQueue<span style="font-weight:bold">*</span> private_res <span style="font-weight:bold">=</span> g_queue_new();                                
        g_queue_foreach(q, g_func(type, name,                               
            name <span style="font-weight:bold">=</span> __VA_ARGS__;                                             
            g_queue_push_tail(private_res, name);                           
            ), <span style="color:#999">NULL</span>);                                                       
        private_res;                                                        
                                      })

<span style="font-weight:bold">static</span>
GQueue<span style="font-weight:bold">*</span> add_code_tags(Options<span style="font-weight:bold">*</span> options, GQueue<span style="font-weight:bold">*</span> blocks) {

    GQueue<span style="font-weight:bold">*</span> indent_blocks(GQueue<span style="font-weight:bold">*</span> blocks) {
        <span style="font-weight:bold">return</span> g_queue_map(blocks, Block<span style="font-weight:bold">*</span>, b,
                b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Narrative <span style="font-weight:bold">?</span> b                                                                                                    :
                b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Code      <span style="font-weight:bold">?</span>
                    union_new(Block, Code, .code <span style="font-weight:bold">=</span>
                        indent(options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>code_symbols<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Indented.indentation, b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Code.code))    <span style="font-weight:bold">:</span>
                    g_assert_no_match;);
    }

    GQueue<span style="font-weight:bold">*</span> surround_blocks(GQueue<span style="font-weight:bold">*</span> blocks) {
        <span style="font-weight:bold">return</span> g_queue_map(blocks, Block<span style="font-weight:bold">*</span>, b,
                b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Narrative <span style="font-weight:bold">?</span>
                    union_new(Block, Narrative, .narrative <span style="font-weight:bold">=</span>
                        g_strjoin(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">&#34;</span>, NL, g_strstrip(b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Narrative.narrative), NL, <span style="color:#999">NULL</span>))   <span style="font-weight:bold">:</span>
                b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Code      <span style="font-weight:bold">?</span>
                    union_new(Block, Code, .code <span style="font-weight:bold">=</span> g_strjoin(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">&#34;</span>,
                                                 NL,
                                                 options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>code_symbols<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Surrounded.start_code,
                                                 NL,
                                                 g_strstrip(b<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Code.code),
                                                 NL,
                                                 options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>code_symbols<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>Surrounded.end_code,
                                                 NL,
                                                 <span style="color:#999">NULL</span>))    <span style="font-weight:bold">:</span>
                                       g_assert_no_match;);

    }

    <span style="font-weight:bold">return</span>  options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>code_symbols<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Indented     <span style="font-weight:bold">?</span>   indent_blocks(blocks)   <span style="font-weight:bold">:</span>
            options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>code_symbols<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>kind <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> Surrounded   <span style="font-weight:bold">?</span>   surround_blocks(blocks) <span style="font-weight:bold">:</span>
                                                            g_assert_no_match;
}

<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> stringify(GQueue<span style="font-weight:bold">*</span> blocks) {
    GString<span style="font-weight:bold">*</span> res <span style="font-weight:bold">=</span> g_string_sized_new(<span style="color:#099">2048</span>);
    g_queue_foreach(blocks, g_func(Block<span style="font-weight:bold">*</span>, b,
        g_string_append(res, extract(b));
    ), <span style="color:#999">NULL</span>);
    <span style="font-weight:bold">return</span> <span style="color:#900;font-weight:bold">g_strchug</span>(res<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>str);
}

<span style="color:#458;font-weight:bold">void</span> deb(GQueue<span style="font-weight:bold">*</span> q);

<span style="font-weight:bold">static</span>
<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">translate</span>(Options<span style="font-weight:bold">*</span> options, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> source) {
    g_assert(options);
    g_assert(source);

    GQueue<span style="font-weight:bold">*</span> blocks  <span style="font-weight:bold">=</span> blockize(options, source);
    blocks          <span style="font-weight:bold">=</span> process_phases(options, blocks);
    <span style="font-weight:bold">return</span> stringify(blocks);
}
</code></pre></div><h2 id="parsing-the-command-line">Parsing the command line</h2>
<p>In glib there is a command line parser that accept options in unix-like format and automatically produces professional &ndash;help messages and such. We shoudl really have something like this in .NET. Pheraps we do and I’m not aware of it?</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="font-weight:bold">typedef</span> <span style="font-weight:bold">struct</span> CmdOptions { <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> input_file; <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> output_file; Options<span style="font-weight:bold">*</span> options;} CmdOptions;

<span style="font-weight:bold">static</span>
CmdOptions<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">parse_command_line</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> argv[]);

<span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">char</span> <span style="font-weight:bold">*</span>no <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>, <span style="font-weight:bold">*</span>nc <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>, <span style="font-weight:bold">*</span>l <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>, <span style="font-weight:bold">*</span>co <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>, <span style="font-weight:bold">*</span>cc <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>, <span style="font-weight:bold">*</span>ou <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>;
<span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span><span style="font-weight:bold">*</span> in_file;

<span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">int</span> ind <span style="font-weight:bold">=</span> <span style="color:#099">0</span>;
<span style="font-weight:bold">static</span> <span style="color:#458;font-weight:bold">bool</span> tests <span style="font-weight:bold">=</span> <span style="color:#999">false</span>;

<span style="color:#998;font-style:italic">// this is a bug in gcc, fixed in 2.7.0 not to moan about the final NULL
</span><span style="color:#998;font-style:italic"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">pragma GCC diagnostic push</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">pragma GCC diagnostic ignored &#34;-Wmissing-field-initializers&#34;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
<span style="font-weight:bold">static</span> GOptionEntry entries[] <span style="font-weight:bold">=</span>
{
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">language</span><span style="color:#b84">&#34;</span>          , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">l</span><span style="color:#b84">&#39;</span>, <span style="color:#099">0</span>, G_OPTION_ARG_STRING, <span style="font-weight:bold">&amp;</span>l ,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Language used</span><span style="color:#b84">&#34;</span>, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">L</span><span style="color:#b84">&#34;</span>  },
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">output</span><span style="color:#b84">&#34;</span>            , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">o</span><span style="color:#b84">&#39;</span>, <span style="color:#099">0</span>, G_OPTION_ARG_FILENAME, <span style="font-weight:bold">&amp;</span>ou,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Defaults to the input file name with mkd extension</span><span style="color:#b84">&#34;</span>, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">FILE</span><span style="color:#b84">&#34;</span> },
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">narrative-open</span><span style="color:#b84">&#34;</span>    , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">p</span><span style="color:#b84">&#39;</span>, <span style="color:#099">0</span>, G_OPTION_ARG_STRING, <span style="font-weight:bold">&amp;</span>no,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">String opening a narrative comment</span><span style="color:#b84">&#34;</span>,   <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">NO</span><span style="color:#b84">&#34;</span> },
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">narrative-close</span><span style="color:#b84">&#34;</span>   , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">c</span><span style="color:#b84">&#39;</span>, <span style="color:#099">0</span>, G_OPTION_ARG_STRING, <span style="font-weight:bold">&amp;</span>nc,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">String closing a narrative comment</span><span style="color:#b84">&#34;</span>,   <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">NC</span><span style="color:#b84">&#34;</span> },
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">code-open</span><span style="color:#b84">&#34;</span>         , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">P</span><span style="color:#b84">&#39;</span>, <span style="color:#099">0</span>, G_OPTION_ARG_STRING, <span style="font-weight:bold">&amp;</span>co,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">String opening a code block</span><span style="color:#b84">&#34;</span>,          <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">CO</span><span style="color:#b84">&#34;</span> },
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">code-close</span><span style="color:#b84">&#34;</span>        , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">C</span><span style="color:#b84">&#39;</span>, <span style="color:#099">0</span>, G_OPTION_ARG_STRING, <span style="font-weight:bold">&amp;</span>cc,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">String closing a code block</span><span style="color:#b84">&#34;</span>,          <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">CC</span><span style="color:#b84">&#34;</span> },
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">indent</span><span style="color:#b84">&#34;</span>            , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">i</span><span style="color:#b84">&#39;</span>, <span style="color:#099">0</span>, G_OPTION_ARG_INT,    <span style="font-weight:bold">&amp;</span>ind,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Indent the code by N whitespaces</span><span style="color:#b84">&#34;</span>,    <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">N</span><span style="color:#b84">&#34;</span>  },
  { <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">run-tests</span><span style="color:#b84">&#34;</span>         , <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">t</span><span style="color:#b84">&#39;</span>, G_OPTION_FLAG_HIDDEN, G_OPTION_ARG_NONE,   <span style="font-weight:bold">&amp;</span>tests,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Run all the testcases</span><span style="color:#b84">&#34;</span>, <span style="color:#999">NULL</span> },
  { G_OPTION_REMAINING  ,   <span style="color:#099">0</span>, <span style="color:#099">0</span>, G_OPTION_ARG_FILENAME_ARRAY, <span style="font-weight:bold">&amp;</span>in_file,
                                <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">Input file to process</span><span style="color:#b84">&#34;</span>,   <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">FILE</span><span style="color:#b84">&#34;</span> },
  { <span style="color:#999">NULL</span> }
};
<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">pragma GCC diagnostic pop</span><span style="color:#999;font-weight:bold">
</span></code></pre></div><p>Brain damaged way to run tests with a -t hidden option. Not paying the code size price in release.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">ifndef NDEBUG</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">include</span> <span style="color:#999;font-weight:bold">&#34;tests.c&#34;</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">endif</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>Here is my big ass command parsing function. It could use a bit of refactoring <span style="color:#a61717;background-color:#e3d2d2">…</span>

<span style="color:#458;font-weight:bold">void</span> destroy_arena_allocator();

<span style="font-weight:bold">static</span>
CmdOptions<span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">parse_command_line</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> argv[]) {

    GError <span style="font-weight:bold">*</span>error <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>;
    GOptionContext <span style="font-weight:bold">*</span>context;

    context <span style="font-weight:bold">=</span>
        g_option_context_new (<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">- translate source code with comemnts to an annotated file</span><span style="color:#b84">&#34;</span>);
    g_option_context_add_main_entries (context, entries, <span style="color:#999">NULL</span>);
    g_option_context_set_summary(context, summary(s_lang_params_table));

    <span style="font-weight:bold">if</span> (<span style="font-weight:bold">!</span>g_option_context_parse (context, <span style="font-weight:bold">&amp;</span>argc, <span style="font-weight:bold">&amp;</span>argv, <span style="font-weight:bold">&amp;</span>error))
        report_error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">option parsing failed: %s</span><span style="color:#b84">&#34;</span>, error<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>message);

    CmdOptions<span style="font-weight:bold">*</span> opt <span style="font-weight:bold">=</span> g_new(CmdOptions, <span style="color:#099">1</span>);
    opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options <span style="font-weight:bold">=</span> g_new(Options, <span style="color:#099">1</span>);

    <span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">ifndef NDEBUG</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>    <span style="font-weight:bold">if</span>(tests) {
        <span style="color:#458;font-weight:bold">int</span> i <span style="font-weight:bold">=</span> run_tests(argc, argv);
        exit(i);
    }
    <span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">endif</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
    <span style="font-weight:bold">if</span>(<span style="font-weight:bold">!</span>in_file) report_error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">No input file</span><span style="color:#b84">&#34;</span>);
    opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>input_file <span style="font-weight:bold">=</span> <span style="font-weight:bold">*</span>in_file;

    <span style="color:#998;font-style:italic">// Uses input file without extension, adding extension .mkd (assume markdown)
</span><span style="color:#998;font-style:italic"></span>    opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>output_file <span style="font-weight:bold">=</span> ou <span style="font-weight:bold">?</span> ou :  ({
                                  <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> output      <span style="font-weight:bold">=</span> g_strdup(<span style="font-weight:bold">*</span>in_file);
                                  <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> extension   <span style="font-weight:bold">=</span> g_strrstr(output, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">.</span><span style="color:#b84">&#34;</span>);
                                  extension <span style="font-weight:bold">?</span> ({
                                               <span style="font-weight:bold">*</span>extension <span style="font-weight:bold">=</span> <span style="color:#b84"></span><span style="color:#b84">&#39;</span><span style="color:#b84">0</span><span style="color:#b84">&#39;</span>;
                                               g_strjoin(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">&#34;</span>, output, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">.mkd</span><span style="color:#b84">&#34;</span>, <span style="color:#999">NULL</span>);
                                                }) <span style="font-weight:bold">:</span>
                                               g_strjoin(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">&#34;</span>, output, <span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">.mkd</span><span style="color:#b84">&#34;</span>, <span style="color:#999">NULL</span>);
                                  });

    <span style="font-weight:bold">if</span>(l) { <span style="color:#998;font-style:italic">// user passed a language
</span><span style="color:#998;font-style:italic"></span>        LangSymbols<span style="font-weight:bold">*</span> lang <span style="font-weight:bold">=</span> lang_find_symbols(s_lang_params_table, l);
        <span style="font-weight:bold">if</span>(<span style="font-weight:bold">!</span>lang) report_error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">%s is not a supported language</span><span style="color:#b84">&#34;</span>, l);

        opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>start_narrative  <span style="font-weight:bold">=</span> lang<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>start;
        opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>end_narrative    <span style="font-weight:bold">=</span> lang<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>end;

    } <span style="font-weight:bold">else</span> {
        <span style="font-weight:bold">if</span>(<span style="font-weight:bold">!</span>no <span style="font-weight:bold">|</span><span style="font-weight:bold">|</span> <span style="font-weight:bold">!</span>nc) report_error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">You need to specify either -l, or both -p and -c</span><span style="color:#b84">&#34;</span>);

        opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>start_narrative  <span style="font-weight:bold">=</span> no;
        opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>end_narrative    <span style="font-weight:bold">=</span> nc;
    }

    <span style="font-weight:bold">if</span>(ind) { <span style="color:#998;font-style:italic">// user pass    g_option_context_free();
</span><span style="color:#998;font-style:italic"></span>        opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>code_symbols <span style="font-weight:bold">=</span> union_new(CodeSymbols, Indented, .indentation <span style="font-weight:bold">=</span> ind);
    } <span style="font-weight:bold">else</span> {
        <span style="font-weight:bold">if</span>(<span style="font-weight:bold">!</span>co <span style="font-weight:bold">|</span><span style="font-weight:bold">|</span> <span style="font-weight:bold">!</span>cc) report_error(<span style="color:#b84"></span><span style="color:#b84">&#34;</span><span style="color:#b84">You need to specify either -indent, or both -P and -C</span><span style="color:#b84">&#34;</span>);
        opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>code_symbols <span style="font-weight:bold">=</span>
            union_new(CodeSymbols, Surrounded, .start_code <span style="font-weight:bold">=</span> co, .end_code <span style="font-weight:bold">=</span> cc);
    }

    <span style="font-weight:bold">return</span> opt;
}
</code></pre></div><p>Some windows programs (i.e. notepad, VS, …) add a 3 bytes prelude to their utf-8 files, C doesn’t know anything about it, so you need to strip it. On this topic, I suspect the program works on UTF-8 files that contain non-ASCII chars, even if when I wrote it I didn’t know anything about localization.</p>
<p>It should work because I’m just splitting the file when I see a certain ASCII string and in UTF-8 ASCII chars cannot appear anywhere else than in their ASCII position.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> <span style="color:#900;font-weight:bold">skip_utf8_bom</span>(<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> str) {
    <span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> b <span style="font-weight:bold">=</span> (<span style="color:#458;font-weight:bold">unsigned</span> <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>) str;
    <span style="font-weight:bold">return</span>  b[<span style="color:#099">0</span>] <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> <span style="color:#099">0xEF</span> <span style="font-weight:bold">&amp;</span><span style="font-weight:bold">&amp;</span> b[<span style="color:#099">1</span>] <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> <span style="color:#099">0xBB</span> <span style="font-weight:bold">&amp;</span><span style="font-weight:bold">&amp;</span> b[<span style="color:#099">2</span>] <span style="font-weight:bold">=</span><span style="font-weight:bold">=</span> <span style="color:#099">0xBF</span>    <span style="font-weight:bold">?</span> (<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>) <span style="font-weight:bold">&amp;</span>b[<span style="color:#099">3</span>]  <span style="font-weight:bold">:</span> <span style="color:#998;font-style:italic">// UTF-8
</span><span style="color:#998;font-style:italic"></span>                                                              (<span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span>) b;
}
</code></pre></div><h2 id="not-freeing-memory-again">Not freeing memory (again)</h2>
<p>The reason I haven’t been freeing memory all along is because I was planning on using an arena allocator (a kind of linear allocator).</p>
<p>Memory management is fully hortogonal to the style of programming described in this post. You can do it whatever way you prefer, but there is a certain affinity between an arena allocator (or garbage collection) and functional programming because of the temporary objects created in expressions. You could create the temporary objects explicitely, but that would diminish the conciseness of the paradigm.</p>
<p>I have an arena allocator implementation here. In the code below I comment it out so that you don’t have a dependency from that code if you want to try this. The program runs so quickly and it does so little that you can probably let the operating system reclame memory at the end of the process life.</p>
<p>If you ended up integrating this with an editor (i.e. literate programming editing), you’d need to be more careful.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">ifdef ARENA</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
Arena_T the_arena;

<span style="font-weight:bold">inline</span> <span style="font-weight:bold">static</span>
gpointer <span style="color:#900;font-weight:bold">arena_malloc</span>(gsize n_bytes) {
    <span style="font-weight:bold">return</span> Arena_alloc(the_arena, n_bytes, __FILE__, __LINE__);
}

<span style="font-weight:bold">inline</span> <span style="font-weight:bold">static</span>
gpointer <span style="color:#900;font-weight:bold">arena_calloc</span>(gsize n_blocks, gsize n_block_bytes) {
    <span style="font-weight:bold">return</span> Arena_calloc(the_arena, n_blocks, n_block_bytes, __FILE__, __LINE__);
}

<span style="font-weight:bold">inline</span> <span style="font-weight:bold">static</span>
gpointer <span style="color:#900;font-weight:bold">arena_realloc</span>(gpointer mem, gsize n_bytes) {
    <span style="font-weight:bold">return</span> Arena_realloc(the_arena, mem, n_bytes, __FILE__, __LINE__);
}

<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">arena_free</span>(G_GNUC_UNUSED gpointer mem) {
    <span style="color:#998;font-style:italic">// NOP
</span><span style="color:#998;font-style:italic"></span>}

<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">set_arena_allocator</span>() {
    GMemVTable vt <span style="font-weight:bold">=</span> (GMemVTable) { .malloc <span style="font-weight:bold">=</span> arena_malloc,      .calloc <span style="font-weight:bold">=</span> arena_calloc,
                                   .realloc <span style="font-weight:bold">=</span> arena_realloc,    .free <span style="font-weight:bold">=</span> arena_free,
                                   .try_malloc <span style="font-weight:bold">=</span> arena_malloc,  .try_realloc <span style="font-weight:bold">=</span> arena_realloc};
    g_mem_set_vtable(<span style="font-weight:bold">&amp;</span>vt);

    the_arena <span style="font-weight:bold">=</span> Arena_new();
}

<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">destroy_arena_allocator</span>() {
    Arena_dispose(<span style="font-weight:bold">&amp;</span>the_arena);
}

<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">endif</span><span style="color:#999;font-weight:bold">
</span></code></pre></div><h2 id="summary">Summary</h2>
<p>I have to say, it didn’t feel too cumbersome to structure C code in a functional way, assuming that you can use GLib and a couple of GCC extensions to the language. It certainly doesn’t have the problems that C++ has in terms of debugging STL failures.</p>
<p>There are a couple of things I don’t like about GLib and I’m working on an hobby project to overcome them. Eventually I’ll post it.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">main</span>(<span style="color:#458;font-weight:bold">int</span> argc, <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> argv[])
{
<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">ifdef ARENA</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>    set_arena_allocator();
<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">endif</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
    CmdOptions<span style="font-weight:bold">*</span> opt <span style="font-weight:bold">=</span> parse_command_line(argc, argv);

    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> source    <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>;
    GError<span style="font-weight:bold">*</span> error   <span style="font-weight:bold">=</span> <span style="color:#999">NULL</span>;

    <span style="font-weight:bold">if</span>(<span style="font-weight:bold">!</span>g_file_get_contents(opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>input_file, <span style="font-weight:bold">&amp;</span>source, <span style="color:#999">NULL</span>, <span style="font-weight:bold">&amp;</span>error))
        report_error(error<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>message);

    source <span style="font-weight:bold">=</span> skip_utf8_bom(source);

    <span style="color:#458;font-weight:bold">char</span><span style="font-weight:bold">*</span> text              <span style="font-weight:bold">=</span> translate(opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>options, source);

    <span style="font-weight:bold">if</span>(<span style="font-weight:bold">!</span>g_file_set_contents(opt<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>output_file, text, <span style="font-weight:bold">-</span><span style="color:#099">1</span>, <span style="font-weight:bold">&amp;</span>error))
        report_error(error<span style="font-weight:bold">-</span><span style="font-weight:bold">&gt;</span>message);

<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">ifdef ARENA</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>    destroy_arena_allocator();
<span style="color:#999;font-weight:bold">#</span><span style="color:#999;font-weight:bold">endif</span><span style="color:#999;font-weight:bold">
</span><span style="color:#999;font-weight:bold"></span>
    <span style="font-weight:bold">return</span> <span style="color:#099">0</span>;
}
</code></pre></div>


  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¶</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/c">C</a></li>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
            <li><a href="../../MyBlog/tags/functional-programming">Functional Programming</a></li>
        
            <li><a href="../../MyBlog/tags/literate-programming">Literate programming</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¶</h2>
    </header>
    <nav id="TableOfContents">
    <ul>
        

        
        <li>
        <a href="#main-ideas">Main ideas</a>
        

        
        </li><li>
            <a href="#lack-of-tuples">Lack of tuples</a>
        

        
        </li><li>
            <a href="#folding-over-arrays">Folding over arrays</a>
        

        
        </li><li>
            <a href="#deallocating-stuff">Deallocating stuff</a>
        

        
        </li><li>
            <a href="#discriminated-unions">Discriminated unions</a>
        

        
        </li><li>
            <a href="#main-data-structure">Main data structure</a>
        

        
        </li><li>
            <a href="#tokenizer">Tokenizer</a>
        

        
        </li><li>
            <a href="#parser">Parser</a>
        

        
        </li><li>
            <a href="#flattener">Flattener</a>
        

        
        </li><li>
            <a href="#parsing-the-command-line">Parsing the command line</a>
        

        
        </li><li>
            <a href="#not-freeing-memory-again">Not freeing memory (again)</a>
        

        
        </li><li>
            <a href="#summary">Summary</a>
    </li></ul>
</nav>


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>