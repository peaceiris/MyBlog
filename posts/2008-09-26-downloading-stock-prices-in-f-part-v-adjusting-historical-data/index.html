<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="Other parts:
 Part I - Data modeling Part II - Html scraping Part III - Async loader for prices and divs Part IV - Async loader for splits Part VI - Code posted   Here is the problem. When you download prices/divs/splits from Yahoo you get a strange mix of historical numbers and adjusted numbers. To be more precise, the dividends are historically adjusted. The prices are not adjusted, but there is one last column in the data for Adjusted close.">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>Downloading stock prices in F# - Part V - Adjusting historical data | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">❧</a>
            
                <time id="blog_date" > 2008/09/09</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        Downloading stock prices in F# - Part V - Adjusting historical data
    
    </h1>

    </header>

    <main>
        

<p>Other parts:</p>
<ul>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/08/29/downloading-stock-prices-in-f-part-i-data-modeling.aspx">Part I  - Data modeling</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/09/05/downloading-stock-prices-in-f-part-ii-html-scraping.aspx">Part II  - Html scraping</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/09/12/downloading-stock-prices-in-f-part-iii-async-loader-for-prices-and-divs.aspx">Part III  - Async loader for prices and divs</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/09/19/downloading-stock-prices-in-f-part-iv-async-loader-for-splits.aspx">Part IV  - Async loader for splits</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2008/10/20/downloading-stock-prices-in-f-part-vi-code-posted.aspx">Part VI  - Code posted</a> </li>
</ul>
<p>Here is the problem. When you download prices/divs/splits from Yahoo you get a strange mix of historical numbers and adjusted numbers. To be more precise, the dividends are historically adjusted. The prices are not adjusted, but there is one last column in the data for Adjusted close. If you don&rsquo;t know what ‘adjusted&rsquo; means in this context read <a href="http://help.yahoo.com/l/us/yahoo/finance/quotes/quote-12.html">here</a>.</p>
<p>The problem with using the ‘adjusted close&rsquo; column is that, for a particular date in the past, ‘adjusted close&rsquo; changes whenever the company pays a dividend or splits its stock. So if I retrieve the value on two different days I might get different numbers because, in the meantime, the company paid a dividend. This prevents me from storing a subset of the data locally and then retrieving other subsets later on. It also has the limitation that just the closing price is present while I might need adjusted opening price, adjusted high price or even adjusted volume depending on the operations I want to perform on the data (i.e. calculating oscillators or volume-adjusted moving averages).</p>
<p>The solution I came up with is to download the data and transform it to an ‘asHappened&rsquo; state. This state is simply an unadjusted version of what happened in the past. Data in this state is not going to change in the future, which means that I can safely store it locally. I can then on demand produce ‘historically adjusted&rsquo; data whenever I need to.</p>
<p>Ok, to the code. As it often happens, I need some auxiliary functions before I get to the core of the algorithms. The first one is a way to compare two observations, I will use it later on to sort a list of observations.</p>
<pre class="code"><span style="color:blue;">let </span>compareObservations obs1 obs2 =
    <span style="color:blue;">if </span>obs1.Date &lt;&gt; obs2.Date <span style="color:blue;">then </span>obs2.Date.CompareTo(obs1.Date)
    <span style="color:blue;">else
        match </span>obs1.Event, obs2.Event <span style="color:blue;">with
            </span>| Price _, Price _ | Div _, Div _ | Split _, Split _<br />                <span style="color:blue;">-&gt; </span>failwith <span style="color:maroon;">"Two same date/ same kind observations"
            </span>| Price _, _  <span style="color:blue;">-&gt; </span>-1
            | _, Price _  <span style="color:blue;">-&gt; </span>1
            | _           <span style="color:blue;">-&gt; </span></pre>
<p>This is rather simple. If the dates of these observations are different, just compare them. If they are the same then the two observations cannot be of the same type (i.e. I cannot have two prices for a particular date). Given that they are not of the same, then &amp;(&amp;^%!#$!4. Crap, that teaches me to put comments in my code! I think I&rsquo;m putting the price information first, but I&rsquo;m not sure. Anyhow my universal excuse not to figuring it out is that the testcases succeed so I must be doing it right (how lame, testcase-addiction I guess).</p>
<p>The next auxiliary function is just a wrapper over fold. I always tend to wrap fold calls in a method with a better name because I remember the old times when I didn&rsquo;t know what fold was. I want a reader of my code to be able to understand it even if they are not familiar with fold (the ‘universal functional Swiss-Army-Knife). This function is a map that needs to know the value of an accumulator to correctly perform its mapping over each element.</p>
<pre class="code"><span style="color:blue;">let </span>mapAcc acc newAccF newItemF inl =
    <span style="color:blue;">let </span>foldF (acc, l) x = newAccF acc x, (newItemF acc x)::l
    <span style="color:blue;">let </span>_, out = inl |&gt; List.fold_left foldF (acc, [])
    out</pre>
<p>Apart from the implementation details, this function takes an accumulator, an accumulator function, an item function and an input list. For each element in the list it calculates two things:</p>
<ol>
<li>a new value for the accumulator: newAccumulatorValue = <u>newAccF</u> oldAccValue itemValue</li>
<li>a new value for the item: new ItemValue = <u>newItemF</u> accValue oldItemValue</li>
</ol>
<p>Maybe there is a standard functional way to do such a thing with a specific name that I&rsquo;m not aware of. <a href="http://blogs.msdn.com/lukeh/default.aspx">Luke</a> might know. He is my resident <u>fold</u> expert.</p>
<p>All right, now to he main algorithm.</p>
<pre class="code"><span style="color:blue;">let </span>asHappened splitFactor observations =
    <span style="color:blue;">let </span>newSplitFactor splitFactor obs =
        <span style="color:blue;">match </span>obs.Event <span style="color:blue;">with
            </span>| Split(factor) <span style="color:blue;">-&gt; </span>splitFactor * factor
            | _             <span style="color:blue;">-&gt; </span>splitFactor
    <span style="color:blue;">let </span>newObs splitFactor obs =
        <span style="color:blue;">let </span>date = obs.Date
        <span style="color:blue;">let </span>event = <span style="color:blue;">match </span>obs.Event <span style="color:blue;">with
                        </span>| Price(p)                  <span style="color:blue;">-&gt; </span>Price(p)
                        | Div(amount)               <span style="color:blue;">-&gt; </span>Div(amount * splitFactor)
                        | Split(factor)             <span style="color:blue;">-&gt; </span>Split(factor)
        {Date = date; Event = event}
    observations
    |&gt; List.sort compareObservations
    |&gt; mapAcc splitFactor newSplitFactor newObs</pre>
<p>To understand what&rsquo;s going on start from the bottom. I&rsquo;m taking the observation list downloaded from Yahoo and sorting it using my <u>compareObservations</u> function. I then take the resulting list and apply the previously described <u>mapAcc</u> to it. For this function splitFactor is the accumulator, newSplitFactor is the accumulator function and newObs is the function that generate a new value for each item in the list.</p>
<p><u>NewSplitFactor</u> is trivial: every time it sees a Split observation it updates the value of the split factor. That&rsquo;s it. <u>NewObs</u> is rather simple as well. Every time it sees a dividend, it ‘unadjust&rsquo; it by multiplying its amount by the split factor. The end result is to transform the dividends downloaded from Yahoo (which are adjusted) to an unadjusted state. I could have filtered out the price observations before doing all of this and add them back afterward, but didn&rsquo;t. It&rsquo;d probably be slower</p>
<p>Now that I can recreate the state of the world as it was at a particular point in time, what if I want to adjust the data? I can call <u>adjusted</u></p>
<pre class="code"><span style="color:blue;">let </span>adjusted (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact)<br />                                                                   asHappenedObs =
    <span style="color:blue;">let </span>newFactor (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact) obs =
        <span style="color:blue;">match </span>obs.Event <span style="color:blue;">with
            </span>| Split(split)  <span style="color:blue;">-&gt;<br />                 </span>splitFactor * split, lastDiv, oFact, hFact, lFact, cFact, vFact
            | Div(div)      <span style="color:blue;">-&gt; </span>splitFactor, div, oFact, hFact, lFact, cFact, vFact
            | Price(p)      <span style="color:blue;">-&gt;<br />                 </span>splitFactor, 0.&lt;money&gt;, oFact / (1. - lastDiv / p.Open),<br />                 hFact / (1. - lastDiv / p.High), lFact / (1. - lastDiv / p.Low),<br />                 cFact / (1. - lastDiv / p.Close), vFact / (1. - lastDiv / p.Close)
    <span style="color:blue;">let </span>newObs (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact) obs =
        <span style="color:blue;">let </span>date = obs.Date
        <span style="color:blue;">let </span>event = <span style="color:blue;">match </span>obs.Event <span style="color:blue;">with
                        </span>| Price(p)          <span style="color:blue;">-&gt;<br />                            </span>Price({Open = p.Open / splitFactor / oFact;<br />                            High = p.High / splitFactor / hFact;<br />                            Low = p.Low / splitFactor / lFact;<br />                            Close = p.Close / splitFactor / cFact;<br />                            Volume = p.Volume / splitFactor / vFact })
                        | Div(amount)       <span style="color:blue;">-&gt; </span>Div (amount / splitFactor)
                        | Split(split)      <span style="color:blue;">-&gt; </span>Split(split)
        {Date = date; Event = event}
    asHappenedObs
        |&gt; List.sort compareObservations
        |&gt; mapAcc (splitFactor, lastDiv, oFact, hFact, lFact, cFact, vFact)<br />                                                                  newFactor newObs
        |&gt; List.filter (<span style="color:blue;">fun </span>x <span style="color:blue;">-&gt; match </span>x.Event <span style="color:blue;">with </span>Split(_) <span style="color:blue;">-&gt; false </span>| _ <span style="color:blue;">-&gt; true</span>)        </pre>
<p>Wow, ok, this looks messy. Let&rsquo;s go through it. Starting from the bottom: sort the observations, perform the right algorithm and filter away all the splits. It doesn&rsquo;t make sense to have splits in adjusted data.</p>
<p>The interesting piece is the <u>mappAcc</u> function. It take a tuple of factors as accumulator and the usual two functions to update such tuple and create new observations. The <u>newObs</u> function creates a new Observation using the factors in the accumulator tuple. Notice how the dividends are divided by the <u>splitFactor</u> (which is the opposite of our <u>asHappened</u> algorithm where we were multiplying them). Also notice how the prices are divided by both the <u>splitFactor</u> and the pertinent price factor. This is needed because the prices need to be adjusted by the dividends paid out and the adjustment factor is different for each kind of price (i.e. open, close, etc). The <u>newFactor</u> function simply updates all the factors depending on the current observation.</p>
<p>Notice how <u>asHappened</u> and <u>adjusted</u> are structurally similar. This is an artifact of having a functional approach to writing code: it kind of forces you to identify these commonality in the way an algorithm behave and abstract them out (in this case in the <u>mapAcc</u> function). You often discover that such abstracted-out pieces are more generally useful than the case at hand.</p>



  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¶</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¶</h2>
    </header>
    


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>