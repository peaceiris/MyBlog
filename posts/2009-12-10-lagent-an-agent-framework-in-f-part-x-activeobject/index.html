<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff"/>


<meta name="description" content="Download framework here.
All posts are here:
 Part I - Workers and ParallelWorkers Part II - Agents and control messages Part III - Default error management Part IV - Custom error management Part V - Timeout management Part VI - Hot swapping of code Part VII - An auction framework Part VIII ‚Äì Implementing MapReduce (user model) Part IX ‚Äì Counting words ‚Ä¶  If you stare long enough at agents, you start to realize that they are just ‚Äòglorified locks‚Äô.">





<link rel="preload" href="../../fonts/SourceSerifVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../fonts/SourceSansVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<link rel="stylesheet" href="../../css/base.css"> 
<link rel="stylesheet" href="../../css/fonts.css">


  <link rel="preload" href="../../fonts/SourceCodeVariable-Roman.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceCodeVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="../../fonts/SourceSerifVariable-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">



  <title>LAgent: an agent framework in F# ‚Äì Part X ‚Äì ActiveObject | Lucabol blog</title>


<link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
<link rel="manifest" href="../../site.webmanifest">
    </head>
<body>
    <header>
        <div id="topnav">
            <a id="logo" href="../../">‚ùß</a>
            
                <time id="blog_date" > 2009/12/12</time>
            
            <span class="offline">~~ Offline ~~</span>
            <span class="rightnav">
                <a id="theme">theme</a><div class="dropdown-content">
          <a class="font-name" data-classname="OpenDyslexic" >0. OpenDyslexic</a>
          <a class="font-name" data-classname="Cardo" >1. Se Old Style: Cardo (Minion, Gallard, Centaur)</a>
          <a class="font-name" data-classname="CrimsonPro" >1. Se Old Style: Crimson Pro (Century, Palatino, Plantin, Sabon)</a>
          <a class="font-name" data-classname="EBGaramond" >1. Se Old Style: Garamond</a>
          <a class="font-name" data-classname="Gentium" >1. Se Old Style: Gentium</a>
          <a class="font-name" data-classname="GoudyStM" >1. Se Old Style: Sorts Mill Goudy</a>
          <a class="font-name" data-classname="LibreBaskerville" >4. Se Transitional: Libre Bask. (Mrs Eaves)</a>
          <a class="font-name" data-classname="LibreCaslon" >4. Se Transitional: Libre Caslon</a>
          <a class="font-name" data-classname="PT" >4. Se Transitional: PT fonts (Le Monde)</a>
          <a class="font-name" data-classname="SourcePro" >4. Se Transitional: Source Pro (Skolar, Fournier)</a>
          <a class="font-name" data-classname="TimesNewRoman" >4. Se Transitional: Times New Roman</a>
          <a class="font-name" data-classname="CM" >5. Se Didone: Computer Modern</a>
          <a class="font-name" data-classname="OldStandardTT" >5. Se Didone: Old Standard TT (Filosofia, Scotch Modern)</a>
          <a class="font-name" data-classname="STIX2" >5. Se Didone: Stix2</a>
          <a class="font-name" data-classname="Charter" >6. Se Scotch: Charter</a>
          <a class="font-name" data-classname="Georgia" >6. Se Scotch: Georgia</a>
          <a class="font-name" data-classname="WorkSans" >8. Sa Grotesque: Work Sans (All Grotesque, FF Bau, Venus)</a>
          <a class="font-name" data-classname="AntiqueOlive" >9. Sa Geometric: Antique Oliv</a>
          <a class="font-name" data-classname="bahnschrift" >9. Sa Geometric: Bahnschrift</a>
          <a class="font-name" data-classname="CooperHewitt" >9. Sa Geometric: Cooper Hewitt (Calibre)</a>
          <a class="font-name" data-classname="SourceSans" >9. Sa Humanist: Source Sans (Balto, Adelle Sans)</a>
          <a class="font-name" data-classname="URWClassico" >9. Sa Humanist: URW Classico (Optima)</a>
          <a class="font-name" data-classname="FiraSans" >a. Sa Humanist: Fira Sans (FF Meta)</a>
          <a class="font-name" data-classname="Nimbus" >a. Sa Humanist: Nimbus (Helvetica)</a>
          <a class="font-name" data-classname="Roboto" >a. Sa Humanist: Roboto (DIN</a>
          <a class="font-name" data-classname="Munson" >b. Sl Grotesque: Munson (Clarendon)</a>
          <a class="font-name" data-classname="Sanchez" >c. Sl Geometric: Sanchez (Rockwell)</a>
          <a class="font-name" data-classname="Enriqueta" >d. Sl Humanist: Enriqueta (PMN Caecilia)</a>
          <a class="font-name" data-classname="Merriweather" >d. Sl Humanist: Merriweather (Chapparal)</a>
          <a class="font-name" data-classname="profont" >Z. Sa Monospace: Profont</a>
</div>
                <a id="to_nav">Menu</a>
                <nav id="primary_nav">
                    

  <a href="../../MyBlog/">home</a>
  <a href="../../MyBlog/tags/">tags</a>
  <a href="https://www.github.com/lucabol">github</a>
  <a href="https://www.linkedin.com/in/lucabolognese/">linkdin</a>
  <a href="../../MyBlog/search">search</a>
  <a href="../../MyBlog/index.xml">rss</a>
                </nav>
            </span>
        </div>
    <h1 id="title">
    
        LAgent: an agent framework in F# ‚Äì Part X ‚Äì ActiveObject
    
    </h1>

    </header>

    <main>
        

<p>Download framework <a href="http://code.msdn.microsoft.com/LAgent">here</a>.</p>
<p>All posts are here:</p>
<ul>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/05/29/lagent-an-agent-framework-in-f-part-i-workers-and-parallelworkers.aspx">Part I  - Workers and ParallelWorkers</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/06/05/lagent-an-agent-framework-in-f-part-ii-agents-and-control-messages.aspx">Part II  - Agents and control messages</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/06/12/lagent-an-agent-framework-in-f-part-iii-default-error-management.aspx">Part III  - Default error management</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/06/19/lagent-an-agent-framework-in-f-part-iv-custom-error-management.aspx">Part IV  - Custom error management</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/06/26/lagent-an-agent-framework-in-f-part-v-timeout-management.aspx">Part V  - Timeout management</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/07/03/lagent-an-agent-framework-in-f-part-vi-hot-swapping-of-code-and-something-silly.aspx">Part VI  - Hot swapping of code</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/07/10/lagent-an-agent-framework-in-f-part-vii-an-auction-application.aspx">Part VII  - An auction framework</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/09/04/lagent-an-agent-framework-in-f-part-viii-implementing-mapreduce-user-model.aspx">Part VIII ‚Äì Implementing MapReduce (user model)</a></li>
<li><a href="http://blogs.msdn.com/lucabol/archive/2009/09/18/lagent-an-agent-framework-in-f-part-ix-counting-words.aspx">Part IX ‚Äì Counting words ‚Ä¶</a></li>
</ul>
<p>If you stare long enough at agents, you start to realize that they are just ‚Äòglorified locks‚Äô. They are a convenient programming model to protect a resource from concurrent access. The programming model is convenient because both the client and the server can write their code without worrying about concurrency problems, and yet the program runs in parallel. Protecting a resource sounds a lot like state encapsulation and the concept of state encapsulation is what object orientation is all about.</p>
<p>So you start thinking if there is a way to enhance vanilla objects to make them agents. You want to reuse all the concepts that you are familiar with (i.e. inheritance, visibility rules, etc‚Ä¶) and you want your clients to call agents as if they were calling normal objects. Obviously, under the cover, the method calls won‚Äôt execute immediately, but they would be queued. Let‚Äôs look at an example.</p>
<p>This is our simple counter agent:</p>
<pre class="code"><span style="color:blue;">type </span>CounterMessage =
| Add <span style="color:blue;">of </span>int
| Print
<span style="color:blue;">let </span>counterF = <span style="color:blue;">fun </span>msg count <span style="color:blue;">-&gt;
    match </span>msg <span style="color:blue;">with
    </span>| Add(i)    <span style="color:blue;">-&gt; </span>count + i
    | Print     <span style="color:blue;">-&gt; </span>printfn <span style="color:maroon;">"The value is %i" </span>count; count
<span style="color:blue;">let </span>c1 = spawnAgent counterF <span style="color:brown;">0
</span>c1 &lt;-- Add(<span style="color:brown;">3</span>)
c1 &lt;‚ÄîPrint</pre>
<p>As nice as this looks, there are unfamiliar things in this model:</p>
<ol>
<li>The communication is through messages. This requires packing and unpacking which, albeit easy in F#, is unfamiliar and feels like machinery that we‚Äôd like to get rid off.</li>
<li>The management of state is bizarre, it gets passed into the lambda and returned from it instead of being represented as fields and properties on the agent</li>
</ol>
<p>My best attempt at creating an object-like syntax follows:</p>
<pre class="code"><span style="color:blue;">type </span>Counter() =
    <span style="color:blue;">let </span>w = <span style="color:blue;">new </span>WorkQueue()
    <span style="color:blue;">let mutable </span>count = <span style="color:brown;">0
    </span><span style="color:blue;">member </span>c.Add x = w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
        </span>count &lt;- count + x
        )
    <span style="color:blue;">member </span>c.Print () = w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
        </span>printfn <span style="color:maroon;">"The value is %i" </span>count
        )</pre>
<pre class="code"><span style="color:blue;">let </span>c = <span style="color:blue;">new </span>Counter()
c.Add <span style="color:brown;">3
</span>c.Print</pre>
<p>With this syntax, you write your agents like you write your vanilla classes except:</p>
<ol>
<li>You need a private field of type <em>WorkQueue</em></li>
<li>You need to write your methods as lambdas passed to the <em>WorkQueue.Queue</em> function</li>
<li>Your methods cannot return values</li>
</ol>
<p>The most worrisome of these constraints is 2. because you can easily forget about it. If you do forget, then everything compiles just fine, but it doesn‚Äôt do what you expect. That‚Äôs pure badness. I haven‚Äôt found a way to enforce it. This is a place where the language could help me. Other than that, the whole model works rather nicely.</p>
<p>Regarding the third point, you can concoct a programming model that allows you to return values from your methods. Here it is:</p>
<pre class="code"><span style="color:blue;">member </span>c.CountTask = w.QueueWithTask(<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
    </span>count
    )
<span style="color:blue;">member </span>c.CountAsync = w.QueueWithAsync(<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
    </span>count
    )</pre>
<pre class="code">printfn <span style="color:maroon;">"The count using Task is %i" </span>(c.CountTask.Result)</pre>
<p>The first method returns a <em>Task;</em> the second method returns an <em>AsyncResultCell</em>. Both are ways to represent a <a href="http://en.wikipedia.org/wiki/Future_(programming)">promise</a>. The latter allows a natural integration with the async block in F# as in the following code:</p>
<pre class="code">Async.RunSynchronously (
            async {
                <span style="color:blue;">let! </span>count = c.CountAsync
                printfn <span style="color:maroon;">"The countusing Async is %i" </span>count
            })</pre>
<p>As for myself, I don‚Äôt like methods returning values. Every time I use them, I end up going back and thinking about my problem in a traditional way, aka as method calls that return results, instead of thinking about it in a more actor oriented fashion. I end up waiting for these promises to be materialized and, by doing so, I limit the amount of parallelism that I unleash. As a matter of fact, the whole business of hiding the message passing nature of the programming model is dubious. It makes for a nicer syntax, but you need to make an extra effort in your mind to translate it to what it really is: just message passing with a nice syntactical veneer. I haven‚Äôt decided yet which model I like the most.</p>
<p>You should have a sense of what <em>WorkQueue</em> is. In essence, it is a <em>Mailbox</em> of lambdas (look at the red bold code below).</p>
<pre class="code"><span style="color:blue;">type </span>WorkQueue() =
    <font color="#ff0000"><strong><span style="color:blue;">let </span>workQueue = spawnWorker (<span style="color:blue;">fun </span>f <span style="color:blue;">-&gt; </span>f())</strong></font>
    <span style="color:blue;">member </span>w.Queue (f) = workQueue &lt;-- f
    <span style="color:blue;">member </span>w.QueueWithTask f : Task&lt;'T&gt; =
        <span style="color:blue;">let </span>source = <span style="color:blue;">new </span>TaskCompletionSource&lt;_&gt;()
        workQueue &lt;-- (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt; </span>f() |&gt; source.SetResult)
        source.Task
    <span style="color:blue;">member </span>w.QueueWithAsync (f:unit <span style="color:blue;">-&gt; </span>'T) : Async&lt;'T&gt; =
        <span style="color:blue;">let </span>result = <span style="color:blue;">new </span>AsyncResultCell&lt;'T&gt;()
        workQueue &lt;-- (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt; </span>f() |&gt; result.RegisterResult )
        result.AsyncWaitResult
    <span style="color:blue;">member </span>w.Restart () = workQueue &lt;-! Restart
    <span style="color:blue;">member </span>w.Stop () = workQueue &lt;-! Stop
    <span style="color:blue;">member </span>w.SetErrorHandler(h) =
        <span style="color:blue;">let </span>managerF = <span style="color:blue;">fun </span>(_, name:string, ex:Exception, _, _, _) <span style="color:blue;">-&gt; </span>h name ex
        <span style="color:blue;">let </span>manager = spawnWorker managerF
        workQueue &lt;-! SetManager manager
    <span style="color:blue;">member </span>w.SetName(name) = workQueue &lt;-! SetName(name)
    <span style="color:blue;">member </span>w.SetQueueHandler(g) = workQueue &lt;-! SetWorkerHandler(g)
    <span style="color:blue;">member </span>w.SetTimeoutHandler(timeout, f) = workQueue &lt;-! SetTimeoutHandler(timeout, f)</pre>
<p>I implemented all the services that are in the message passing model. The two are equivalent as expressing power goes. In case you wonder how a real piece of code looks like using this model, here is an <em>ActiveObject</em> version of the map reduce algorithm. One of these days, I will gather the strength to go trough this code and explain what it does, but not today üôÇ</p>
<pre class="code"><span style="color:blue;">#load </span><span style="color:maroon;">"AgentSystem.fs"
</span><span style="color:blue;">open </span>AgentSystem.LAgent
<span style="color:blue;">open </span>System
<span style="color:blue;">open </span>System.Collections
<span style="color:blue;">open </span>System.Collections.Generic
<span style="color:blue;">open </span>System.Threading
<span style="color:blue;">type </span>IOutput&lt;'out_key, 'out_value&gt; =
    <span style="color:blue;">abstract </span>Reduced: 'out_key <span style="color:blue;">-&gt; </span>seq&lt;'out_value&gt; <span style="color:blue;">-&gt; </span>unit
    <span style="color:blue;">abstract </span>MapReduceDone: unit <span style="color:blue;">-&gt; </span>unit
<span style="color:blue;">type </span>Mapper&lt;'in_key, 'in_value, 'my_out_key, 'out_value <span style="color:blue;">when </span>'my_out_key : comparison&gt;<br />                                                      (map:'in_key <span style="color:blue;">-&gt; </span>'in_value <span style="color:blue;">-&gt; </span>seq&lt;'my_out_key * 'out_value&gt;, i, partitionF) =
    <span style="color:blue;">let </span>w = <span style="color:blue;">new </span>WorkQueue()
    <span style="color:blue;">let mutable </span>reducerTracker: BitArray = <span style="color:blue;">null
    let mutable </span>controller = Unchecked.defaultof&lt;Controller&lt;'in_key, 'in_value, 'my_out_key, 'out_value&gt;&gt;
    <span style="color:blue;">let mutable </span>reducers = Unchecked.defaultof&lt;Reducer&lt;'in_key, 'in_value, 'my_out_key, 'out_value&gt; array&gt;
    <span style="color:blue;">member </span>m.Init c reds =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>controller &lt;- c
            reducers &lt;- reds
            reducerTracker &lt;- <span style="color:blue;">new </span>BitArray(reducers.Length, <span style="color:blue;">false</span>))
    <span style="color:blue;">member </span>m.Process inKey inValue =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            let </span>outKeyValues = map inKey inValue
            outKeyValues |&gt; Seq.iter (<span style="color:blue;">fun </span>(outKey, outValue) <span style="color:blue;">-&gt;
                                        let </span>reducerUsed = partitionF outKey (reducers.Length)
                                        reducerTracker.Set(reducerUsed, <span style="color:blue;">true</span>)
                                        reducers.[reducerUsed].Add(outKey, outValue)))
    <span style="color:blue;">member </span>m.Done () =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>controller.MapDone i reducerTracker)
    <span style="color:blue;">member </span>m.Stop () = w.Stop ()
<span style="color:blue;">and </span>Reducer&lt;'in_key, 'in_value, 'out_key, 'out_value <span style="color:blue;">when </span>'out_key :<br />                     comparison&gt;(reduce:'out_key <span style="color:blue;">-&gt; </span>seq&lt;'out_value&gt; <span style="color:blue;">-&gt; </span>seq&lt;'out_value&gt;, i, output:IOutput&lt;'out_key, 'out_value&gt;) =
    <span style="color:blue;">let </span>w = <span style="color:blue;">new </span>WorkQueue()
    <span style="color:blue;">let mutable </span>workItems = <span style="color:blue;">new </span>List&lt;'out_key * 'out_value&gt;()
    <span style="color:blue;">let mutable </span>controller = Unchecked.defaultof&lt;Controller&lt;'in_key, 'in_value, 'out_key, 'out_value&gt;&gt;
    <span style="color:blue;">member </span>r.Init c =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>controller &lt;- c)
    <span style="color:blue;">member </span>r.StartReduction () =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>workItems
            |&gt; Seq.groupBy fst
            |&gt; Seq.sortBy fst
            |&gt; Seq.map (<span style="color:blue;">fun </span>(key, values) <span style="color:blue;">-&gt; </span>(key, reduce key (values |&gt; Seq.map snd)))
            |&gt; Seq.iter (<span style="color:blue;">fun </span>(key, value) <span style="color:blue;">-&gt; </span>output.Reduced key value)
            controller.ReductionDone i)
    <span style="color:blue;">member </span>r.Add (outKey:'out_key, outValue:'out_value) : unit =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>workItems.Add((outKey, outValue)))
    <span style="color:blue;">member </span>m.Stop () = w.Stop ()
<span style="color:blue;">and </span>Controller&lt;'in_key, 'in_value, 'out_key, 'out_value <span style="color:blue;">when </span>'out_key : comparison&gt;(output:IOutput&lt;'out_key, 'out_value&gt;) =
    <span style="color:blue;">let </span>w = <span style="color:blue;">new </span>WorkQueue()
    <span style="color:blue;">let mutable </span>mapperTracker: BitArray = <span style="color:blue;">null
    let mutable </span>reducerUsedByMappers: BitArray = <span style="color:blue;">null
    let mutable </span>reducerDone: BitArray = <span style="color:blue;">null
    let mutable </span>mappers = Unchecked.defaultof&lt;Mapper&lt;'in_key, 'in_value, 'out_key, 'out_value&gt; array&gt;
    <span style="color:blue;">let mutable </span>reducers = Unchecked.defaultof&lt;Reducer&lt;'in_key, 'in_value, 'out_key, 'out_value&gt; array&gt;
    <span style="color:blue;">let </span>BAtoSeq (b:BitArray) = [<span style="color:blue;">for </span>x <span style="color:blue;">in </span>b <span style="color:blue;">do yield </span>x]
    <span style="color:blue;">member </span>c.Init maps reds =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>mappers &lt;- maps
            reducers &lt;- reds
            mapperTracker &lt;- <span style="color:blue;">new </span>BitArray(mappers.Length, <span style="color:blue;">false</span>)
            reducerUsedByMappers &lt;- <span style="color:blue;">new </span>BitArray(reducers.Length, <span style="color:blue;">false</span>)
            reducerDone &lt;- <span style="color:blue;">new </span>BitArray(reducers.Length, <span style="color:blue;">false</span>))
    <span style="color:blue;">member </span>c.MapDone (i : int) (reducerTracker : BitArray) : unit =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>mapperTracker.Set(i, <span style="color:blue;">true</span>)
            <span style="color:blue;">let </span>reducerUsedByMappers = reducerUsedByMappers.Or(reducerTracker)
            <span style="color:blue;">if </span>not( BAtoSeq mapperTracker |&gt; Seq.exists(<span style="color:blue;">fun </span>bit <span style="color:blue;">-&gt; </span>bit = <span style="color:blue;">false</span>)) <span style="color:blue;">then
                </span>BAtoSeq reducerUsedByMappers |&gt; Seq.iteri (<span style="color:blue;">fun </span>i r <span style="color:blue;">-&gt; if </span>r = <span style="color:blue;">true then </span>reducers.[i].StartReduction ())
                mappers |&gt; Seq.iter (<span style="color:blue;">fun </span>m <span style="color:blue;">-&gt; </span>m.Stop ())
              )
    <span style="color:blue;">member </span>c.ReductionDone (i: int) : unit =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>reducerDone.Set(i, <span style="color:blue;">true</span>)
            <span style="color:blue;">if </span>BAtoSeq reducerDone |&gt; Seq.forall2 (<span style="color:blue;">fun </span>x y <span style="color:blue;">-&gt; </span>x = y) (BAtoSeq reducerUsedByMappers) <span style="color:blue;">then
                </span>output.MapReduceDone ()
                reducers |&gt; Seq.iter (<span style="color:blue;">fun </span>r <span style="color:blue;">-&gt; </span>r.Stop ())
                c.Stop()
             )
    <span style="color:blue;">member </span>m.Stop () = w.Stop ()
<span style="color:blue;">let </span>mapReduce   (inputs:seq&lt;'in_key * 'in_value&gt;)
                (map:'in_key <span style="color:blue;">-&gt; </span>'in_value <span style="color:blue;">-&gt; </span>seq&lt;'out_key * 'out_value&gt;)
                (reduce:'out_key <span style="color:blue;">-&gt; </span>seq&lt;'out_value&gt; <span style="color:blue;">-&gt; </span>seq&lt;'out_value&gt;)
                (output:IOutput&lt;'out_key, 'out_value&gt;)
                M R partitionF =
    <span style="color:blue;">let </span>len = inputs |&gt; Seq.length
    <span style="color:blue;">let </span>M = <span style="color:blue;">if </span>len &lt; M <span style="color:blue;">then </span>len <span style="color:blue;">else </span>M
    <span style="color:blue;">let </span>mappers = Array.init M (<span style="color:blue;">fun </span>i <span style="color:blue;">-&gt; new </span>Mapper&lt;'in_key, 'in_value, 'out_key, 'out_value&gt;(map, i, partitionF))
    <span style="color:blue;">let </span>reducers = Array.init R (<span style="color:blue;">fun </span>i <span style="color:blue;">-&gt; new </span>Reducer&lt;'in_key, 'in_value, 'out_key, 'out_value&gt;(reduce, i, output))
    <span style="color:blue;">let </span>controller = <span style="color:blue;">new </span>Controller&lt;'in_key, 'in_value, 'out_key, 'out_value&gt;(output)
    mappers |&gt; Array.iter (<span style="color:blue;">fun </span>m <span style="color:blue;">-&gt; </span>m.Init controller reducers)
    reducers |&gt; Array.iter (<span style="color:blue;">fun </span>r <span style="color:blue;">-&gt; </span>r. Init controller )
    controller.Init mappers reducers
    inputs |&gt; Seq.iteri (<span style="color:blue;">fun </span>i (inKey, inValue) <span style="color:blue;">-&gt; </span>mappers.[i % M].Process inKey inValue)
    mappers |&gt; Seq.iter (<span style="color:blue;">fun </span>m <span style="color:blue;">-&gt; </span>m.Done ())
<span style="color:blue;">let </span>partitionF = <span style="color:blue;">fun </span>key M <span style="color:blue;">-&gt; </span>abs(key.GetHashCode()) % M
<span style="color:blue;">let </span>map = <span style="color:blue;">fun </span>(fileName:string) (fileContent:string) <span style="color:blue;">-&gt;
            let </span>l = <span style="color:blue;">new </span>List&lt;string * int&gt;()
            <span style="color:blue;">let </span>wordDelims = [|<span style="color:maroon;">' '</span>;<span style="color:maroon;">','</span>;<span style="color:maroon;">';'</span>;<span style="color:maroon;">'.'</span>;<span style="color:maroon;">':'</span>;<span style="color:maroon;">'?'</span>;<span style="color:maroon;">'!'</span>;<span style="color:maroon;">'('</span>;<span style="color:maroon;">')'</span>;<span style="color:maroon;">'n'</span>;<span style="color:maroon;">'t'</span>;<span style="color:maroon;">'f'</span>;<span style="color:maroon;">'r'</span>;<span style="color:maroon;">'b'</span>|]
            fileContent.Split(wordDelims) |&gt; Seq.iter (<span style="color:blue;">fun </span>word <span style="color:blue;">-&gt; </span>l.Add((word, <span style="color:brown;">1</span>)))
            l :&gt; seq&lt;string * int&gt;
<span style="color:blue;">let </span>reduce = <span style="color:blue;">fun </span>key (values:seq&lt;int&gt;) <span style="color:blue;">-&gt; </span>[values |&gt; Seq.sum] |&gt; seq&lt;int&gt;
<span style="color:blue;">let </span>printer () =
  { <span style="color:blue;">new </span>IOutput&lt;string, int&gt; <span style="color:blue;">with
        member </span>o.Reduced key values = printfn <span style="color:maroon;">"%A %A" </span>key values
        <span style="color:blue;">member </span>o.MapReduceDone () = printfn <span style="color:maroon;">"All done!!"</span>}
<span style="color:blue;">let </span>testInput =<br />     [<span style="color:maroon;">"File1"</span>, <span style="color:maroon;">"I was going to the airport when I saw someone crossing"</span>; <span style="color:maroon;">"File2"</span>, <span style="color:maroon;">"I was going home when I saw you coming toward me"</span>]
mapReduce testInput map reduce (printer ()) <span style="color:brown;">2 2 </span>partitionF
<span style="color:blue;">open </span>System.IO
<span style="color:blue;">open </span>System.Text
<span style="color:blue;">let </span>gatherer(step) =
  <span style="color:blue;">let </span>w = <span style="color:blue;">new </span>WorkQueue()
  <span style="color:blue;">let </span>data = <span style="color:blue;">new </span>List&lt;string * int&gt;()
  <span style="color:blue;">let </span>counter = ref <span style="color:brown;">0
  </span>{ <span style="color:blue;">new </span>IOutput&lt;string, int&gt; <span style="color:blue;">with
        member </span>o.Reduced key values =
            w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
                if </span>!counter % step = <span style="color:brown;">0 </span><span style="color:blue;">then
                    </span>printfn <span style="color:maroon;">"Processed %i words. Now processing %s" </span>!counter key
                data.Add((key, values |&gt; Seq.hd))
                counter := !counter + <span style="color:brown;">1</span>)
        <span style="color:blue;">member </span>o.MapReduceDone () =
            w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
                </span>data
                |&gt; Seq.distinctBy (<span style="color:blue;">fun </span>(key, _) <span style="color:blue;">-&gt; </span>key.ToLower())
                |&gt; Seq.filter (<span style="color:blue;">fun </span>(key, _) <span style="color:blue;">-&gt; </span>not(key = <span style="color:maroon;">"" </span>|| key = <span style="color:maroon;">""" </span>|| (fst (Double.TryParse(key)))))
                |&gt; Seq.to_array
                |&gt; Array.sortBy snd
                |&gt; Array.rev
                |&gt; Seq.take <span style="color:brown;">20
                </span>|&gt; Seq.iter (<span style="color:blue;">fun </span>(key, value) <span style="color:blue;">-&gt; </span>printfn <span style="color:maroon;">"%Att%A" </span>key value)
                printfn <span style="color:maroon;">"All done!!"</span>)
        }
<span style="color:blue;">let </span>splitBook howManyBlocks fileName =
    <span style="color:blue;">let </span>buffers = Array.init howManyBlocks (<span style="color:blue;">fun </span>_ <span style="color:blue;">-&gt; new </span>StringBuilder())
    fileName
    |&gt; File.ReadAllLines
    |&gt; Array.iteri (<span style="color:blue;">fun </span>i line <span style="color:blue;">-&gt; </span>buffers.[i % (howManyBlocks)].Append(line) |&gt; ignore)
    buffers
<span style="color:blue;">let </span>blocks1 = <span style="color:blue;">__SOURCE_DIRECTORY__ </span>+ <span style="color:maroon;">"kjv10.txt" </span>|&gt; splitBook <span style="color:brown;">100
</span><span style="color:blue;">let </span>blocks2 = <span style="color:blue;">__SOURCE_DIRECTORY__ </span>+ <span style="color:maroon;">"warandpeace.txt" </span>|&gt; splitBook <span style="color:brown;">100
</span><span style="color:blue;">let </span>input =
    blocks1
    |&gt; Array.append blocks2
    |&gt; Array.mapi (<span style="color:blue;">fun </span>i b <span style="color:blue;">-&gt; </span>i.ToString(), b.ToString())
<span style="color:green;">//mapReduce input map reduce (gatherer(1000)) 20 20 partitionF
</span><span style="color:blue;">type </span>BookSplitter () =
    <span style="color:blue;">let </span>blocks = <span style="color:blue;">new </span>List&lt;string * string&gt;()
    <span style="color:blue;">member </span>b.Split howManyBlocks fileName =
            <span style="color:blue;">let </span>b =
                fileName
                |&gt; splitBook howManyBlocks
                |&gt; Array.mapi (<span style="color:blue;">fun </span>i b <span style="color:blue;">-&gt; </span>i.ToString(), b.ToString())
            blocks.AddRange(b)
    <span style="color:blue;">member </span>b.Blocks () =
            blocks.ToArray() :&gt; seq&lt;string * string&gt;
<span style="color:blue;">type </span>WordCounter () =
    <span style="color:blue;">let </span>w = <span style="color:blue;">new </span>WorkQueue()
    <span style="color:blue;">let </span>words = <span style="color:blue;">new </span>Dictionary&lt;string,int&gt;()
    <span style="color:blue;">let </span>worker(wordCounter:WordCounter, ev:EventWaitHandle) =
          <span style="color:blue;">let </span>w1 = <span style="color:blue;">new </span>WorkQueue()
          { <span style="color:blue;">new </span>IOutput&lt;string, int&gt; <span style="color:blue;">with
                member </span>o.Reduced key values =
                    w1.Queue (<span style="color:blue;">fun</span>() <span style="color:blue;">-&gt;
                        </span>wordCounter.AddWord key (values |&gt; Seq.hd))
                <span style="color:blue;">member </span>o.MapReduceDone () =
                    w1.Queue(<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
                        </span>ev.Set() |&gt; ignore)
           }
    <span style="color:blue;">member </span>c.AddWord word count =
            <span style="color:blue;">let </span>exist, value = words.TryGetValue(word)
            <span style="color:blue;">if </span>exist <span style="color:blue;">then
                </span>words.[word] &lt;- value + count
            <span style="color:blue;">else
                </span>words.Add(word, count)
    <span style="color:blue;">member </span>c.Add fileName =
        w.Queue (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            let </span>s = <span style="color:blue;">new </span>BookSplitter()
            fileName |&gt; s.Split <span style="color:brown;">100
            </span><span style="color:blue;">let </span>ev = <span style="color:blue;">new </span>EventWaitHandle(<span style="color:blue;">false</span>, EventResetMode.AutoReset)
            <span style="color:blue;">let </span>blocks = s.Blocks ()
            mapReduce blocks map reduce (worker(c, ev)) <span style="color:brown;">20 20 </span>partitionF
            ev.WaitOne() |&gt; ignore
            )
    <span style="color:blue;">member </span>c.Words =
        w.QueueWithAsync (<span style="color:blue;">fun </span>() <span style="color:blue;">-&gt;
            </span>words |&gt; Seq.to_array |&gt; Array.map (<span style="color:blue;">fun </span>kv <span style="color:blue;">-&gt; </span>kv.Key, kv.Value)
        )
<span style="color:blue;">let </span>wc = <span style="color:blue;">new </span>WordCounter()
wc.Add (<span style="color:blue;">__SOURCE_DIRECTORY__ </span>+ <span style="color:maroon;">"kjv10.txt"</span>)
wc.Add (<span style="color:blue;">__SOURCE_DIRECTORY__ </span>+ <span style="color:maroon;">"warandpeace.txt"</span>)
<span style="color:blue;">let </span>wordsToPrint = async {
                    <span style="color:blue;">let! </span>words = wc.Words
                    <span style="color:blue;">return </span>words
                        |&gt; Seq.distinctBy (<span style="color:blue;">fun </span>(key, _) <span style="color:blue;">-&gt; </span>key.ToLower())
                        |&gt; Seq.filter (<span style="color:blue;">fun </span>(key, _) <span style="color:blue;">-&gt; </span>not(key = <span style="color:maroon;">"" </span>|| key = <span style="color:maroon;">""" </span>|| (fst (Double.TryParse(key)))))
                        |&gt; Seq.to_array
                        |&gt; Array.sortBy snd
                        |&gt; Array.rev
                        |&gt; Seq.take <span style="color:brown;">20
                        </span>|&gt; Seq.iter (<span style="color:blue;">fun </span>(key, value) <span style="color:blue;">-&gt; </span>printfn <span style="color:maroon;">"%Att%A" </span>key value)}
Async.RunSynchronously wordsToPrint
Thread.Sleep(<span style="color:brown;">15000</span>)
printfn <span style="color:maroon;">"Closed session"
</span></pre>



  
  <div id="disqus-container">
  
    <button id="disqus-button" onclick="showComments()">Show comments</button>
    <div id="disqus-comments">
      
      
      
        <div id="disqus_thread">
        </div>
        <script type="application/javascript">
          function showComments() {
            var disqus_config = function () {
};
// Build and append comments 
var d = document;
var s = d.createElement('script');
s.async = true;
s.src = '//' + "lucabol" + '.disqus.com/embed.js';
s.setAttribute('data-timestamp', + new Date());
(d.head || d.body).appendChild(s);
            // Remove button
var disqusButton = document.getElementById('disqus-button');
disqusButton.parentNode.removeChild(disqusButton); 
// Un-hide comments
var disqusComments = document.getElementById('disqus-comments');
disqusComments.style.display = 'block'; 
          }
        </script>
      
      <noscript>Enable JavaScript to view Disqus comments.</noscript>
    </div>
  
</div>




    </main>

    <aside id="sidebar-left">
        
<div id="tags">
  <header>
    <h1>Tags</h1>
      
    <h2>¬∂</h2>
    
  </header>
  
    
    <nav>
      <ul>
        
            <li><a href="../../MyBlog/tags/fsharp">fsharp</a></li>
        
      </ul>
    </nav>
    
  
</div>

    </aside>

    <aside id="sidebar-right">
        <section id="TOC">
        
  
    <header>
        <h1>Table of contents</h1>
        <h2>¬∂</h2>
    </header>
    


        </section>
    </aside>

    <a id="to_top" href="#top">Top</a>
    <footer>
        
    </footer>

    <script>
    const th = document.querySelector("#theme")
    th.addEventListener("click", e => {
        const x = document.querySelector(".dropdown-content")
        if (x.style.display === "block") {
            x.removeAttribute("style")
        } else {
            x.style.display = "block";
        }
    })
    const children = document.querySelectorAll(".font-name")
    const allStyles = Array.from(children).map(c => c.dataset.classname)

    const defaultStyle = "TimesNewRoman"
    const retrievedStyle = localStorage.getItem("Style")
    const style = allStyles.includes(retrievedStyle) ? retrievedStyle : defaultStyle
    document.body.className = style;

    const fontEl = document.querySelector(".dropdown-content")
    fontEl.addEventListener("click", e => {
        const el = e.target
        const style = el.dataset.classname
        document.body.className = style;
        localStorage.setItem("Style", style)
    })



</script>
    <script>
const init = () => {

    
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    
    window.ga = window.ga || ((...args) => (ga.q = ga.q || []).push(args));

    ga('create', 'UA-133194891-1', 'auto');
    ga('set', 'transport', 'beacon');
    ga('send', 'pageview');
};


window.addEventListener('load', init);
</script>
    <script>
    if("serviceWorker" in navigator){
        navigator.serviceWorker.register("/sw.js");
    }
</script>
    <script>
    window.addEventListener('offline', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.add("show")
        window.caches.keys().then(strikeNonCached)
    })
    window.addEventListener('online', (e) => {
        const els = document.getElementsByClassName('offline')
        for(const el of els)
            el.classList.remove("show")

        const as = document.querySelectorAll('main a')
        for(const a of as)
            a.classList.remove('strike')
    })

    const strikeNonCached = cacheKeys => {
        caches.open(cacheKeys[0]).then(cache =>
            cache.keys().then(keys => {
                const as = document.querySelectorAll('main a')
                const urls = keys.map(k => k.url)
                for(const a of as)
                    if(urls.indexOf(a.href) === -1)    
                        a.classList.add('strike')
    }))}

    if(navigator.onLine)
        window.dispatchEvent(new Event('online'))
    else
        window.dispatchEvent(new Event('offline'))

</script>
    <script>
function variableResize() {

  
  let bodyStyles = window.getComputedStyle(document.body);	
	
  let root = document.documentElement;
	
	
	const maxWindowSize = bodyStyles.getPropertyValue('--bp-xlarge') * 16;
	const minWindowSize = bodyStyles.getPropertyValue('--bp-small') * 16;
	
	
	const windowWidth = window.innerWidth
	
  
  const pWidthVar = '--p-wdth';
	const pMinFontWidth = bodyStyles.getPropertyValue('--p-wdth-min');
	const pMaxFontWidth = bodyStyles.getPropertyValue('--p-wdth-max');
	scale(pWidthVar, pMinFontWidth, pMaxFontWidth);

  const pWeightVar = '--p-wght';
	const pMinFontWeight = bodyStyles.getPropertyValue('--p-wght-min');
	const pMaxFontWeight = bodyStyles.getPropertyValue('--p-wght-max');
	scale(pWeightVar, pMinFontWeight, pMaxFontWeight);
	
  const h1WidthVar = '--h1-wdth';
	const h1MinFontWidth = bodyStyles.getPropertyValue('--h1-wdth-min');
	const h1MaxFontWidth = bodyStyles.getPropertyValue('--h1-wdth-max');
	scale(h1WidthVar, h1MinFontWidth, h1MaxFontWidth);

  const h1WeightVar = '--h1-wght';
	const h1MinFontWeight = bodyStyles.getPropertyValue('--h1-wght-min');
	const h1MaxFontWeight = bodyStyles.getPropertyValue('--h1-wght-max');
	scale(h1WeightVar, h1MinFontWeight, h1MaxFontWeight);
	
  const h2WidthVar = '--h2-wdth';
	const h2MinFontWidth = bodyStyles.getPropertyValue('--h2-wdth-min');
	const h2MaxFontWidth = bodyStyles.getPropertyValue('--h2-wdth-max');
	scale(h2WidthVar, h2MinFontWidth, h2MaxFontWidth);

  const h2WeightVar = '--h2-wght';
	const h2MinFontWeight = bodyStyles.getPropertyValue('--h2-wght-min');
	const h2MaxFontWeight = bodyStyles.getPropertyValue('--h2-wght-max');
	scale(h2WeightVar, h2MinFontWeight, h2MaxFontWeight);
	
	function scale(varName, minValue, maxValue) {
		
		minValue = minValue * 1;
		maxValue = maxValue * 1;

		
		const percent = (windowWidth - minWindowSize) / (maxWindowSize - minWindowSize);
		if (maxValue < minValue) {
			var valueScale = minValue - (percent * (minValue - maxValue));
		} else {
			var valueScale = (percent * (maxValue - minValue)) + minValue;
		}
	  
		
		const newValue = windowWidth > maxWindowSize
		   ? maxValue 
		   : windowWidth < minWindowSize 
				? minValue 
				: valueScale;
	   
		
		root.style.setProperty(varName, newValue);
	}
}

window.addEventListener("load", variableResize);
window.addEventListener("resize", variableResize);

</script>
    <script>
  const el = document.querySelector("#to_nav")
  el.addEventListener("click", e => {
    const x = document.querySelector("#primary_nav")
    if (x.style.display === "block") {
      x.removeAttribute("style")
    } else {
      x.style.display = "block";
    }
  })
  window.addEventListener('click', e => {
    const x = document.querySelector("#primary_nav")
    const y = document.querySelector("#to_nav")
    if (!y.contains(e.target) && x.style.display === "block") {
      x.removeAttribute("style")
    } 

    const th = document.querySelector("#theme")
    const x1 = document.querySelector(".dropdown-content")

    if (!th.contains(e.target) && ! x1.contains(e.target) && x1.style.display === "block") {
      x1.removeAttribute("style")
    } 
  })
</script>

</body>
</html>